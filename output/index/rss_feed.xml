<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mathematica Tutorial</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial</link>
    <atom:link href="https://www.wolframcloud.com/objects/b3m2a1/tutorial/index/rss_feed.xml" rel="self" type="application/rss+xml" />
    <image>
      <url>https://www.wolframcloud.com/objects/b3m2a1/tutorial/favicon-32x32.png</url>
      <title>Mathematica Tutorial</title>
      <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial</link>
    </image>
    <description>Mathematica Tutorial</description>
  <item>
    <title>Trott-Strzebonski</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/trottstrzebonski.html</link>
    <description>
        Trott-Strzebonski (replace with evaluation)  This is the pattern we saw earlier for replacing a part of an expression with an evaluated expression:      Hold[holdReplace]/.{holdReplace:&gt;With[{eval=Integrate[Sin[], {, 2, }]}, eval/;True]} (*Out:*) Hold[1+Cos[2]]    It is a nice trick to keep in mind for those cases when you need to insert something into a held context and it would be too much of a pain to wrap everything in a With .  This pattern is really a side-effect of the way scoping constructs work in Mathematica. By placing a Condition (/;) at the end of a scoping construct the whole construct evaluates or not depending on that condition.  We take advantage of the fact that the scoping construct will always scan to the end if there is a condition there, plus the fact that With inserts values, not symbols, to force the evaluated chunk of code to be inserted in our otherwise unevaluated structure.      See Also:    https://mathematica.stackexchange.com/questions/29317/replacement-inside-held-expression
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/trottstrzebonski.html</guid>
    <pubDate>Tue 17 Jul 2018 14:19:18</pubDate>
  </item>
  <item>
    <title>Villegas-Gayley</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/villegasgayley.html</link>
    <description>
        Villegas-Gayley (internal function overloads)  This is a way we can assign definitions to built-in functions cleanly. This takes advantage of a two main things, a conditional definition and the power of Block . We&#39;ll use it to overload how MessageName works.      Unprotect@MessageName; (MessageName[o_,a:Except[&quot;usage&quot;]]/;!TrueQ@$recursionBreakingVariable):= If[ MatchQ[o,object[_Association]], First[o][a], Block[{$recursionBreakingVariable=True}, MessageName[o,a] ] ]; Protect@MessageName;    Now we can do fun things with the MessageName operator, ::     object[&lt;|&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f|&gt;]::a (*Out:*) b    Usually that would have thrown an error:      abject[&lt;|&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f|&gt;]::a         Message::name:       Message name MessageName[abject[Association[&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f]],&quot;a&quot;] is not of the form symbol::name or symbol::name::language.           (*Out:*) MessageName[abject[Association[&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f]],&quot;a&quot;]    And the reason we did this the way we did is because if we assigned some object to a variable, variable::a would give us something meaningless. See:      variable=abject[&lt;|&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f|&gt;]; variable::a (*Out:*) variable::a    But if it&#39;s an object it will be treated differently:      variable=object[&lt;|&quot;a&quot;-&gt;b,&quot;c&quot;-&gt;d,&quot;e&quot;-&gt;f|&gt;]; variable::a (*Out:*) b    And because of the structure of the overload, MessageName still works normally in every other case.      See Also:    https://mathematica.stackexchange.com/questions/39711/understanding-villegas-gayley
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/villegasgayley.html</guid>
    <pubDate>Wed 18 Jul 2018 21:38:13</pubDate>
  </item>
  <item>
    <title>Import and ReadList</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/import-and-readlist.html</link>
    <description>
        Import and ReadList  Import has a peculiar feature. It requires vastly more memory than the size of the file being imported, which can lead to nasty behavior, sometimes. To get around this one would think of importing line-by-line as one does in python or C++ and the ReadLine function seems perfect for the job.  Unfortunately ReadLine is horrendously slow. So the better thing to do is to use ReadList , line, by line on an InputStream object.  For example, let&#39;s make an input stream from the following URL:      textFile= URLDownload[ &quot;https://www.w3.org/TR/PNG/iso_8859-1.txt&quot;, FileNameJoin@{$TemporaryDirectory,&quot;read_list_example.txt&quot;} ]; textStream=OpenRead@textFile (*Out:*)       Now let&#39;s read some lines using ReadLine and do the same with ReadList and compare the performance. First iterated ReadLine :      AbsoluteTiming@ Table[ ReadLine@textStream, 25 ]       (*Out:*) {0.001708, {The following are the graphical (non-control) characters defined by,ISO 8859-1 (1987). Descriptions in words aren&#39;t all that helpful,,but they&#39;re the best we can do in text. A graphics file illustrating,the character set should be available from the same archive as this,file.,Hex Description Hex Description,20 SPACE,21 EXCLAMATION MARK A1 INVERTED EXCLAMATION MARK,22 QUOTATION MARK A2 CENT SIGN,23 NUMBER SIGN A3 POUND SIGN,24 DOLLAR SIGN A4 CURRENCY SIGN,25 PERCENT SIGN A5 YEN SIGN,26 AMPERSAND A6 BROKEN BAR,27 APOSTROPHE A7 SECTION SIGN,28 LEFT PARENTHESIS A8 DIAERESIS,29 RIGHT PARENTHESIS A9 COPYRIGHT SIGN,2A ASTERISK AA FEMININE ORDINAL INDICATOR,2B PLUS SIGN AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK,2C COMMA AC NOT SIGN,2D HYPHEN-MINUS AD SOFT HYPHEN,2E FULL STOP AE REGISTERED SIGN,2F SOLIDUS AF OVERLINE,30 DIGIT ZERO B0 DEGREE SIGN,31 DIGIT ONE B1 PLUS-MINUS SIGN,32 DIGIT TWO B2 SUPERSCRIPT TWO } }    Then iterated ReadList (although of course in general we will want to do this in batches):      AbsoluteTiming@ Table[ ReadList[textStream, String, 1], 25]       (*Out:*) {0.00014, { {33 DIGIT THREE B3 SUPERSCRIPT THREE},{34 DIGIT FOUR B4 ACUTE ACCENT},{35 DIGIT FIVE B5 MICRO SIGN},{36 DIGIT SIX B6 PILCROW SIGN},{37 DIGIT SEVEN B7 MIDDLE DOT},{38 DIGIT EIGHT B8 CEDILLA},{39 DIGIT NINE B9 SUPERSCRIPT ONE},{3A COLON BA MASCULINE ORDINAL INDICATOR},{3B SEMICOLON BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK},{3C LESS-THAN SIGN BC VULGAR FRACTION ONE QUARTER},{3D EQUALS SIGN BD VULGAR FRACTION ONE HALF},{3E GREATER-THAN SIGN BE VULGAR FRACTION THREE QUARTERS},{3F QUESTION MARK BF INVERTED QUESTION MARK},{40 COMMERCIAL AT C0 CAPITAL LETTER A WITH GRAVE},{41 CAPITAL LETTER A C1 CAPITAL LETTER A WITH ACUTE},{42 CAPITAL LETTER B C2 CAPITAL LETTER A WITH CIRCUMFLEX},{43 CAPITAL LETTER C C3 CAPITAL LETTER A WITH TILDE},{44 CAPITAL LETTER D C4 CAPITAL LETTER A WITH DIAERESIS},{45 CAPITAL LETTER E C5 CAPITAL LETTER A WITH RING ABOVE},{46 CAPITAL LETTER F C6 CAPITAL LETTER AE},{47 CAPITAL LETTER G C7 CAPITAL LETTER C WITH CEDILLA},{48 CAPITAL LETTER H C8 CAPITAL LETTER E WITH GRAVE},{49 CAPITAL LETTER I C9 CAPITAL LETTER E WITH ACUTE},{4A CAPITAL LETTER J CA CAPITAL LETTER E WITH CIRCUMFLEX},{4B CAPITAL LETTER K CB CAPITAL LETTER E WITH DIAERESIS}}}    You&#39;ll notice the performance is drastically different. Even getting the proper text as opposed to the list structure has no discernible effect.      AbsoluteTiming@ Table[ First@ReadList[textStream,String,1], 25]       (*Out:*) {0.000126, {4C CAPITAL LETTER L CC CAPITAL LETTER I WITH GRAVE,4D CAPITAL LETTER M CD CAPITAL LETTER I WITH ACUTE,4E CAPITAL LETTER N CE CAPITAL LETTER I WITH CIRCUMFLEX,4F CAPITAL LETTER O CF CAPITAL LETTER I WITH DIAERESIS,50 CAPITAL LETTER P D0 CAPITAL LETTER ETH (Icelandic),51 CAPITAL LETTER Q D1 CAPITAL LETTER N WITH TILDE,52 CAPITAL LETTER R D2 CAPITAL LETTER O WITH GRAVE,53 CAPITAL LETTER S D3 CAPITAL LETTER O WITH ACUTE,54 CAPITAL LETTER T D4 CAPITAL LETTER O WITH CIRCUMFLEX,55 CAPITAL LETTER U D5 CAPITAL LETTER O WITH TILDE,56 CAPITAL LETTER V D6 CAPITAL LETTER O WITH DIAERESIS,57 CAPITAL LETTER W D7 MULTIPLICATION SIGN,58 CAPITAL LETTER X D8 CAPITAL LETTER O WITH STROKE,59 CAPITAL LETTER Y D9 CAPITAL LETTER U WITH GRAVE,5A CAPITAL LETTER Z DA CAPITAL LETTER U WITH ACUTE,5B LEFT SQUARE BRACKET DB CAPITAL LETTER U WITH CIRCUMFLEX,5C REVERSE SOLIDUS DC CAPITAL LETTER U WITH DIAERESIS,5D RIGHT SQUARE BRACKET DD CAPITAL LETTER Y WITH ACUTE,5E CIRCUMFLEX ACCENT DE CAPITAL LETTER THORN (Icelandic),5F LOW LINE DF SMALL LETTER SHARP S (German),60 GRAVE ACCENT E0 SMALL LETTER A WITH GRAVE,61 SMALL LETTER A E1 SMALL LETTER A WITH ACUTE,62 SMALL LETTER B E2 SMALL LETTER A WITH CIRCUMFLEX,63 SMALL LETTER C E3 SMALL LETTER A WITH TILDE,64 SMALL LETTER D E4 SMALL LETTER A WITH DIAERESIS}}    Now this file is a text file that contains hex integer-description pairs, so let&#39;s pull these out as rules. We&#39;ll do this using patterns, Reap and Sow . Note that the relevant data looks like &quot;&lt;key&gt; description&quot; so we&#39;ll use StringReplace on that pattern.      Replace[ Reap@Do[ With[{f=ReadList[textStream,String,1]}, If[MatchQ[f,{}], Replace[ ReadLine@textStream,{ EndOfFile:&gt;Return[], s_String:&gt; StringReplace[s, key__~~&quot; &quot;~~desc__~~(&quot; &quot;|EndOfString):&gt;Sow@{key,desc}] }], StringReplace[First@f, key:(Except[&quot; &quot;]..)~~&quot; &quot;~~desc:Shortest[__]~~(&quot; &quot;|EndOfString):&gt;Sow@{key,desc}] ] ],  ], {_,{data_}}:&gt;data ]       (*Out:*) { {65,SMALL LETTER E},{E5,SMALL LETTER A WITH RING ABOVE},{66,SMALL LETTER F},{E6,SMALL LETTER AE},{67,SMALL LETTER G},{E7,SMALL LETTER C WITH CEDILLA},{68,SMALL LETTER H},{E8,SMALL LETTER E WITH GRAVE},{69,SMALL LETTER I},{E9,SMALL LETTER E WITH ACUTE},{6A,SMALL LETTER J},{EA,SMALL LETTER E WITH CIRCUMFLEX},{6B,SMALL LETTER K},{EB,SMALL LETTER E WITH DIAERESIS},{6C,SMALL LETTER L},{EC,SMALL LETTER I WITH GRAVE},{6D,SMALL LETTER M},{ED,SMALL LETTER I WITH ACUTE},{6E,SMALL LETTER N},{EE,SMALL LETTER I WITH CIRCUMFLEX},{6F,SMALL LETTER O},{EF,SMALL LETTER I WITH DIAERESIS},{70,SMALL LETTER P},{F0,SMALL LETTER ETH (Icelandic)},{71,SMALL LETTER Q},{F1,SMALL LETTER N WITH TILDE},{72,SMALL LETTER R},{F2,SMALL LETTER O WITH GRAVE},{73,SMALL LETTER S},{F3,SMALL LETTER O WITH ACUTE},{74,SMALL LETTER T},{F4,SMALL LETTER O WITH CIRCUMFLEX},{75,SMALL LETTER U},{F5,SMALL LETTER O WITH TILDE},{76,SMALL LETTER V},{F6,SMALL LETTER O WITH DIAERESIS},{77,SMALL LETTER W},{F7,DIVISION SIGN},{78,SMALL LETTER X},{F8,SMALL LETTER O WITH STROKE},{79,SMALL LETTER Y},{F9,SMALL LETTER U WITH GRAVE},{7A,SMALL LETTER Z},{FA,SMALL LETTER U WITH ACUTE},{7B,LEFT CURLY BRACKET},{FB,SMALL LETTER U WITH CIRCUMFLEX},{7C,VERTICAL LINE},{FC,SMALL LETTER U WITH DIAERESIS},{7D,RIGHT CURLY BRACKET},{FD,SMALL LETTER Y WITH ACUTE},{7E,TILDE},{FE,SMALL LETTER THORN (Icelandic)},{FF,SMALL LETTER Y WITH DIAERESIS}}    There&#39;s a lot of boiler plate here, but I&#39;ll leave it up to you to make a macro that will deal with all of that for any future imports.  Just remember, when one has to process a large file or needs a special import mechanism, this is often the best way to do it, otherwise a simple Import is likely fastestalthough there are cases where this does not hold, and if a file takes particularly long to load, using ReadList can be faster.      See Also:    https://mathematica.stackexchange.com/questions/35371/speeding-up-import-and-export-in-csv-format
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/import-and-readlist.html</guid>
    <pubDate>Wed 18 Jul 2018 22:10:42</pubDate>
  </item>
  <item>
    <title>CurrentValue and FrontEndTokens</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/currentvalue-and-frontendtokens.html</link>
    <description>
        CurrentValue and FrontEndTokens  As mentioned briefly under Highly Useful Functionality  Kernels and Remote Computations Mathematica has a device called a FrontEndToken for accessing front end methods and information.    FrontEndToken  In general, how this is structured is the following:      FrontEndToken[token_String]    or      FrontEndToken[feobject_,token_String]    And then the front end is actually accessed via FrontEndExecute . We can use this to, say, copy the previous cell as plaintext and paste it:      SelectionMove[PreviousCell@PreviousCell[],All,Cell]; FrontEndTokenExecute[&quot;CopySpecial&quot;,&quot;Text&quot;]; SelectionMove[EvaluationCell[],After,Cell]; FrontEndTokenExecute[&quot;Paste&quot;];    Via front end tokens, its possible to do pretty much everything the front end can. A somewhat exhaustive list of them is presented below:      (*Out:*)       Each button in that list executes FrontEndTokenExecute[token] so test them out for yourself. Beware that many might be dangerous.  You may know or recall that there are a series of event specifications that can be passed to EventHandler , CellEventActions , NotebookEventActions , and FrontEndEventActions . There are a number of documented event specifications, but there is one critical class of these that is missing. It looks like this:      {&quot;MenuCommand&quot;,token_}    This catches the front end event called by FrontEndTokenExecute[token] . Among the many uses of this, it can be used for changing the way an InputField evaluates using the &quot;HandleShiftReturn&quot; token:      validationFunction[variable_]:= (variable=StringReplace[variable,Except[DigitCharacter]-&gt;&quot;&quot;]); validationFunction~SetAttributes~HoldFirst; InputField[Dynamic[var],String]~EventHandler~{ {&quot;MenuCommand&quot;,&quot;HandleShiftReturn&quot;}:&gt;validationFunction[var]}    Now whenever you press + , validationFunction is applied. This is useful if you dont want to put your side-effects as the second argument to Dynamic .  This can also be used to make notebooks with custom actions, for, say, a save event:      CreateDocument[{ Cell[&quot;&quot;,&quot;TopBarCell&quot;], Cell[&quot;Try saving this notebook&quot;,&quot;Text&quot;]}, NotebookEventActions{ {&quot;MenuCommand&quot;,&quot;Save&quot;} FrontEndExecute@ FrontEnd`AttachCell[ First@Cells[], Cell[TextData[{&quot;Notebook cannot be saved via the front end. Try &quot;,ToBoxes@Unevaluated@Style[NotebookSave[],&quot;Input&quot;]}],&quot;Text&quot;,FontColorRed], {Automatic,{Left,Bottom}}, {Left,Top}, &quot;ClosingActions&quot;{&quot;OutsideMouseClick&quot;} ], {&quot;MenuCommand&quot;,&quot;SaveRename&quot;} FrontEndExecute@ FrontEnd`AttachCell[ First@Cells[], Cell[TextData[{&quot;Notebook cannot be deleted via the front end. Try &quot;,ToBoxes@Unevaluated@Style[NotebookClose[],&quot;Input&quot;]}],&quot;Text&quot;,FontColorRed], {Automatic,{Left,Bottom}}, {Left,Top}, &quot;ClosingActions&quot;{&quot;OutsideMouseClick&quot;} ] }, StyleDefinitions Notebook[{ Cell[StyleData[StyleDefinitions&quot;Default.nb&quot;]], Cell[StyleData[&quot;TopBarCell&quot;], CellMargins{ {0, 0}, {15, 0}}, CellFrame{ {0,0},{2,0}}, &quot;CellFrameStyle&quot;GrayLevel[.8], BackgroundGrayLevel[.9] ] }], WindowSize{500,400}]     CurrentValue  In many ways, CurrentValue is just a wrapper to Options , SetOptions , and FrontEndToken but this makes it powerful.  For instance, we can use it to query style options:      CurrentValue@{&quot;StyleDefinitions&quot;,&quot;Section&quot;,&quot;Background&quot;} (*Out:*)       Figure out what the current selection in a notebook is (restricted to content):      SelectionMove[EvaluationCell[],All,CellContents]; CurrentValue@&quot;SelectionData&quot; (*Out:*) RowBox[{RowBox[{RowBox[{&quot;SelectionMove&quot;,&quot;[&quot;,RowBox[{RowBox[{&quot;EvaluationCell&quot;,&quot;[&quot;,&quot;]&quot;}],&quot;,&quot;,&quot;All&quot;,&quot;,&quot;,&quot;CellContents&quot;}],&quot;]&quot;}],&quot;;&quot;}],&quot; &quot;,RowBox[{&quot;CurrentValue&quot;,&quot;@&quot;,&quot;\&quot;SelectionData\&quot;&quot;}]}]    And determine whether a modifier key is pressed or not:      Dynamic@CurrentValue[&quot;ShiftKey&quot;]    It can also be used to set options:      CurrentValue[EvaluationCell[],&quot;Background&quot;]=RandomColor[]; Pause[.5]; CurrentValue[EvaluationCell[],&quot;Background&quot;]=None;
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/currentvalue-and-frontendtokens.html</guid>
    <pubDate>Fri 29 Dec 2017 23:23:44</pubDate>
  </item>
  <item>
    <title>Info Scraping</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/info-scraping.html</link>
    <description>
        Info Scraping  Mathematica, being so symbolic, is a particularly easy language to scrape and get information from, particularly given the rich pattern language it supports.  Because of this, we can learn a lot by simply pulling relevant info from the source files of the program. First we need a way to get the source files:      internalFiles[namePattern_,directoryExtensions___,depth:_Integer|:]:= FileNames[namePattern, FileNameJoin@{ $InstallationDirectory, directoryExtensions }, depth];    Then we can pull things from these according to a pattern:      expressionsSearch[pat_,files__]:= Table[ f-&gt;Quiet@ Cases[ Switch[FileExtension@f, &quot;m&quot;|&quot;wl&quot;, Import[f,&quot;HeldExpressions&quot;], _, Import[f] ], pat,  ], {f,Replace[Hold[files], Except@Hold[_List]internalFiles[files] ]} ]//DeleteDuplicates;    Well use this to figure out how CurrentValue is used in Mathematicas built-in stylesheets:      Join@@Last/@expressionsSearch[c:_CurrentValueHoldForm[c], &quot;*.nb&quot;,&quot;SystemFiles&quot;,&quot;FrontEnd&quot;,&quot;StyleSheets&quot;]//DeleteDuplicates//Sort (*Out:*) {CurrentValue[&quot;ControlsFontFamily&quot;],CurrentValue[&quot;ControlsFontSize&quot;],CurrentValue[&quot;HyperlinkModifierKey&quot;],CurrentValue[&quot;MenuFontFamily&quot;],CurrentValue[&quot;MenuFontSize&quot;],CurrentValue[&quot;MouseOver&quot;],CurrentValue[&quot;PanelBackground&quot;],CurrentValue[&quot;PanelFontFamily&quot;],CurrentValue[&quot;PanelFontSize&quot;],CurrentValue[&quot;ShiftKey&quot;],CurrentValue[&quot;ToolbarBackground&quot;],CurrentValue[&quot;TooltipFontFamily&quot;],CurrentValue[&quot;TooltipFontSize&quot;],CurrentValue[&quot;TooltipFrameMargins&quot;],CurrentValue[Enabled],CurrentValue[Evaluatable],CurrentValue[{&quot;SystemColor&quot;,&quot;DialogText&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;DialogTextDisabled&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;Menu&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;MenuText&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;Tooltip&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;TooltipFrame&quot;}],CurrentValue[{&quot;SystemColor&quot;,&quot;TooltipText&quot;}],CurrentValue[{StyleHints,&quot;CodeFont&quot;}],CurrentValue[EvaluationNotebook[],WindowElements],CurrentValue[EvaluationNotebook[],WindowMargins],CurrentValue[EvaluationNotebook[],WindowSize],CurrentValue[EvaluationNotebook[],{AutoStyleOptions,&quot;StringStyle&quot;}],CurrentValue[EvaluationNotebook[],{TaggingRules,&quot;ExampleCounter&quot;}],CurrentValue[EvaluationNotebook[],{TaggingRules,&quot;SlideShowSettings&quot;,&quot;WindowSize&quot;}]}    Theres a lot of info in the source files and by doing things like this you can mine a lot of it.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/info-scraping.html</guid>
    <pubDate>Fri 29 Dec 2017 17:18:09</pubDate>
  </item>
  <item>
    <title>Object Oriented Programming</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/object-oriented-programming.html</link>
    <description>
        Object Oriented Programming  Mathematica is a functional programming language, which, for the purposes of the current discussion, basically means that everything has a purely symbolic representation. Often we talk about things not have state which is to say, they dont have attributes.  This makes Mathematica code very deterministic and results easy to store, but sometimes using something with state can be useful. We call these things with state objects and so programming with things with state is called object oriented programming (OOP).  This is a very powerful programming paradigm and, in fact, the (probably) most popular languages are all object-oriented. Java, Python, and C++ all make extensive use of objects in the form of classes, instances, templates, interfaces, etc.  We can work OOP into our standard Mathematica programming, although it can be a tough job to do.    Association Interfaces  The simplest and probably most widely used form of OOP in Mathematica isnt true OOP. We still have symbolic stateless objects, but, critically, it looks like they have state.  The basic idea is that our object will be defined by an association, then well give it a head so that it can be easily distinguished for pattern matching and operator overloading.  Well do this for an object called SphereObject  First, we need a nice way to make a new one of these:      SphereObject[attrs:(_Rule|_RuleDelayed...)]:= SphereObject[ Merge[{&lt;|&quot;Radius&quot;1,&quot;Color&quot;White,&quot;Position&quot;{0,0,0}|&gt;,&lt;|attrs|&gt;},First] ];    Then well need a way to set and get attributes. Well do this via SubValues . To be extra fancy, well also write it so that if our returned argument is a Function , that gets called with the object and passed arguments:      SphereObject[attrs_Association][k_,args___]:= With[{r=attrs[k]}, If[MatchQ[r,_Function], r[SphereObject[attrs],args], r ] ];    Then do something for setting / removing attributes with UpValues :      SphereObject/:HoldPattern[ Set[SphereObject[attrs_Association][k_],v_] ]:=SphereObject[Append[attrs,k-&gt;v]]; SphereObject/:HoldPattern[ SetDelayed[SphereObject[attrs_Association][k_],v_] ]:=SphereObject[Append[attrs,k:&gt;v]]; SphereObject/:HoldPattern[ Unset[SphereObject[attrs_Association][k_]] ]:=SphereObject[KeyDrop[attrs,k]];    Last, assign some Format form to the object:      Format[SphereObject[attrs_]]:= With[{ r=Replace[attrs[&quot;Radius&quot;],_Missing1], c=Replace[attrs[&quot;Color&quot;],_MissingWhite], p=Replace[attrs[&quot;Position&quot;],_Missing{0,0,0}] }, Interpretation[ Deploy@ Style[ Row@{&quot;SphereObject&quot;,&quot;[&quot;, Graphics3D[{c,Sphere[p,r]}, Lighting&quot;Neutral&quot;, BoxedFalse, Method{&quot;ShrinkWrap&quot; -&gt; True}], &quot;]&quot;},ShowStringCharactersFalse], SphereObject[attrs] ] ]; SphereObject[] (*Out:*)          SphereObject[&quot;Color&quot;Red] (*Out:*)       Note that we can pull values from these objects:        (*Out:*)       And we can set them:        (*Out:*)       And unset them        (*Out:*)       Each of these is really just an Association at heart, though. There is no state. These arent real objects.    Managed Types  To get state, we have to track state. And to track state, we need some form of state manager. So well take a hint from our front end objects and write our own and then define objects relative to that.  This time well make a StringObject  Well start with a manager. Just an association that will track things by ever-increasing ID.      $StringObjectCounter=1; $StringObjectManager=&lt;||&gt;;    Then a constructor, once more, but this time the constructor adds an entry to the manager table:      StringObject[s:_String:&quot;&quot;,styleSpecs:((_Rule|_RuleDelayed)...)]:=( $StringObjectManager[$StringObjectCounter]= &lt;|&quot;String&quot;s,styleSpecs|&gt;; StringObject[$StringObjectCounter++] );    Well use the same attribute get / set structure as before, except this time routed through an ID:      StringObject[ID_][k_,args___]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], With[{r=attrs[k]}, If[MatchQ[r,_Function], r[StringObject[ID],args], r ] ], Missing[&quot;NoObject&quot;,StringObject[ID]] ] ]; StringObject/:HoldPattern[ Set[StringObject[ID_][k_],v_] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], $StringObjectManager[ID][k]=v, Missing[&quot;NoObject&quot;,StringObject[ID]] ] ]; StringObject/:HoldPattern[ SetDelayed[StringObject[ID_][k_],v_] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], $StringObjectManager[ID][k]:=v, Missing[&quot;NoObject&quot;,StringObject[ID]] ] ]; StringObject/:HoldPattern[ Unset[StringObject[ID_][k_]] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], KeyDropFrom[$StringObjectManager[ID],k];, Missing[&quot;NoObject&quot;,StringObject[ID]] ] ];    And build a similar format although this time well want a special format if the object doesnt exist:      Format[StringObject[ID_]]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], With[{ s=Replace[attrs[&quot;String&quot;],_Missing&quot;&quot;], o=Sequence@@Normal@KeyDrop[attrs,&quot;String&quot;] }, Interpretation[ Deploy@ Style[ Row@{&quot;StringObject&quot;,&quot;[&quot;, Style[s, &quot;Output&quot;, o, BackgroundNone, ShowStringCharactersFalse ], &quot;]&quot;},ShowStringCharactersFalse], StringObject[ID] ] ], Unevaluated[StringObject[ID]] ] ];    Then test this:      S=StringObject[&quot;obj&quot;] (*Out:*) StringObject[8]    But now its got state:      With[{S=S},S[FontColor]=Red] (*Out:*)          S (*Out:*) StringObject[8] With[{S=S},S[&quot;String&quot;]=&quot;obj_changed&quot;] (*Out:*) &quot;obj_changed&quot; S (*Out:*) StringObject[8]    All of these are the same object, though:      InputForm /@ {StringObject[8], StringObject[8], StringObject[8]} (*Out:*) {StringObject[8],StringObject[8],StringObject[8]}    This is now an object with attributes and state, which means that within a session it is more powerful, but we cant figure out what it looks like (attribute wise) from the symbolic form alone. Here is where our manager comes into play:      $StringObjectManager (*Out:*)       This is all the string data for all of the objects we made this session. By caching this, we can retrieve the state of our system trivially.   Types as Symbol Interfaces  There is one last (common) way to do object orientation. Rather than using a centralized manager, which if it gets corrupted or deleted can destroy the state of our system, we can use a symbol interface.  We do this by creating a symbol where before we created an ID. In fact, this really blurs the line between a managed type and an association interface.  This time well outline a timer object.  Instead of using ID, well assign an association to a symbol. This means we need to hold our symbol, though, to prevent it from evaluating. We will also want to keep track of which symbols we have used. Well do this via an association because lookup in associations is much faster than in lists:      $TimerObjectCache=&lt;||&gt;; TimerObject[]:= With[{obj=Unique@&quot;timer&quot;}, $TimerObjectCache[TimerObject[obj]]=None; obj=&lt;| &quot;CheckPoint&quot;-&gt;Now, &quot;EndPoint&quot;-&gt;None, &quot;Toggle&quot;:&gt;( With[{o=#}, o[&quot;EndPoint&quot;]= Replace[o[&quot;EndPoint&quot;],{ None-&gt;Now, _-&gt;None }] ]&amp;) |&gt;; TimerObject[obj] ]; TimerObject~SetAttributes~HoldFirst; TimerObject[sym_][attr_,args___]:= With[{r=sym[attr]}, If[MatchQ[r,_Function], r[TimerObject[sym],args], r ] ]; TimerObject/: HoldPattern[HoldPattern[Set[TimerObject[sym_][attr_],v_]]]:=(sym[attr]=v); TimerObject/: HoldPattern[SetDelayed[TimerObject[sym_][attr_],v_]]:=(sym[attr]:=v); TimerObject/: HoldPattern[Unset[TimerObject[sym_],attr_]]:=(sym[attr]=.); Format[TimerObject[sym_]]:= With[{ start=sym[&quot;CheckPoint&quot;], end=Replace[sym[&quot;EndPoint&quot;],NoneNow]}, Interpretation[ Deploy@Style[ Row@{&quot;TimerObject&quot;,&quot;[&quot;, Framed[ NumberForm[end-start,3], RoundingRadius5, BackgroundLighter[Blend@{LightBlue,Gray},.8], FrameStyleGrayLevel[.6] ],&quot;]&quot;}, ShowStringCharactersFalse ], TimerObject[sym] ] ]; t=TimerObject[] Pause[1]; t (*Out:*) TimerObject[timer17] (*Out:*) TimerObject[timer17]    Note that these are obviously the same object  And we can access state:      With[{t=t},t[&quot;Toggle&quot;]] (*Out:*)          t Pause[1]; t (*Out:*) TimerObject[timer17] (*Out:*) TimerObject[timer17] t[&quot;EndPoint&quot;] (*Out:*)       This is a more powerful method that using a manager and its harder to accidentally delete ones data. Unfortunately, saving state is somewhat harder, though. This is why we tracked our objects built.      With[{objs=$TimerObjectCache//Keys}, #ReleaseHold@#&amp;/@(HoldForm@@@objs) ] (*Out:*)       We now have to save all of these definitions but it is doable.    Summary  The order in which weve seen these object management structures more or less corresponds to their order of flexibility and also complexity.  Using a state-less object-like wrapper (an interface to an association, basically) is easier but less flexible than using objects that reference an object manager, which are in turn harder to use and less powerful than objects that track their own state.  Moreover, this is just a primer on making objects. Languages such as Java, Python, and C++ have a much richer object interface, including classes, instances, interfaces, templates, etc. To implement all of that is beyond the scope of this tutorial, but the tools we have here are actually sufficient to do so (at least for classes and instances).  In general, though, it is best to use the object you need for the project you need, until youre comfortable enough to build a more general architecture.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/assorted-tricks/object-oriented-programming.html</guid>
    <pubDate>Fri 29 Dec 2017 17:18:15</pubDate>
  </item>
  <item>
    <title>Scoping Revisited</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/scoping-revisited.html</link>
    <description>
        Scoping Revisited   With, Module, and Block  We finally have enough knowledge to understand the differences between the scoping constructs. We&#39;ll start by writing the same chunk of code with each:      Module[{a=35}, a^2 ] (*Out:*) 1225 With[{a=35}, a^2 ] (*Out:*) 1225 Block[{a=35}, a^2 ] (*Out:*) 1225    Everything is normal as of now. So let&#39;s try introducing some held expressions:      Module[{a=35}, a^2//Hold ]        Hold[a$2424 2 ]        With[{a=35}, a^2//Hold ]        Hold[35 2 ]        Block[{a=35}, a^2//Hold ]        Hold[a 2 ]     This alone should help in figuring out what is going on:  Module creates a new symbol with $ModuleNumber appended With inserts the given values into the expression  But what is Block doing? Nothing seems changed.  Let&#39;s look at a different example, just considering Module and Block as there is little more to discuss with With , although it should be noted that With is the cleanest and most useful of all these constructs.  Let&#39;s try define a global function:      scopeProbe[x_]:=x*b;    First let&#39;s use it inside Module     Module[{b=35}, scopeProbe[10] ] (*Out:*) 10 b    This behavior makes perfect sense. The b defined in Module is not the global b so this is what we&#39;d predict.      Block[{b=35}, scopeProbe[10] ] (*Out:*) 350    This here is the critical difference between Module and Block . Block reassigns the values of its symbols temporarily, while Module makes new symbols with temporary values (they have been given the attribute Temporary ).  This makes Block incredibly useful, but also potentially dangerous. Names used as variables to Block should always be made unique enough such that it&#39;s unlikely they&#39;ll have been used in a function that will be called by the Block .  An example of how we can use this is in memoization for a recursive function:      recursiveFunction[arg_]:=Block[{`recursiveFunction`memoPad=&lt;||&gt;}, recursiveStep[arg] ]; recursiveStep[arg_]:= If[!KeyMemberQ[`recursiveFunction`memoPad,arg], `recursiveFunction`memoPad[arg]=If[Length@arg==0, Pause[.5]; Total@ToCharacterCode@ToString@arg, recursiveStep/@(List@@arg)//Total ], `recursiveFunction`memoPad[arg] ];    And to see that this is doing what we expect      recursiveFunction[a[a,a,a,a,a]]//AbsoluteTiming (*Out:*) {0.500925`,485}    While without memoization this should take about 2.5 seconds:      recursiveNoMemo[arg_]:=If[Length@arg==0, Pause[.5]; Total@ToCharacterCode@ToString@arg, recursiveNoMemo/@(List@@arg)//Total ] recursiveNoMemo[a[a,a,a,a,a]]//AbsoluteTiming (*Out:*) {2.506773`,485}    And just to check that we the Block wrapper does something:      recursiveStep@a[a,a,a,a,a]      KeyMemberQ::invas:   The argument Globa recursiveFunction memoPad is not a valid Association or rule.       (*Out:*) If[!KeyMemberQ[Global`recursiveFunction`memoPad,a[a,a,a,a,a]],Global`recursiveFunction`memoPad[a[a,a,a,a,a]]=If[Length[a[a,a,a,a,a]]==0,Pause[0.5`];Total[ToCharacterCode[ToString[a[a,a,a,a,a]]]],Total[recursiveStep/@List@@a[a,a,a,a,a]]],Global`recursiveFunction`memoPad[a[a,a,a,a,a]]]        See Also:    https://mathematica.stackexchange.com/questions/559/what-are-the-use-cases-for-different-scoping-constructs
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/scoping-revisited.html</guid>
    <pubDate>Tue 17 Jul 2018 13:21:26</pubDate>
  </item>
  <item>
    <title>Flow Control</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/flow-control.html</link>
    <description>
        Mathematica, being primarily a functional programming language, doesn&#39;t use standard flow-control techniques such as While , Break , Continue , etc . to the same degree that a primarily procedural language like python does.  Despite that, these are still useful things to know how to work with. We&#39;ll go through them pretty quickly, one-by-one.    While  Of all of these, While is likely the most common to be used, although as mentioned previously it can be emulated perhaps more cleanly by Do with Infinity as the iterator spec.  On the other hand, particularly in the context of Compile or other cases where a predominantly procedural paradigm is use, While can be useful.    For  For is never useful. Any time it could be used Table or Do would be a better choice.    Break / Continue / Return  As noted, For isn&#39;t useful, which renders moot the primary use case of Break and Continue . They can potentially still be useful in Do and Table , though.  All Mathematica functions have an implicit Return in them, which makes use of Return infrequent, but it has its place. Especially when there are multiple possible points of exit from a function Return can be highly useful.  It also helpfully has a second argument specifying the scope from which the value should be returned, which can allow for somewhat more targeted usage in, say Do .  Similarly, FixedPoint and other nested functional programming constructs provide support for Return , Break , and potentially Continue .
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/flow-control.html</guid>
    <pubDate>Mon 16 Jul 2018 23:27:15</pubDate>
  </item>
  <item>
    <title>Error Handling</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/error-handling.html</link>
    <description>
        Error Handling  As we noted before, errors in Mathematica are much more subtle than in many languages. There is no compiler, so nothing will warn you about compile-time errors, and there is no real concept of an automatic runtime errori.e. there is nothing in the language enforcing any type of strict semantics. Because of this we need to be particularly careful about validating errors ourselves.  When we catch one of these errors we then have the question of what to do with it. To compound the difficulty, there aren&#39;t any official guidelines on the best ways to handle errors. I have my own preferences, and so we&#39;ll work through the various cases in order of least-to-most suggested.    Abort  When an error is caught, we could simply do as most programming languages do and simply abort the calculation, in this case via the function Abort .  The problem with this is that it is a potential overreaction as if we are producing code that others will use, this Abort will be passed up into any of their functions, too.    Message  The standard way Mathematica functions handle cases like this is by emitting a Message and then returning some type of failure tag, e.g. something like this:      Integrate[x, {1, 10}]      Integrate::ilim:   Invalid integration variable or limit(s) in {1,10}.       (*Out:*) Integrate[x,{1,10}]    Since this was an unhandled-arguments type of error, the function simply bottoms out and says: &quot;I&#39;m going to stay unevaluated&quot;.  For those interested, this type of behaviour most commonly occurs when a Condition is failed in either the pattern test of the function arguments or if a Condition is found at the end of a scoping construct, e.g.:      doNothing[]:= Module[ {}, doNothing::no=&quot;Nope :)&quot;; &quot;Something!&quot;/;If[&quot;Something&quot;=!=Nothing, Message[doNothing::no], True] ] doNothing[]      doNothing::no:   &quot;Nope :)&quot;       (*Out:*) doNothing[]    If Abort is too much, this approach is too little. An error caught deep inside a function shouldn&#39;t have to be passed step-by-step up through the rest of the function.    Throw / Catch  The Throw / Catch mechanism provides a much more robust way to handle errors in Mathematica. Catch takes a second argument that can be a pattern to catch the different error tags that Throw can attach to its results. By doing this we can get deeply-nested functions to throw to high-level and be caught only by the handlers we want, for instance we can do something like:      main[]:= NumberForm[Catch[{sub1[], sub2[], sub3[]}, &quot;err1&quot;|&quot;err2&quot;|&quot;err3&quot;], 3] sub1[]:= If[#&lt;.25, Throw[StringForm[&quot;`` too large&quot;, #], &quot;err1&quot;], #]&amp;@RandomReal[] sub2[]:= If[#&lt;.5, Throw[StringForm[&quot;`` two large&quot;, #], &quot;err2&quot;], #]&amp;@RandomReal[] sub3[]:= If[#&lt;.75, Throw[StringForm[&quot;`` three large&quot;, #], &quot;err3&quot;], #]&amp;@RandomReal[]    And when we use this:      ToString/@Table[main[], 10] (*Out:*) {&quot;0.137 two large&quot;,&quot;0.18 too large&quot;,&quot;0.704 three large&quot;,&quot;0.18 too large&quot;,&quot;0.0282 three large&quot;,&quot;0.463 three large&quot;,&quot;0.0129 too large&quot;,&quot;0.634 three large&quot;,&quot;0.104 too large&quot;,&quot;0.464 two large&quot;}    We see that the different errors were caught, each with their messages, and we didn&#39;t have to catch and pass up on each round.    Standardized Error Handling  We can combine these approaches to make a more robust approach to error handling. We&#39;ll use Message to tell the user about the source of the error, Throw and Catch to pass the error to top-level cleanly, and finally we&#39;ll use the Failure object to capture the message feed them to Throw .  We can go one step further, though, and allow any exceptions caught by Catch to optionally be passed up  Here&#39;s a sample way this could work:      Protect[$$tagStack]; catchExceptions[expr_, tags:{___}, passUp:True|False:True]:= Block[ { $$tagStack= If[ListQ@$$tagStack, {Join@@$$tagStack, tags}, {{}, tags}] }, Catch[expr, Alternatives@@tags, If[passUp, If[MemberQ[First@$$tagStack, #2], Throw[##], # ]&amp;, #&amp; ] ] ]; catchExceptions~SetAttributes~HoldFirst; raiseException[HoldPattern[msg:MessageName[sym_, tag_, ___]], params___]:= ( Message[msg, params]; Throw[ Failure[tag, &lt;|&quot;MessageTemplate&quot;:&gt;msg, &quot;MessageParameters&quot;-&gt;{params}|&gt;], tag ] ); raiseException~SetAttributes~HoldFirst;    We create a function that sets up a stack of tags being checked for, calls Catch with the set of currently tracked tags, if the error is caught, it conditionally checks whether the tag is in the head of the stack and if so passes it up.  Next we take a function that will Throw to this Catch block and return a nice structure to go with it.  Here&#39;s this in action:      myCoolFunction::err1=&quot;Uh oh spaghetti-Os!&quot;; myCoolFunction::err2=&quot;Oh deary me!&quot;; myCoolFunction::err3=&quot;Why did you do this to me ``?&quot;; myCoolFunction[name_]:= catchExceptions[ winAwards@ callMeBy@ yourName@name, {&quot;err1&quot;, &quot;err2&quot;, &quot;err3&quot;} ]; winAwards[movie_]:= If[!StringQ@movie, raiseException[myCoolFunction::err1], StringForm[&quot;`` won an award!&quot;, movie] ]; callMeBy[name_]:= If[RandomReal[]&lt;.5, raiseException[myCoolFunction::err2], &quot;Call Me By &quot;&lt;&gt;name//Quiet ]; yourName[name_]:= If[StringQ@name&amp;&amp;StringFreeQ[name, &quot; &quot;], raiseException[myCoolFunction::err3, name], name ];    And now we can use it on some examples:      myCoolFunction/@ Join[ StringRiffle@*DeleteDuplicates/@ Tuples[EntityValue[RandomEntity[&quot;GivenName&quot;, 2], &quot;Label&quot;], 2], {1} ]      myCoolFunction::err3:   Why did you do this to me &quot;Icelyn&quot;?      myCoolFunction::err2:   &quot;Oh deary me!&quot;      myCoolFunction::err3:   Why did you do this to me &quot;Shota&quot;?      myCoolFunction::err1:   &quot;Uh oh spaghetti-Os!&quot;       (*Out:*)       And we can nest this without end and it will always throw all the way up to top-level:      catchExceptions[ catchExceptions[myCoolFunction[1], {&quot;err1&quot;, &quot;err2&quot;, &quot;err3&quot;}], {&quot;err1&quot;, &quot;err2&quot;, &quot;err3&quot;} ]      myCoolFunction::err1:   &quot;Uh oh spaghetti-Os!&quot;       (*Out:*)       More extensions can be built on top of this, but this gets us a good ways beyond passing failed arguments up through our call stack.      See Also:    https://mathematica.stackexchange.com/questions/29321/what-are-the-best-practices-most-common-idiomatic-ways-to-report-errors-in-m
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/error-handling.html</guid>
    <pubDate>Tue 17 Jul 2018 13:06:10</pubDate>
  </item>
  <item>
    <title>Symbols and Expressions</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/symbols-and-expressions.html</link>
    <description>
        Symbols and Expressions   Symbols  Mathematica has one more basic type than those mentioned before: Symbol  In reality, every variable we&#39;ve used and function we&#39;ve defined (excluding pure functions) has been a symbol.  One thing to keep in mind is that the only things that can have properties or values in Mathematica are symbols, although a symbol need not have any.  All of the following are symbols:      Automatic AxesLabel $ModuleNumber Rule SetDelayed (*Out:*) Automatic (*Out:*) AxesLabel (*Out:*) 1205 (*Out:*) Rule (*Out:*) SetDelayed     Expressions  In Mathematica, they say everything is an expression. What this means, really, is that outside of the primitive types everything has one common form:      (head)[arg1,arg2,arg2,...,argn]    Furthermore, there are tools to parse these structures:      {1,2,3}//FullForm (*Out:*) List[1,2,3]    This even applies to things like graphics. Consider the following graphic:      Graphics3D[Sphere[],Boxed-&gt;False,Lighting-&gt;&quot;Neutral&quot;,ImageSize-&gt;Small] (*Out:*)       It is, however, still just an expression:      Graphics3D[Sphere[], Boxed-&gt;False, Lighting-&gt;&quot;Neutral&quot;, ImageSize-&gt;Small ]//FullForm (*Out:*) Graphics3D[Sphere[List[0,0,0]],Rule[Boxed,False],Rule[Lighting,&quot;Neutral&quot;],Rule[ImageSize,Small]]
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/symbols-and-expressions.html</guid>
    <pubDate>Wed 18 Jul 2018 23:47:42</pubDate>
  </item>
  <item>
    <title>Expressions Structure</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/expressions-structure.html</link>
    <description>
        Expressions Structure   Heads  For any expression the part before the square brackets is known as the Head of the expression and happily there is the conveniently named Head function extract it!      Head@&lt;|1-&gt;2, 3-&gt;4, 5-&gt;6|&gt; (*Out:*) Association    The Head of an expression can be anything. It can be a string:      Head@&quot;a&quot;[b] (*Out:*) &quot;a&quot;    A compound expression:      Head@((12 s^2)[2]) (*Out:*) 12 s^2    Or a deeply-nested chain of expressions:      Head@(f[1][&lt;|a-&gt;b|&gt;][3]) (*Out:*) f[1][&lt;|a-&gt;b|&gt;]     Parts  Everything following the Head in the expression is simply a part of the expression and can be extracted with the Part function.  Here the part 1 is the part within the brackets:      Part[((12s^2)[2]), 1] (*Out:*) 2    And here part 2 second bit in the curly bracesL      Part[{1,2,3}, 2] (*Out:*) 2    But if we look at the FullForm of that:      {1,2,3}//FullForm (*Out:*) List[1,2,3]    We see that it&#39;s really no different than the first example  Part also has an alias [[ ]]     {1,2,3}[[2]] (*Out:*) 2    It can also take runs of elements using Span syntax:      Range[10][[2;;8;;3]] (*Out:*) {2,5,8}    Or it can take a list of elements:      Range[100, 1, -1][[Array[Fibonacci, 10]]] (*Out:*) {100,100,99,98,96,93,88,80,67,46}    Because so often one needs the first or last components of an expression there are two dedicated functions to getting these parts.  First is functionally equivalent to [[1]] :      First@Range[10] (*Out:*) 1    And Last is functionally equivalent to [[-1]] :      Last@Range[10] (*Out:*) 10    There is also the function Rest which will take the second through last parts of an expression:      Rest@A[1, 2, 3, 4, 5] (*Out:*) A[2,3,4,5]    And Most which will that the first through second to last parts:      Most@A[1, 2, 3, 4, 5] (*Out:*) A[1,2,3,4]    There is also the function Take which takes spans from an expression:      Take[B@@Range[10],{3,5}] (*Out:*) B[3,4,5]    Take also accepts Span syntax  There is also Extract which is much like Part but provides a few features that can make it much more efficient in some cases (and less efficient in others). If you&#39;re going to do a lot of numeric manipulation or manipulation of memory-hungry objects it&#39;s worth being comfortable with both.    Manipulating Expressions  Mathematica also supports the manipulation of expressions through a wide series of functions, a few of which will be explained here and more which will be explained later:  Insert takes an expression and inserts another expression in the index specified as its third argument      Insert[{1,2,4}, &quot;Hi&quot;, -1] (*Out:*) {1,2,4,&quot;Hi&quot;}    As expected, it can insert into an arbitrary expression:      Insert[A[1,2,4], &quot;Hi&quot;, -2] (*Out:*) A[1,2,&quot;Hi&quot;,4]    We can use this to, for example, insert another Sphere into a Graphics3D expression:     Graphics3D[{Sphere[]},ImageSize-&gt;Small]//Insert[#, Sphere[{2,2,2}, .5], {1,-1}]&amp; (*Out:*)       Append and Prepend take an expression and add an element at the end and beginning respectively      Append[Graphics3D[Sphere[],ImageSize-&gt;Small], Lighting-&gt;&quot;Neutral&quot;] (*Out:*)       Delete and Drop both remove parts from an expression. Delete drops a single part:      Delete[A[1,2,3,4,5],4] (*Out:*) A[1,2,3,5]    Drop removes a span of parts      Drop[A[1,2,3,4,5],-2] (*Out:*) A[1,2,3]     Sequence  Often one wants to do something like stick the arguments of one expression inside another one. For this purpose there is a special Head Sequence     A[1,2,3,Sequence[1,2,3]] (*Out:*) A[1,2,3,1,2,3]    Or demonstrating how to put a list inside the expression:      A[1,2,3,Sequence@@{1,2,3}] (*Out:*) A[1,2,3,1,2,3]    Sequence generally represents a sequence of arguments which will be used without a Head . It is used most often in pattern matching and function definitions, but, being such a flexible construct, it has many uses.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/expressions-structure.html</guid>
    <pubDate>Thu 19 Jul 2018 00:05:36</pubDate>
  </item>
  <item>
    <title>Patterns</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/patterns.html</link>
    <description>
        Patterns   Simple Patterns  Patterns and how to use them might be the most important thing to understand in Mathematica  At some level, due to its expression-centered structure, Mathematica is just a huge pattern matching machine  The most basic pattern is just an underscore, but of course it has an expression structure:      _ // FullForm (*Out:*) Blank[]    We can also provide a name for our pattern which has in various function      p_//FullForm (*Out:*) Pattern[p,Blank[]]    You&#39;ll notice the Blank[] remains. Blank[] matches any single expression. For pattern matching there&#39;s the function MatchQ . It will return whether the expression as in its first argument matches the pattern in its second.  It doesn&#39;t have to have a pattern as its second argument though:      MatchQ[a,a] (*Out:*) True    But the following will also match:      MatchQ[a,_] (*Out:*) True    As will the following where we simply named one of the parameters:      MatchQ[a, p_] (*Out:*) True    Patterns of this type can also have a Head that must match, which is specified after the underscore.     _a//FullForm (*Out:*) Blank[a]    Any expression with a as its Head will match this pattern. For instance an empty invocation:      MatchQ[a[], _a] (*Out:*) True    With arguments      MatchQ[a[1,2,3], _a] (*Out:*) True    Or incredibly deeply nested:      MatchQ[a[a[a[a[a[a[]]]]]], _a] (*Out:*) True    But the following won&#39;t:      MatchQ[a, _a] (*Out:*) False    Along with a head one can also specify a test condition which will be applied to the thing that&#39;s being matched against      _a?test//FullForm (*Out:*) PatternTest[Blank[a],test]    Which means the following will match:      MatchQ[a[1,2,3],_a?(Length@#&gt;1&amp;)] (*Out:*) True    But the other cases will not. Here we clearly have too few arguments:      MatchQ[a[], _a?(Length@#&gt;1&amp;)] (*Out:*) False    Here it&#39;s hard to see, but the outer-most structure has only one argument, so it also won&#39;t match:      MatchQ[a[a[a[a[a[a[]]]]]],_a?(Length@#&gt;1&amp;)] (*Out:*) False    Patterns can also be specified as parts of an expression:      MatchQ[a[1,2,3],a[_,_,_]] (*Out:*) True    Patterns can also be specified as matching 1 or more elements with a double underscore:      __//FullForm (*Out:*) BlankSequence[]    Since we have arguments this matches:      MatchQ[a[1,2,3], a[__]] (*Out:*) True    But this does not:      MatchQ[a[], a[__]] (*Out:*) False    or 0 or more elements via a triple underscore:      ___//FullForm (*Out:*) BlankNullSequence[]    This will match since all of these arguments have head Integer :      MatchQ[a[1,2,3], a[___Integer]] (*Out:*) True    And this will match since there aren&#39;t any arguments anyway:      MatchQ[a[],a[___]] (*Out:*) True    Everything that applies to single element patterns applies as well to these multi-element patterns.    Complex Patterns  Often it&#39;s useful to be able to match more than one type. For this, there&#39;s a built-in head Alternatives , which is represented by a vertical bar |  An Integer matches this pattern:      MatchQ[10, _Integer|_String] (*Out:*) True    As does a String :      MatchQ[&quot;10&quot;, _Integer|_String] (*Out:*) True    But a Symbol does not:      MatchQ[, _Integer|_String] (*Out:*) False    Alternatives can be used with any pattern and simplifies life tremendously in describing complicated structures concisely  One issue, however, is that a set of alternatives can&#39;t be matched multiple times with the double or triple underscores. To fix this issue there is Repeated ( .. ) and RepeatedNull ( ... ) which have the same meanings as __ and ___ respectively.  Here&#39;s an example of matching a complex structure:      MatchQ[RandomChoice[{A,B,C}]@(Sequence@@( If[RandomInteger[]==0,ToString@#,#]&amp;/@RandomInteger[10,RandomInteger[10]] )), (A|B|C)[(_String|_Integer)...] ] (*Out:*) True    It is impossible to know ahead of time what the head will be or how many arguments there will be or whether they&#39;ll be strings or integers, but that doesn&#39;t matter. We can still represent this pattern in under one line. Yet the pattern is robust enough that by doing something like appending in a symbol, our pattern catches that:      MatchQ[ Append[ RandomChoice[{A,B,C}]@( Sequence@@( If[RandomInteger[]==0,ToString@#,#]&amp;/@RandomInteger[10,RandomInteger[10]] ) ), RandomChoice[{A,B,C}] ], (A|B|C)[(_String|_Integer)...] ] (*Out:*) False    There is one further useful addition to this current redux on patterns. Sometime you know you&#39;ll, say, see pairs of a patterns, and so a simple .. or __ isn&#39;t precise enough. For this case there is the head PatternSequence which can capture this:      MatchQ[ A@@(If[OddQ@#,ToString@#,#]&amp;/@Range[10]), A[PatternSequence[_String,_Integer]..] ] (*Out:*) True     Except  The final piece of patterns is the head Except . It specifies that anything Except the pattern inside should match. It is a negation pattern, in essence.      MatchQ[1,Except[_String]] (*Out:*) True    These examples show a basic usage:      MatchQ[&lt;|a-&gt;b|&gt;, Except[_String]] MatchQ[Graphics@Disk[], Except[_String]] MatchQ[&quot;asdasd&quot;, Except[_String]] (*Out:*) True (*Out:*) True (*Out:*) False    One interesting case is the two argument form of Except , where the second argument is a pattern that should match and the first argument is a list of exceptions to that pattern.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/patterns.html</guid>
    <pubDate>Thu 19 Jul 2018 00:12:32</pubDate>
  </item>
  <item>
    <title>Replacement Patterns</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/replacement-patterns.html</link>
    <description>
        Replacement Patterns  The fundamental usage of patterns is in replacement. This is just what it sounds like. One replaces part of an expression with something else. Theres a whole family of functions built around this concept, too, and theyre some of the oldest functions in the language. They all share one parent, though    Replace  Replace is possibly the most fundamental function in Mathematica. It takes an expression and if it matches a pattern, replaces it with that value. For example:      Replace[{1, 2, 3}, a : {__Integer} :&gt; Column@a] (*Out:*)       If the pattern doesnt match, nothing happens:      Replace[{1, 2, 3}, a : {RandomInteger[1000], RandomReal[1000], RandomReal[1000]} :&gt; &quot;This has a 1/1000000000 chance of being the result&quot; ] (*Out:*) {1, 2, 3}    Replace can also try a list of replacements:      Replace[{1, 2, 3}, { {_Integer, _Integer, _String} :&gt; &quot;No&quot;, {_Integer, _Integer, _List} :&gt; &quot;No&quot;, {_Integer, _Integer, _Association} :&gt; &quot;No&quot;, {_Integer, _Integer, _Integer} :&gt; &quot;Yes!&quot;, {__Integer} :&gt; &quot;Yes, but won&#39;t happen&quot; } ] (*Out:*) &quot;Yes!&quot;    Youll notice it only matches the first pattern that fits.  Replace can also work at various levels of an expression:      Replace[{1, 2, &quot;3&quot;, 2, 1}, i_Integer :&gt; (&quot;int &quot; &lt;&gt; ToString@i), 1] (*Out:*) {&quot;int 1&quot;, &quot;int 2&quot;, &quot;3&quot;, &quot;int 2&quot;, &quot;int 1&quot;}     ReplaceAll  ReplaceAll is the only other member of the family Ill mention here. It works similarly to Replace , except the replacements can happen at any level of the expression. This is dangerous, but also useful.  Also useful is the fact that it has a keyboard alias: /.  Heres a fun example:      GraphicsGrid[ Table[ Table[RandomInteger[100], {j, RandomInteger[{1, 6}]}], {i, RandomInteger[{3, 5}]} ] /. i_Integer :&gt; Graphics[{RandomColor[], Disk[]}, ImageSize -&gt; i], Spacings -&gt; 0 ] (*Out:*)        Replace  The rest of this family share the name Replace and most of them work quite like Replace , with the notable exception of ReplacePart
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/replacement-patterns.html</guid>
    <pubDate>Wed 27 Dec 2017 16:12:10</pubDate>
  </item>
  <item>
    <title>Functions</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/functions.html</link>
    <description>
        Functions   Functions as Patterns  The reason for that long discussion of patterns is the following: Mathematica functions (except pure functions) are just patterns. Consider the following:      f[x_]:=x*10    All I&#39;ve done here is tell the system that whenever it sees the pattern f[Blank[]] execute the right hand code, but with x replaced with the value of that Blank[] .  Seeing as that&#39;s all we&#39;re doing, though, we can also leverage the power of patterns to restrict our definition:      g[i_Integer]:=RandomInteger[i]; g[s_String]:=RandomChoice@Characters@s; g[{v_,___}]:=g[v];    Now we have a function g that can vary depending on its arguments.      g/@{10,&quot;my word!&quot;,{g,c,d}} (*Out:*) {2,&quot;w&quot;,g[g]}    One thing worth noting is that if a multi-element pattern is matched, the values are substituted as the arguments of the enclosing head, but if the values themselves are returned they are wrapped in Sequence for consistency. For instance:      g[s___]:={Hold[s], ListPlot[{s}]}; g[1,2,3,2,1,2,3,4] (*Out:*)          g2[s___]:=s; g2[1,2,3,2,1] (*Out:*) Sequence[1,2,3,2,1]     Named Patterns, Optional and Disappearing Arguments  A Pattern can be declared without any underscores by following it with a colon. This is useful in function declarations when you want to get the value of a complicated pattern element, for instance:      h[a:(_Integer|_String|)]:=Head@a; h[_]:=2 h/@{1,&quot;1&quot;,,h,{&quot;H&quot;,&quot;i&quot;,&quot;M&quot;,&quot;o&quot;,&quot;m&quot;,&quot;!&quot;}} (*Out:*) {Integer,String,Symbol,2,2}    Pattern has a cousin, however, called Optional who also uses a colon, but who can only be called on top of an existing Pattern :      a:_:Automatic//FullForm (*Out:*) Optional[Pattern[a,Blank[]],Automatic]    MatchQ works with Optional by just matching the pattern beneath      MatchQ[1,a:_Integer|_String:Automatic] (*Out:*) True    What makes Optional special is its behavior in functions. It has a special simplest form which you may have seen already in a function declaration:      a_:Automatic//FullForm (*Out:*) Optional[Pattern[a,Blank[]],Automatic]    And now observe what this can do for us:      optionsFunction[arg_:Automatic]:=arg; optionsFunction[1] optionsFunction[] (*Out:*) 1 (*Out:*) Automatic    Notice how we didn&#39;t need to supply a value. How Optional works is that if the Pattern doesn&#39;t match, the default value gets substituted instead. What makes this special is the following sort of thing:      opF[intArg:_Integer:1,strArg:_String:&quot;Hi&quot;,listArg:_List:{1,2,3}]:=Grid@{ {&quot;Int&quot;,&quot;Str&quot;,&quot;List&quot;}, {intArg,strArg,listArg} }; opF[] opF[{1}] opF[&quot;a&quot;,{1}] opF[10, {1}] (*Out:*)          (*Out:*)          (*Out:*)          (*Out:*)       Notice how we didn&#39;t even need to specify all of our arguments to change our list argument. This is because a List wouldn&#39;t match _Integer or _String so these took on their default values, but the list argument took the value supplied.  This sort of trick only works when the argument patterns are disjoint enough, but often they are. At base, it means that complicated functions can be declared more concisely. Moreover, it is a crucial thing to know when dealing with OptionsPattern   Attributes  I&#39;m mentioning Attributes here only because I would be remiss not to. All Symbol s can have Attributes in Mathematica and as functions are Symbol s, they can too. There is a list of permitted Attributes and trying to set an undefined attribute will cause an error to be raised:      SetAttributes[a,hat]; Attributes@a    The point of Attributes is generally to change the evaluation behavior of a symbol. The most useful Attributes in my mind are HoldFirst , HoldAll , and Listable all of which change how a definitions on a Symbol are applied.  HoldFirst and HoldAll designate that some portion of their arguments (either the first or all of them) should not be evaluated before being substituted into the code of their function definition. For example:      atF~SetAttributes~HoldFirst; atF[arg_]:=Hold[arg]; atF[N[]] (*Out:*) Hold[N[]]    If atF did not have this, N[] would have evaluated first:      ClearAttributes[atF,HoldFirst]; atF[N[]] (*Out:*) Hold[3.141592653589793`]    HoldAll has the same behavior, just every argument is held. (There is also a HoldRest attribute which should be self explanatory). There is however also an attribute HoldAllComplete which behaves like HoldAll except even UpValues are not applied (this is probably a meaningless statement, but there is a section dealing with UpValues soon)  Listable changes evaluation behavior by specifying that the function should be applied to the elements of any List in its arguments. This is made clear better by the documentation, but there is a useful case to know about, where this behavior is important.  StringJoin joins strings, obviously, but it also has the attribute Listable which means that rather that requiring      StringJoin[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] (*Out:*) &quot;abcd&quot;    It can take:      StringJoin@{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;} (*Out:*) &quot;abcd&quot;    But where this is really useful is in the alias form of StringJoin ( &lt;&gt; ). If it did not have Listable we&#39;d have to do the following:      &quot;a&quot;&lt;&gt;&quot;b&quot;&lt;&gt;&quot;c&quot;&lt;&gt;&quot;d&quot; (*Out:*) &quot;abcd&quot;    But since it does we can drop some of those &lt;&gt; for a list:      &quot;&quot;&lt;&gt;{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;} (*Out:*) &quot;abcd&quot;    This behavior may seem unimportant now, but it can be incredibly useful when in the midst of a large project and needing to try out different things. Converting your entire list to &lt;&gt; joined pairs can be annoying, or maybe you already had some joins in there. In any case, it can save time and brain power which could be better used on actual programming.    Options, OptionsPattern, OptionValue, and FilterRules  Much like Attributes a Symbol can also store Options . These are a list of Rule s with default values which are used by functions via the OptionValue interface. There&#39;s a convenient Pattern called OptionsPattern which will match Rule and RuleDelayed sequences among other things. The Options interface is rich, so check out the documentation on it, but I&#39;ll provide some tips, tricks, and common uses cases  One thing to keep in mind is that since OptionsPattern matches a block of Rule and RuleDelayed , it can be useful to declare that all of the arguments before this block (or after it) are not Rule or RuleDelayed     Options[opEx]={&quot;X&quot;-&gt;0,Y-&gt;0,1-&gt;5,{1,2,3}-&gt;3}; opEx[notRuleArgs:Except[_Rule]...,ops:OptionsPattern[]]:={ {notRuleArgs}, {ops} }; opEx[1,2,3] opEx[1, 2, &quot;X&quot;-&gt;1000] opEx[1, 2, &quot;X&quot;-&gt;1000,A-&gt;20] (*Out:*) { {1,2,3},{}} (*Out:*) { {1,2},{&quot;X&quot;-&gt;1000}} (*Out:*) { {1,2},{&quot;X&quot;-&gt;1000,A-&gt;20}}    When using Options in a function one uses OptionValue to get the value, which will first check to see it&#39;s been overridden in an argument and if not go to the default value:      opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]]:=OptionValue@&quot;X&quot;; opEx[1,2,3] opEx[1, 2, &quot;X&quot;-&gt;1000] (*Out:*) 0 (*Out:*) 1000    If you call an OptionValue for which there is no default, you&#39;ll get an error:      opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]]:=OptionValue@Z; opEx[1,2,3]         OptionValue::optnf:       Option name Z not found in defaults for opEx.           (*Out:*) Z    Even if you provide an explicit override value, it will still grouse at you, although it will work:      opEx[1,2,&quot;Z&quot;-&gt;500]         OptionValue::nodef:       Unknown option &quot;Z&quot; for opEx.           (*Out:*) 500    Options are generally used to provide more flexibility and control than can easily be done via an argument list. Options can also be used as a function to see all of the default options for a symbol and for many of the built-in symbols you can see how many there are, so that users can tweak lots of things. For example, Plot has a whole host of options:      Options@Plot (*Out:*) {AlignmentPoint-&gt;Center,AspectRatio-&gt;1/GoldenRatio,Axes-&gt;True,AxesLabel-&gt;None,AxesOrigin-&gt;Automatic,AxesStyle-&gt;{},Background-&gt;None,BaselinePosition-&gt;Automatic,BaseStyle-&gt;{},ClippingStyle-&gt;None,ColorFunction-&gt;Automatic,ColorFunctionScaling-&gt;True,ColorOutput-&gt;Automatic,ContentSelectable-&gt;Automatic,CoordinatesToolOptions-&gt;Automatic,DisplayFunction:&gt;$DisplayFunction,Epilog-&gt;{},Evaluated-&gt;Automatic,EvaluationMonitor-&gt;None,Exclusions-&gt;Automatic,ExclusionsStyle-&gt;None,Filling-&gt;None,FillingStyle-&gt;Automatic,FormatType:&gt;TraditionalForm,Frame-&gt;False,FrameLabel-&gt;None,FrameStyle-&gt;{},FrameTicks-&gt;Automatic,FrameTicksStyle-&gt;{},GridLines-&gt;None,GridLinesStyle-&gt;{},ImageMargins-&gt;0.`,ImagePadding-&gt;All,ImageSize-&gt;Automatic,ImageSizeRaw-&gt;Automatic,LabelStyle-&gt;{},MaxRecursion-&gt;Automatic,Mesh-&gt;None,MeshFunctions-&gt;{#1&amp;},MeshShading-&gt;None,MeshStyle-&gt;Automatic,Method-&gt;Automatic,PerformanceGoal:&gt;$PerformanceGoal,PlotLabel-&gt;None,PlotLabels-&gt;None,PlotLegends-&gt;None,PlotPoints-&gt;Automatic,PlotRange-&gt;{Full,Automatic},PlotRangeClipping-&gt;True,PlotRangePadding-&gt;Automatic,PlotRegion-&gt;Automatic,PlotStyle-&gt;Automatic,PlotTheme:&gt;$PlotTheme,PreserveImageOptions-&gt;Automatic,Prolog-&gt;{},RegionFunction-&gt;(True&amp;),RotateLabel-&gt;True,ScalingFunctions-&gt;None,TargetUnits-&gt;Automatic,Ticks-&gt;Automatic,TicksStyle-&gt;{},WorkingPrecision-&gt;MachinePrecision}    This is also useful for chaining functions together and passing their options to each other. Before an example of that, it&#39;s worth talking about FilterRules . All it does is take a list of rules and either an explicit list of rules or rule names or a pattern to match and selects those rules whose left-hand side matches. For example:      FilterRules[Options@Plot,PlotStyle|EvaluationMonitor] (*Out:*) {EvaluationMonitor-&gt;None,PlotStyle-&gt;Automatic}    This can be used to make sure rules conform to the options of a given function:      FilterRules[{&quot;Z&quot;-&gt;10,&quot;X&quot;-&gt;100},Options@opEx] (*Out:*) {&quot;X&quot;-&gt;100}    Finally as OptionValue matches the last pattern it sees, one can pass all the defaults for a symbol plus some updates by putting your new rules first in a FilterRules :      ClearAll@opEx Options[opEx] = {&quot;X&quot; -&gt; 0, Y -&gt; 0}; opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]] := OptionValue@&quot;X&quot;; FilterRules[Join[{&quot;Z&quot;-&gt;10,&quot;X&quot;-&gt;100}, Options@opEx], Options@opEx] opEx@@FilterRules[Join[{&quot;Z&quot;-&gt;10,&quot;X&quot;-&gt;100},Options@opEx],Options@opEx] (*Out:*) {&quot;X&quot;-&gt;100,&quot;X&quot;-&gt;0,Y-&gt;0} (*Out:*) 100    This trick is necessary when overriding options on an old function:      Options[newGraphics3D]=Join[{ Lighting-&gt;&quot;Neutral&quot;, Boxed-&gt;False, ImageSize-&gt;Small }, FilterRules[Options@Graphics3D,Except[Boxed|Lighting|ImageSize]] ]; newGraphics3D[graphicsStuff:Except[_Rule]...,ops:OptionsPattern[]]:=Graphics3D[{graphicsStuff}, FilterRules[Join[{ops},Options@newGraphics3D], Options@Graphics3D] ] newGraphics3D@Sphere[] (*Out:*)
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/functions.html</guid>
    <pubDate>Thu 19 Jul 2018 00:15:29</pubDate>
  </item>
  <item>
    <title>Contexts</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/contexts.html</link>
    <description>
        Contexts  Contexts are a relatively simple concept but have major effects. Their basic use is to tag symbols with extra information. Usually we are in the global context:      $Context (*Out:*) &quot;Global`&quot;    Although many of the functions we use are not:      Context@Plot (*Out:*) &quot;System`&quot;    A context is a series of symbol names followed by &quot;`&quot;  Contexts we can use without fully qualifying the name are those on $ContextPath     $ContextPath (*Out:*) {&quot;CloudObjectLoader`&quot;,&quot;StreamingLoader`&quot;,&quot;SymbolicMachineLearningLoader`&quot;,&quot;IconizeLoader`&quot;,&quot;HTTPHandlingLoader`&quot;,&quot;PacletManager`&quot;,&quot;System`&quot;,&quot;Global`&quot;}    We can define our own contexts via Begin and BeginPackage and the context is exited via End and EndPackage respectively. The only difference between these is that BeginPackage restricts the value of $ContextPath while Begin does not:      BeginPackage[&quot;NameTools`&quot;]; thisIsTheLocalContextPath=$ContextPath; EndPackage[] thisIsTheLocalContextPath//Context thisIsTheLocalContextPath (*Out:*) &quot;NameTools`&quot; (*Out:*) {&quot;NameTools`&quot;,&quot;System`&quot;}    This protects symbols from being affected by things in the Global` context or any other context. Begin does not do this:      Begin[&quot;NameTools`&quot;]; thisIsTheLocalContextPath=$ContextPath; End[]; thisIsTheLocalContextPath (*Out:*) {&quot;NameTools`&quot;,&quot;CloudObjectLoader`&quot;,&quot;StreamingLoader`&quot;,&quot;SymbolicMachineLearningLoader`&quot;,&quot;IconizeLoader`&quot;,&quot;HTTPHandlingLoader`&quot;,&quot;PacletManager`&quot;,&quot;System`&quot;,&quot;Global`&quot;}    Note that BeginPackage also prepended the context defined to the $ContextPath .  Anything not in NameTools` exactly won&#39;t be found, however. We can see this by definining something in a subcontext:      NameTools`hidden`a=100 (*Out:*) 100    And noting that it doesn&#39;t get exposed via context in the $ContextPath :      a a//Context (*Out:*) a (*Out:*) &quot;Global`&quot;    This is how Mathematica defines so many functions without us having to worry about using the wrong symbols. Just consider all of the symbols we can find in System`Private` :      Pane[Column@Names@&quot;System`Private`*&quot;, {Automatic,100},Scrollbars-&gt;{False,True}, AppearanceElements-&gt;None] (*Out:*)       One final useful thing to know is that the current context can be implied when defining a symbol, such as done in the following example:      `Private`b=100 (*Out:*) 100    This just had the current context put in front of the first `      Global`Private`b (*Out:*) 100        See Also:    https://mathematica.stackexchange.com/questions/43381/how-symbol-lookup-actually-works/43629#43629
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/contexts.html</guid>
    <pubDate>Thu 19 Jul 2018 00:17:22</pubDate>
  </item>
  <item>
    <title>OwnValues, Set, and SetDelayed</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/ownvalues-set-and-setdelayed.html</link>
    <description>
        OwnValues, Set, and SetDelayed   Set and SetDelayed  Both Set and SetDelayed work by setting definitions on a symbol. What this means in practice is that Set and SetDelayed add replacement patterns to one of the Values lists of the symbol. The lists can be OwnValues , DownValues , UpValues or SubValues . There are also NValues and FormatValues , but these are assigned via alternate interfaces and do not have much effect on real programming.    OwnValues  OwnValues are the most fundamental type of Values . These represent things like the following:      a=10; a:=20;    We can then query the OwnValues     OwnValues@a (*Out:*) {HoldPattern[a]:&gt;20}    We can even edit the OwnValues manually if we know what we&#39;re doing:      OwnValues[a]=Prepend[OwnValues[a], HoldPattern[a]:&gt;50] (*Out:*) {HoldPattern[a]:&gt;50,HoldPattern[a]:&gt;20} a (*Out:*) 50    Something interesting happens, though, if you set more values on a via SetDelayed :      a:=100 OwnValues@a (*Out:*) {HoldPattern[a]:&gt;100,HoldPattern[a]:&gt;20} a:=32 OwnValues@a (*Out:*) {HoldPattern[a]:&gt;32,HoldPattern[a]:&gt;20}    Only the first entry is changed. This behavior could be used with something like the following to cache symbol values:      setValue[s_Symbol,v_]:=(OwnValues[s]=Prepend[OwnValues[s],HoldPattern[s]:&gt;v]); resetValue[s_Symbol]:=(OwnValues[s]=Rest@OwnValues[s]); SetAttributes[setValue,HoldFirst]; SetAttributes[resetValue,HoldFirst]    We set the value once:      setValue[a,10]; a (*Out:*) 10    Then set it to a new value:      setValue[a,20]; a (*Out:*) 20    But can restore the cached value:      resetValue[a]; a (*Out:*) 10    Notice that using a plain Set erases these changes:      a=10 OwnValues@a (*Out:*) 10 (*Out:*) {HoldPattern[a]:&gt;10}    Even if now we add more values Set will erase them all:      OwnValues[a]=Join[ConstantArray[HoldPattern[a]:&gt;25,10],OwnValues@a] a=10 OwnValues@a (*Out:*) {HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;25,HoldPattern[a]:&gt;10} (*Out:*) 10 (*Out:*) {HoldPattern[a]:&gt;10}        See Also:    https://mathematica.stackexchange.com/a/18487/193     https://mathematica.stackexchange.com/a/18456/193     https://mathematica.stackexchange.com/a/18562/193
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/ownvalues-set-and-setdelayed.html</guid>
    <pubDate>Thu 19 Jul 2018 00:18:55</pubDate>
  </item>
  <item>
    <title>Function Values and Definition Clearing</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/function-values-and-definition-clearing-.html</link>
    <description>
        Function Values and Definition Clearing   DownValues  If OwnValues are standard value bindings, DownValues are your basic function bindings:      f[x_]:=x DownValues@f (*Out:*) {HoldPattern[f[x_]]:&gt;x}    This is also why we can define functions as patterns. All that happens is a series of replacement rules are tried, based on the DownValues of the expression. Really, one can imagine that all Mathematica does to execute an expression is apply ReplaceRepeated on the Values .  Obviously the system is more complex, because of Attributes and the coming discussion of evaluation order and things, and also more optimized, but it&#39;s a good concept to keep in mind.  Just like with OwnValues we can manipulate the DownValues via  One final thing. On the name DownValues : one can imagine that the system is looking &quot;down-stream&quot; in the expression to see if the arguments match the defined replacement pattern.    UpValues  UpValues are a highly useful, if not necessarily intuitive feature of the expression structure. While DownValues look &quot;down-stream&quot;, UpValues look &quot;up-stream&quot;. What this means in practice is they are patterns applied on an expression by the arguments of the expression which are, in a way, looking &quot;up-stream&quot;. This is probably clearest via example, but first we need to know how UpValues are set.  First off, there is a function UpSet ( ^= ) and it&#39;s partner UpSetDelayed ( ^:= ) which will do this      h[b[c___]]^:=b[h,c]    This has set UpValues on b :      UpValues@b (*Out:*) {HoldPattern[h[b[c___]]]:&gt;b[h,c]}    Then let&#39;s test this:      h[b[1,3,4,2,1]] (*Out:*) b[h,1,3,4,2,1]    The most useful aspect of this behavior is that it requires only that we give definitions to the down-stream symbol, not the head, so we can use this to &quot;overload&quot; the basic functionality of a built-in function, which is more efficient and also cleaner and safer.  Moreover, this means we can apply definitions to functions which we otherwise couldn&#39;t. We&#39;ll demonstrate this with the MessageName function. Aliased with ::  I&#39;ll also demonstrate the better way to set these definitions, using TagSet ( /: )      AssociationInterface/:HoldPattern[ MessageName[AssociationInterface[a_Association],key_] ]:=a[key];    TagSet only sets the definition on the symbol to the left, unlike UpSet which sets the definition on every argument.  The HoldPattern is necessary to make sure the expression doesn&#39;t evaluate while we set the UpValue , which will make more sense when we get to discussions of evaluation order.  Now we can see how our definition works:      AssociationInterface[&lt;| &quot;a&quot;-&gt;b, &quot;b&quot;-&gt;d, &quot;e&quot;-&gt;f |&gt;]::a (*Out:*) b    MessageName automatically converts its second argument to a String , so the keys of our Association need to be strings, but we can see the definition works.  One thing that should be mentioned before moving on is that the UpValues of the arguments of a symbol are applied before the DownValues of the enclosing head, although the DownValues of the argument itself are applied before its UpValues   SubValues  SubValues are the final type of values we need to deal with here. They provide an extension of DownValues to multiple sets of arguments as follows:      s[arg_][arg2_]:=arg+arg2; SubValues@s (*Out:*) {HoldPattern[s[arg_][arg2_]]:&gt;arg+arg2}     Clear and ClearAll  With Values discussed it&#39;s possible to understand the operations of of the functions Clear and ClearAll . Consider some symbol we&#39;ve set a lot of definitions on:      m[1]=1; m[2]=10; m[5]=100; HoldPattern[m[1][3]]=20; m[s_String]:=&quot;soup&quot;; HoldPattern[Print[m[x_]]]^:=x+&quot;Print&quot;; m:=35 OwnValues@m DownValues@m UpValues@m SubValues@m (*Out:*) {HoldPattern[m]:&gt;35} (*Out:*) {HoldPattern[m[1]]:&gt;1,HoldPattern[m[2]]:&gt;10,HoldPattern[m[5]]:&gt;100,HoldPattern[m[s_String]]:&gt;&quot;soup&quot;} (*Out:*) {HoldPattern[HoldPattern[Print[m[x_]]]]:&gt;x+&quot;Print&quot;} (*Out:*) {HoldPattern[HoldPattern[m[1][3]]]:&gt;20}    All Clear does is remove the Values :      Clear@m OwnValues@m DownValues@m UpValues@m SubValues@m (*Out:*) {} (*Out:*) {} (*Out:*) {} (*Out:*) {}    ClearAll on the other hand can also remove Options and Attributes .  We see that Clear doesn&#39;t remove these:      SetAttributes[m,Listable]; Options[m]={&quot;why&quot;-&gt;&quot;me?&quot;}; Clear@m Options@m Attributes@m (*Out:*) {&quot;why&quot;-&gt;&quot;me?&quot;} (*Out:*) {Listable}    But ClearAll does:      ClearAll@m Options@m Attributes@m (*Out:*) {} (*Out:*) {}        See Also:    https://mathematica.stackexchange.com/questions/96/what-is-the-distinction-between-downvalues-upvalues-subvalues-and-ownvalues
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/function-values-and-definition-clearing-.html</guid>
    <pubDate>Thu 19 Jul 2018 00:20:38</pubDate>
  </item>
  <item>
    <title>Hold and Evaluation Order</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/hold-and-evaluation-order.html</link>
    <description>
        Hold and Evaluation Order  Weve touched on evaluation order briefly when we introduced UpValues but there are a series of other things to consider. For example say you want to define a function that makes a string of print commands to display. Naively we might try the following:      Column@(ToString /@ {Print[1], Print[2], Print[3]})     1    2    3      (*Out:*)       But Print evaluates before ToString so well need to format a different way. We can try it with Hold     Column@(ToString /@ Hold[Print[1], Print[2], Print[3]]) (*Out:*) Column[Hold[ToString[Print[1]], ToString[Print[2]], ToString[Print[3]]]]    Hold prevents the evaluation of the command its wrapped around. Unfortunately that applies to ToString too.  Our solution is instead to use Unevaluated     Column@(ToString /@ {Unevaluated@Print[1], Unevaluated@Print[2], Unevaluated@Print[3]}) (*Out:*)       Unevaluated has no meaning on its own, but when wrapped around an expression essentially says to use that expression it is Unevaluated form.  Its counterpart is Evaluate , which forces the evaluation of a held expression:      Hold[Evaluate@ 0  Sin[]]        (*Out:*) Hold[2]    Note that Evaluate only works when on the first level of the expression though:      Hold[1 + Evaluate@ 0  Sin[]]         Hold[1 + Evaluate[ 0  Sin[]]]     Hold is often used with Thread to create lists of held expressions:      Column@Thread@Hold[{  2  Sin[],  1  Sin[],  0  Sin[]}]        (*Out:*)       Its also used with the Replace function family to manipulate expressions without evaluation:      Hold[a[1], b[], c[1]] /. { a -&gt; Print, _b :&gt;  2  Sin[], c -&gt; CreateDocument}         Hold[Print[1],  2  Sin[], CreateDocument[1]]     Note that Print[2] is inserted into the Hold without evaluation.  Theres a trick to getting it do evaluate:      Hold[a[1], b[], c[1]] /. { a -&gt; Print, _b :&gt; With[{r =  2  Sin[]}, r /; True], c -&gt; CreateDocument}        (*Out:*) Hold[Print[1], 1 + Cos[2], CreateDocument[1]]    Why this works will be explained later, for now just keep in mind as a useful trick
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/code-structure/hold-and-evaluation-order.html</guid>
    <pubDate>Thu 28 Dec 2017 00:47:26</pubDate>
  </item>
  <item>
    <title>Procedural Programming</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/procedural-programming.html</link>
    <description>
        Procedural Programming  In most programming languages (C++, Java, python) we generally use what is called &quot;procedural programming&quot; where we work in a very step-wise fashion. Perhaps the archetype of this is the &quot;for-loop&quot;, the work-horse of standard programming. Mathematica, too, has a For loop. In fact we can use all the standard constructs of procedural programming:      radii={}; For[ i =1, i&lt;10, i++, radii=radii~Append~RandomReal[] ]; radii (*Out:*) {0.914128302537593`,0.3769315906863173`,0.6234932943918361`,0.1322100006893343`,0.1577628966678457`,0.016730303000478397`,0.17548676789547235`,0.8109969085084299`,0.20378370831071368`}    We have a very simple set of steps, here, make a list, radii , initialize a loop variable i , then perform a task (appending a Real to radii ) and incrementing our loop variable i while some test holds ( i &lt; 10 ). Everything is laid out very explicitly and easily to understand. Unfortunately, when writing a large program, having to go through so many steps is a hassle and impedes the development process.  Functional programming, which is almost always defined in contrast to procedural programming, deals with using functions like our usual primitives and passing them through other function accordingly. There are many facets to functional programming, of course, but its most common use is the application of functions to lists.  We can do the above process in a single line using a functional construct:      Table[RandomReal[],10] (*Out:*) {0.4137847297182886`,0.9732982192569992`,0.3548496693281973`,0.8582126960787808`,0.15420928011477764`,0.6816139288605962`,0.8404716895591711`,0.9679926345109562`,0.7314841013853948`,0.7997407311341189`}    There are many useful functional constructs we can use that will solve large classes of programming issues for us.      See Also:    https://mathematica.stackexchange.com/questions/7924/alternatives-to-procedural-loops-and-iterating-over-lists-in-mathematica     https://mathematica.stackexchange.com/questions/163992/what-makes-mathematica-a-functional-programming-language
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/procedural-programming.html</guid>
    <pubDate>Tue 17 Jul 2018 13:41:57</pubDate>
  </item>
  <item>
    <title>Table / Do</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/table--do.html</link>
    <description>
        Table / Do  Both Table and Do are only barely functional programming, still generally used procedurally, but they are simple, much more efficient alternatives to For and While loops. All they do is loop over a list or range, with optional localized loop variables:  Compare:      For[ i = 1, i&lt; 10^6, i++, PrimeQ@i]// AbsoluteTiming//First (*Out:*) 0.830501`    and      Do[ PrimeQ@i,{i,10^6}]// AbsoluteTiming//First (*Out:*) 0.31723`    Its over 2x faster to use Do here and the result is exactly the same. Moreover, as shown before, Table will automatically accumulate the results of each step, with huge efficiency gains over the equivalent procedural construct:      results={}; For[ i = 1, i&lt; 2.5*10^4, i++,AppendTo[results, PrimeQ@i]]// AbsoluteTiming//First (*Out:*) 3.008666` Table[PrimeQ@i,{i,2.5*10^4}]// AbsoluteTiming//First (*Out:*) 0.008375`
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/table--do.html</guid>
    <pubDate>Fri 29 Dec 2017 17:18:59</pubDate>
  </item>
  <item>
    <title>Map / Scan</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/map--scan.html</link>
    <description>
        Map / Scan  Note that often we can even one-up Table and Do in terms of simplicity, while losing no performance. Map and Scan pass an argument from a list to a function, much as Table and Do iterate over a range or list:      Table[PrimeQ@i,{i,10^6}]// AbsoluteTiming//First (*Out:*) 0.369371`    compared to      Map[PrimeQ,Range[10^6]]// AbsoluteTiming//First (*Out:*) 0.3625`    Even better, though, Map has a more compact in-line syntax:      PrimeQ/@Range[10^6]// AbsoluteTiming//First (*Out:*) 0.374421`    Over time you will start thinking in this new syntax. Rather than map prime-q over range of 10^6 you will start to think prime-q slash at range of 10^6.  Note that both Map and Table generate output, while their equivalents Scan and Do dont. Even though Scan does not have in-line syntax it is worth getting to know, as it can sometimes be more efficient than Do and is, of course, vastly more efficient than For
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/map--scan.html</guid>
    <pubDate>Fri 29 Dec 2017 17:19:07</pubDate>
  </item>
  <item>
    <title>Nest / NestList</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/nest--nestlist.html</link>
    <description>
        Nest / NestList   Nest  Often instead of mapping a function over a list we want to map a function in a nested fashion, taking the previous result as the argument of our next call. For this, there is Nest . We could, for instance, implement a random-walk function using this.  First the random vector:      randomVector= Compile[{ {mag,_Real} }, mag*Normalize@RandomReal[{-1,1},3] ];    Then the random walk starting from a point:      randomWalk[start_,n_,stepSize_]:=Nest[randomVector[stepSize]+#&amp;,start,n]; randomWalk[{0,0,0},100,.1] (*Out:*) {-0.6701260860918063`,0.14108631400644098`,-0.18613771198513052`}    Do to this procedurally we would have had to have scoped it then looped:      randomWalkP[start_,n_,stepSize_]:= Module[{current=start,i}, For[i = 1, i&lt;= n , i++,current+= randomVector[stepSize]]; current ]; randomWalkP[{0,0,0},100,.1] (*Out:*) {-0.014976940150273566`,0.9945437636484472`,-0.08019586484541548`}    And then we can see the efficiency gains of the former:      randomWalkP[{0,0,0},10^6,.1]// AbsoluteTiming//First (*Out:*) 2.599178` randomWalk[{0,0,0},10^6,.1]// AbsoluteTiming//First (*Out:*) 1.824635`    Small (most of the cost comes from the normalization in randomVector , hence the Compile call) but non-negligible.    NestList  The gains are drastic if we want all of our walk positions. For this we use the corresponding NestList function:      randomWalk2[start_,n_,stepSize_]:= NestList[randomVector[stepSize]+#&amp;,start,n]; randomWalk2[{0,0,0},10^6,.1]//AbsoluteTiming//First (*Out:*) 1.892415` randomWalkP2[start_,n_,stepSize_]:= Module[{path={start},i}, For[i = 1, i&lt;= n , i++,AppendTo[path, randomVector[stepSize]+Last@path]]; path ]; randomWalkP2[{0,0,0},10^5,.1]// AbsoluteTiming//First (*Out:*) 27.372997`    Note that, not only does it take almost 15x as long, we accumulated an order of magnitude fewer points.  Lets put this to good use, now, seeing where our random walks end up:      randomWalkP2[{0,0,0},2.5*10^4,.1]//Mean//AbsoluteTiming (*Out:*) {1.821336`,{7.575784741863281`,-5.394047567758916`,2.3229639385579515`}} randomWalk2[{0,0,0},25*10^3,.1]//Mean//AbsoluteTiming (*Out:*) {0.043608`,{-6.015475841270593`,-0.6336148160099607`,-3.303309091893062`}}    Both have traveled a considerable distance and using the vast efficiency gains from the NestList we can actually see if this holds in general or if its just a spurious effect:      Table[randomWalk2[{0,0,0},25*10^3,.1]//Mean//Norm,100]//Mean//AbsoluteTiming (*Out:*) {4.537624`,8.4477492155034`}    So it does in fact seem that, on average, a random walk will leave its origin. Note that doing that checking the same thing procedurally would have take a number of minutes. We can do it in under five seconds.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/nest--nestlist.html</guid>
    <pubDate>Fri 29 Dec 2017 23:23:12</pubDate>
  </item>
  <item>
    <title>Fold / FoldList</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/fold--foldlist.html</link>
    <description>
        Fold / FoldList  Where Nest applies a function in to the result of the previous function call in a nested fashion, Fold and its related functions apply a function to the previous function call and simultaneously map over a list.  As a very simple example we can turn an expression like this:      c[a1,a2,a3,...,an]    into one like      c[a1][a2][a3][...][an]    in one line of code. This process is closely related to the concept currying in standard functional programming so we can call this pseudocurrying (in fact this example comes directly from a question I asked on the Mathematica stack exchange):      curry= Function[expr, Replace[expr,h_[a__]:&gt;Fold[#1[#2]&amp;,{h,a}]], HoldFirst];    where we take advantage of Mathematicas ability to set attributes on pure functions. We can use this to, for example, drill into nested associations, where we will also build our association using Fold :      data=Association@Fold[#2Replace[#,_Rule-&gt;Association@#]&amp;,Range[1,10]] (*Out:*) 10987654321 curry@data[10,9,8] (*Out:*) 7654321    Note that Mathematica already implements this type currying for associations:      data[10,9,8] (*Out:*) 7654321    But for other user-defined types this can be incredibly useful
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/fold--foldlist.html</guid>
    <pubDate>Fri 29 Dec 2017 17:19:22</pubDate>
  </item>
  <item>
    <title>FixedPoint and Gradients</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/fixedpoint-and-gradients.html</link>
    <description>
        FixedPoint and Gradients   Why is this here  While not tightly intertwined with all aspects of functional programming, this does provide an example of the simplicity with which we can do interesting tasks using functional programming.  Using a more procedural paradigm each portion of this code (outside of the basic gradient definitions) would be more involved, more error prone, and also less efficient.    FixedPoint and Gradients  Just as a side note there is a function called FixedPoint that is essentially Nest until the result doesnt change. This is great for following gradients to minima. We can use its corresponding FixedPointList to trace an arbitrary gradient. For now well use a gradient with a predictable result:      gradient= Compile[{ {pos,_Real,1}}, { Piecewise[{ {Sqrt@-(#+2),#&lt;-3}, {(-(#+2)^3),-3&lt;#&lt;0}, {-((#-2)^3),0#&lt;3}, {-Sqrt@(#-2),3&lt;=#} },#]&amp;@pos[[1]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[2]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[3]] } ]; Plot[First@gradient@{x,x,x},{x,-5,5}] (*Out:*)          Plot[Last@gradient@{x,x,x},{x,-5,5}] (*Out:*)       Essentially our system should be pushed to either {2,0,0} or {-2,0,0}  Then well calculate the path a point travels along (well apply a much rougher sameness test that FixedPoint usually takes):      (path= FixedPointList[ gradient@#+#&amp;, {5,2,2}, SameTest(Norm@Abs[#-#2]&lt;.0001&amp;)])//AbsoluteTiming//First (*Out:*) 0.001503`    And we can plot this:      Graphics3D[Arrow@Tube[path],AxesTrue,ImageSizeSmall] (*Out:*)       Then we can do this for many paths. First well calculate a grid across the cube { {-5,-5,-5},{5,5,5}} with 20 divisions on per direction:      gridPoints= Tuples[Subdivide[-5,5,20],3];    Then well compute the paths traveled (note how quickly this can be computed using FixedPoint ):      (paths= Table[ FixedPointList[ gradient@#+#&amp;, p, SameTest(Norm@Abs[#-#2]&lt;.1&amp;) ][[2;;]], {p,gridPoints} ])//AbsoluteTiming//First (*Out:*) 0.213083`    Well plot the paths followed:      Graphics3D[Line/@paths,AxesTrue,ImageSizeSmall] (*Out:*)       Note the central gap where the gradient sampled out the points immediately. We can visualize this by simply showing the first step for a central cube:      Arrow@{#,#+gradient@#}&amp;/@Tuples[Subdivide[-1,1,3],3]//Graphics3D[#, ImageSizeSmall, PlotRange{Automatic,{-2,2},{-2,2}}, AxesTrue, AxesOrigin{0,0,0}]&amp; (*Out:*)       Then well create a density map for these points based on the norm of the gradient at a each point along the paths:      pds=Append[#,Norm@*gradient@#]&amp;/@DeleteDuplicates@Flatten[paths,1]; densityData= With[{r=Last/@pds//MinMax}, ReplacePart[#,4-&gt;Rescale[Last@#,r]]&amp;/@pds ];    then use the magical ListDensityPlot3D to get a density plot of this:      ListDensityPlot3D[densityData, OpacityFunction(If[#&lt;.25,1-#,0]&amp;), ImageSizeSmall] (*Out:*)       Note that we dont see two wells because Mathematica interpolates between the two well pieces. We can change this by simply adding our grid points back in:      pdsNew=Join[pds,Append[#,Norm@gradient@#]&amp;/@gridPoints,1]; densityDataNew= With[{r=Last/@pdsNew//MinMax}, ReplacePart[#,4-&gt;Rescale[Last@#,r]]&amp;/@pdsNew ]; ListDensityPlot3D[densityDataNew, OpacityFunction(If[#&lt;.2,1-#,0]&amp;) ] (*Out:*)       Note the application of OpacityFunction to drop those bits of data with norms above the 20% mark. The rings are, of course, just coming from our grid points.  And of course we can functionalize this:      Options[gradientDensityPlot]=Options@ListDensityPlot3D; gradientDensityPlot[grad_, startPoints:{ {_?NumericQ,_?NumericQ,_?NumericQ},__List}, cutoff:_?NumericQ:.2, ops:OptionsPattern[] ]:= With[{ pathData= With[{o= Sequence@@ FilterRules[ {ops, SameTest-&gt;(Norm@Abs[#1-#2]&lt;.1&amp;) }, Options@FixedPointList]}, Join@@Map[ FixedPointList[grad@#+#&amp;,#,o]&amp;, startPoints] ] }, With[{ gradData= Append[#,Norm@grad@#]&amp;/@DeleteDuplicates@Join[pathData,startPoints] }, ListDensityPlot3D[ With[{r=MinMax@gradData}, ReplacePart[#, -1-&gt;Rescale[Last@#,r]]&amp;/@gradData ], FilterRules[ {ops, OpacityFunction-&gt;(If[#&lt;cutoff,1-#,0]&amp;) }, Options@ListDensityPlot3D] ] ] ];    By judicious use of RegionFunction and a density cutoff we can focus in on the places we are interested in:      gradientDensityPlot[gradient,gridPoints, .05, SameTest-&gt;(Norm@Abs[#1 - #2 ]&lt;.01 &amp;) ] (*Out:*)       Now lets try it on another gradient!  Well just use a linear gradient, pushing everything into zero:      gradientDensityPlot[-#/2&amp;,N@gridPoints] (*Out:*)
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/functional-programming/fixedpoint-and-gradients.html</guid>
    <pubDate>Fri 29 Dec 2017 23:22:29</pubDate>
  </item>
  <item>
    <title>Packages</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/packages.html</link>
    <description>
        Packages  Packages are a convenient way to partition code into chunks that don&#39;t interact with each other needlessly, allowing for simpler programming. Mathematica even has a special package file type, the .m file, which is closer to plain-text than a .nb file.  A package is really just a collection of symbols in a given context, defined so as to interact with only the System context and whichever contexts the user loads, which protects from name overlaps and things.    Definition  A package may be defined anywhere, using BeginPackage and EndPackage . Usually one inserts a Private context into the package, however, to make definitions cleaner, and only exposes a certain subset of functions, which are given usage messages. For example let&#39;s define a simple package:      BeginPackage[&quot;BabysFirstPackage`&quot;]; function1::usage=&quot;an exposed function&quot;; function2::usage=&quot;another one!&quot; $constant::usage=&quot;a package constant&quot;; Begin[&quot;`Private`&quot;]; function1[x_]:=function2[1,x]; function2[x_,y_]:=($constant=RandomReal[]*x*y); End[]; EndPackage[];    Note that the symbols must be used before they are given private definitions or else the definitions will be on private symbols.    Get and Needs  Once the package is defined, it&#39;s later imported using Get or Needs , the difference between which can be found in the documentation (there are no subtleties to be warned about, here).  Note that both Get and Needs only work on these very plain .m and .wl files. One cannot run Get on a notebook file and evaluate the expressions contained within so simply.    AutoGeneratedPackage and InitializationGroups  Happily there is a way to define packages within notebooks, using the AutoGeneratePackage option for the notebook. When this is set to Automatic , every time the notebook is saved it saves all of the initialization cells within to a package file with the same file name.  If this were all, that wouldn&#39;t be too useful, as having to specify all of the initialization cells is a pain. Happily we evade that problem by using an InitializationGroup , which is simply a cell group where all of the evaluatable cells are automatically initialization cells.  The way I often go about using this is creating two cell groups:  I put all of my package code here.  And run all of my tests here.  Then I make the Package cell an InitializationGroup . This way I can simply add and subtract from the package at will, but still get all the benefits of a notebook for testing and formatting.  Packages are also a great way to store useful tricks and things you develop for doing problem sets or similar projects. Just toss all of your tricks in one package and you can get them all at once.      See Also:    https://mathematica.stackexchange.com/questions/29324/creating-mathematica-packages/29325#29325
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/packages.html</guid>
    <pubDate>Tue 17 Jul 2018 13:42:56</pubDate>
  </item>
  <item>
    <title>Dynamic</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/dynamic.html</link>
    <description>
        Dynamic  Everything done up to here has involved static content. Often, though, dynamic content is what you need. I don&#39;t have the time to explain all of Dynamic here, given how many things one can do with Dynamic , but it&#39;s worth going over a few critical things.    Dynamic as formatting head  Dynamic only ever updates while it&#39;s on screen. This is one of it&#39;s key features, as otherwise things could get out of hand. How this works is that Dynamic is just something that the Mathematica front end sees and creates listeners to update.  This means, though, that if your content will never display it won&#39;t update. If you need an invisible updater, use DynamicWrapper .    Dynamic&#39;s second argument  Dynamic takes a function as a second argument that it calls whenever it tries to update, passing the update value as the first argument. We can use this to do fancy things like the following:      Slider@Dynamic[x, (x=RandomReal[])&amp;] (*Out:*)       The variable takes a random value every time we try to update it.  This could also be used to record responses:      $responseCache={}; Grid[ { { SetterBar[ Dynamic[Last@Replace[$responseCache,{}:&gt;{None}], AppendTo[$responseCache,#]&amp; ], Range[10] ], Dynamic@Column@$responseCache } }, Alignment-&gt;Top ] (*Out:*)       Each click adds to the response cache.    TrackedSymbols  Dynamic usually decides in a semi-opaque manner which symbols to track changes in, but we can force it to follow symbol updates. Let&#39;s make a Dynamic thing that passes colors back and forth. We&#39;ll write it using Mouseover so the passing only occurs when we&#39;re hovering      c1=Gray;c2=Green;counter=1; Mouseover[ Row@{Dynamic@Graphics[{c1,Disk[]}],Dynamic@Graphics[{c2,Disk[]}]}, Row@{ Dynamic[Graphics[{ c1=If[counter&lt;5, counter++;Pause[.1];c1, counter=1;c2], Disk[]}], TrackedSymbols:&gt;{c1,c2,counter}], Dynamic[Graphics[{ c2=If[c1===c2,RandomColor[],c2], Disk[]}],TrackedSymbols:&gt;{c1,c2,counter}] } ] (*Out:*)       You&#39;ll notice this works exactly as expected.  Often, however, one runs into issues with TrackedSymbols . This is because of an interesting implementation choice. To track a symbol, it needs to appear in the display expression and not too deep. Usually I simply put the symbol in as part of a CompoundExpression so it does nothing, but Dynamic knows to track it. The following is probably the safer way to write this, to ensure tracking:      c1=Gray;c2=Green;counter=1; Mouseover[ Row@{Dynamic@Graphics[{c1,Disk[]}],Dynamic@Graphics[{c2,Disk[]}]}, Row@{ Dynamic[counter;c1;c2;Graphics[{ c1=If[counter&lt;5, counter++;Pause[.1];c1, counter=1;c2], Disk[]}], TrackedSymbols:&gt;{c1,c2,counter}], Dynamic[c1;c2;Graphics[{ c2=If[c1===c2,RandomColor[],c2], Disk[]}],TrackedSymbols:&gt;{c1,c2,counter}] } ] (*Out:*)        UpdateInterval  Dynamic can also be scheduled to simply update on a given time frame, which is usually a fall back for when there&#39;s no other way to get symbol tracking to work right or there are no symbols to track. In this case it&#39;s very important the TrackedSymbols be passed an empty list.  Here&#39;s a classic stop watch example:      startTime=None;updateInterval=; Panel@Grid[{ {Button[&quot;Start&quot;, startTime=TimeObject[]; updateInterval=.1], Button[&quot;Stop&quot;,updateInterval=], Button[&quot;Reset&quot;,startTime=If[updateInterval===,None,TimeObject[]]] }, {Panel@Panel[ Dynamic[ updateInterval; startTime; Dynamic[ TemplateApply[&quot;``:``:``&quot;, If[MatchQ[#,_Integer], StringPadLeft[ToString[#],2,&quot;0&quot;], ToString@#]&amp;/@First@TimeObject@( If[ startTime===None, {0,0,0}, {0,0,Round[TimeObject[]-startTime//QuantityMagnitude,.01]}]) ], TrackedSymbols:&gt;{}, UpdateInterval-&gt;updateInterval], TrackedSymbols:&gt;{updateInterval,startTime}], ImageSize-&gt;200, Alignment-&gt;Center, Background-&gt;White], SpanFromLeft} }] (*Out:*)           See Also:    https://mathematica.stackexchange.com/questions/18393/what-are-the-most-common-pitfalls-awaiting-new-users/85491#85491
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/dynamic.html</guid>
    <pubDate>Tue 17 Jul 2018 14:04:09</pubDate>
  </item>
  <item>
    <title>Formatting</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/formatting.html</link>
    <description>
        Formatting  Mathematica has a number of useful formatting heads for arbitrary expressions, which fall into two main categories: spatial formatting and styling    Grid, Row, and Column  These are the primary spatial formatting heads. They primarily let you arrange lists nicely:      Column@RandomInteger[20,20] (*Out:*)          Row@Riffle[RandomInteger[20,20],&quot;, &quot;] (*Out:*) Row[{20, &quot;, &quot;, 19, &quot;, &quot;, 18, &quot;, &quot;, 7, &quot;, &quot;, 0, &quot;, &quot;, 19, &quot;, &quot;, 18, &quot;, &quot;, 19, &quot;, &quot;, 0, &quot;, &quot;, 20, &quot;, &quot;, 9, &quot;, &quot;, 3, &quot;, &quot;, 4, &quot;, &quot;, 18, &quot;, &quot;, 11, &quot;, &quot;, 18, &quot;, &quot;, 11, &quot;, &quot;, 17, &quot;, &quot;, 15, &quot;, &quot;, 18}] Grid@Array[RandomInteger[20,20]&amp;,20] (*Out:*)       Each of these comes with their own options and formatting rules, but the idea is the same for all of them. Ill just point out a few things:  Anything can be part of a formatted expression:      Grid@Array[Array[Graphics[{RandomColor[],Disk[]},ImageSizeRandomInteger[{5,20}]]&amp;, 5] &amp;, 5] (*Out:*)       The internal expression is also still possible to recover using First :      First@%       And a Grid is not just a Column of Rows :      Row/@%//Column (*Out:*)       Grid in particular has three special elements types that change how spacing is done, SpanFromLeft , SpanFromAbove , and SpanFromBoth . It is not always clear exactly what combination of spanning elements will achieve the desired effect, but just play around with them until the output looks right and youll be fine.  Be sure to look at all of the options for Grid as there are many cool things one can do. As a quick example, one can put in dividers with arbitrary coloring:      Grid[ Array[Array[Graphics[{RandomColor[],Disk[]},ImageSizeRandomInteger[{5,20}]]&amp;, 5] &amp;, 5], Dividers{Array[#-&gt;RandomColor[]&amp;,6],Array[#-&gt;RandomColor[]&amp;,6]} ] (*Out:*)       Similarly look at Item because it provides more fine-grained control over grid formatting, which can often be useful.    Style, Framed, Pane, and Panel  The other class of formatting heads is the styling heads. First among them is Style which applies styling to an expression, particularly text:      Style[ HoldForm[ Row@{  0  Cos[]Sin[], Spacer[25], Graphics[Disk[]] } ], BackgroundRandomColor[], FontSizeLarge, FontColorRandomColor[], FontFamilyRandomChoice@$FontFamilies, FontVariations{&quot;Underline&quot; -&gt; True,&quot;Underlight&quot;Purple}, FontWeightBold, AutoStyleWords{ &quot;Cos&quot;&quot;Text&quot;, &quot;Sin&quot;&quot;Section&quot; } ]        (*Out:*)       Essentially any styling one can apply to a Cell , one can apply to an expression using Style  Framed on the other hand does one thing. It puts a frame around an expression:      Framed[&quot;Are you enjoying the tutorial?&quot;] (*Out:*)       But what makes it useful is the styling one can apply to the frame:      Framed[ Style[&quot;Are you enjoying the tutorial?&quot;,Blue], RoundingRadius5, FrameStyleGrayLevel[.8], BackgroundLightBlue] (*Out:*)       It does nothing to affect the display of the actual expression though.  In contrast, that is all Pane does. Pane merely provides a way to change how an expression displays on screen. Its chief use is for preventing large objects from taking up lots of display space:      Pane[ ExampleData[{&quot;Text&quot;,&quot;USConstitution&quot;}], ImageSize{500,250} ] (*Out:*)       The display size can be variable and one can also attach scroll bars and things:      Pane[ ExampleData[{&quot;Text&quot;,&quot;USConstitution&quot;}], ImageSize{ {Automatic,500},250}, Scrollbars{False, Automatic} ]//Framed[#,FrameMargins{ {3,0},{0,0}}]&amp; (*Out:*)       Pane has less customization than the rest of the styling heads, but is possibly the most useful when designing quality interfaces  Panel is different from the other styling heads in that it is a sort of amalgamation of all three:      Panel[&quot;Check this out&quot;] (*Out:*)       It basically generates a frame and applies default text styling, but the size of the panel can also be set:      Panel[ ExampleData[{&quot;Text&quot;,&quot;USConstitution&quot;}], ImageSize{500,250} ] (*Out:*)       Unfortunately scrolling is disabled, so often one wraps a Pane in a Panel to achieve that:      Panel[ Pane[ ExampleData[{&quot;Text&quot;,&quot;USConstitution&quot;}], ImageSize{500,250}, Scrollbars{False, Automatic} ] ] (*Out:*)       Panel is a nice, simple, reasonably professional looking go-to for arbitrary formatting, so it should often be the one of the first things one considers when formatting and expression    Format and Interpretation  The use for most of this formatting is often to hide the complexity of an expression. One leverages the power of the Format function and Interpretation functions to make an ugly expression look nice.  Usually one does this by defining an inert formatting head to wrap around the expression and defining the formatting for that expression:      Format[ExampleDataFormatter[data_,title_]]:= Interpretation[ Panel[Column[{ Style[title,Large,Bold], Panel@Pane[ data, ImageSize-&gt;{ {Automatic,400},150}, Scrollbars-&gt;{False, Automatic} ]}, Dividers-&gt;Center] ], ExampleDataFormatter[data,title] ]; ExampleDataFormatter[ ExampleData[{&quot;Text&quot;,&quot;USConstitution&quot;}],&quot;The United States Constitution&quot;] (*Out:*)          Column@{ StringLength@First@%, Head@%, Last@% } (*Out:*)       This allows the often messy internal structure of a Mathematica expression to be hidden by a nice, content-rich format.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/formatting.html</guid>
    <pubDate>Fri 29 Dec 2017 23:24:13</pubDate>
  </item>
  <item>
    <title>Interfaces</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/interfaces.html</link>
    <description>
        Interfaces   Button  Button is as simple as they come. Its just a button. It has an expression it puts on the button and it runs a command and thats it:      Button[ MouseAppearance[&quot;Click Me&quot;, Style[&quot;?&quot;,Large,Bold] ], Print[&quot;Ouch!&quot;]] (*Out:*)       Its got some nice formatting options:      Row@Table[ With[{a=a}, Button[ MouseAppearance[&quot;Click Me&quot;, Style[&quot;?&quot;,Large,Bold] ], Print[a], Appearancea] ], {a,{Automatic,&quot;Frameless&quot;,&quot;Palette&quot;,&quot;AbuttingRight&quot;,&quot;AbuttingLeft&quot;}} ] (*Out:*)       And you can change its basic styling:      Button[ Mouseover[&quot;You deserve a break&quot;, Style[&quot;Relax and click here&quot;,&quot;HyperlinkActive&quot;] ], SystemOpen@&quot;https://www.youtube.com/watch?v=cMdiYuzHVZ4&quot;, BaseStyle&quot;Hyperlink&quot;, Appearance&quot;Frameless&quot; ] (*Out:*) [&quot;You deserve a break&quot;](#&quot;You deserve a break&quot;)     InputField  An InputField is pretty self-explanatory:      InputField[&quot;Hi there&quot;,String] (*Out:*)       Its usefulness comes when combined with Dynamic     inputVar=&quot;Change me&quot;; InputField[Dynamic[inputVar, Print[&quot;Changed!&quot;];inputVar=#;&amp;],String] (*Out:*)          inputVar    It of course has many useful styling and usage options but these are generally pretty well documented so there is no pressing need to discuss them here.    PopupMenu  A PopupMenu just selects a value from a list:      PopupMenu[&quot;&quot;,Prepend[Names[&quot;*Data&quot;],&quot;&quot;Style[&quot;Choose a data type&quot;,Italic,Gray]]] (*Out:*)       Once again we can also set a variable this way:      Dynamic@popupVar; PopupMenu[Dynamic@popupVar,Prepend[Names[&quot;*Data&quot;],&quot;&quot;-&gt;Style[&quot;Choose a data type&quot;,Italic,Gray]]] (*Out:*)          popupVar     EventHandler  EventHandler isnt really an interface element so much as an extension for them. It catches front end events -- mouse clicks, keyboard input, etc. and routes them through a set of rules. Its powerful, but can be a little tough to use.  Mathematica, unlike a more usual front-end system like tkinter, has no rich event syntax, instead it depends on the user querying the front end about global state, such as how one catches a double click event:      youDidIt=False; nowClickPrinted=False; wellDonePrinted=False; EventHandler[ MouseAppearance[ Panel[&quot;Double click here&quot;], &quot;Arrow&quot;],{ &quot;MouseEntered&quot;:&gt; If[!(youDidIt//TrueQ)&amp;&amp;!(nowClickPrinted//TrueQ),Print[&quot;Now click&quot;]; nowClickPrinted=True], &quot;MouseClicked&quot;:&gt; If[CurrentValue@&quot;MouseClickCount&quot;==2, If[!(youDidIt//TrueQ), Print[&quot;You did it!&quot;]; youDidIt=True ] ], &quot;MouseExited&quot;:&gt;If[ youDidIt&amp;&amp;!(wellDonePrinted//TrueQ), Print[&quot;Well done&quot;]; wellDonePrinted=True] } ] (*Out:*)       This is an undeniably poor way to do things with myriad pitfalls, but it is one of the restrictions of the system, unfortunately.  The full list of events that EventHandler can use isnt completely clear, but the most common use cases are on its doc page. Others can be found by `` &quot;googling&quot; ``` .  One class of events to know about is the class of &quot;MenuCommand&quot; events. These look like {&quot;MenuCommand&quot;, token} and of these particularly crucial are the tokens &quot;HandleShiftReturn&quot; and &quot;EvaluateCells&quot; . These prevent Shift-Return or Keypad-Enter from evaluating and creating a new cell. Heres a way to use this:      HandlerInputField[sym:_Dynamic|None:None,handlerFunction_,ops___]:= With[{dynSym=Replace[sym, NoneWith[{u=Unique@&quot;handlerInputFieldValue$&quot;},u=Null;Dynamic@u] ]}, EventHandler[InputField[dynSym,ops],{ {&quot;MenuCommand&quot;,&quot;HandleShiftReturn&quot;} Replace[ dynSym, Verbatim[Dynamic][s_,___]( handlerFunction@s; s=&quot;&quot; ) ], {&quot;MenuCommand&quot;,&quot;EvaluateCells&quot;} Replace[ dynSym, Verbatim[Dynamic][s_,___]( handlerFunction@s; s=&quot;&quot; ) ], &quot;ReturnKeyDown&quot;NotebookWrite[EvaluationNotebook[],&quot;\n&quot;] } ] ]    This creates and input field wrapped in an event handler. Now well make an interface that can log the most common words we type. Type normally and return with Shift-Return.      wordLog={}; Column[{ HandlerInputField[ (wordLog=Join[wordLog, ToLowerCase/@StringSplit@StringReplace[#,Except[WordCharacter|&quot;&#39;&quot;]-&gt;&quot; &quot;] ])&amp;, String ], Dynamic[ With[{a=Counts@wordLog}, BarChart[Values@a, ChartLabels-&gt;Keys@a] ] ] }, Dividers-&gt;{ {},{2-&gt;Gray}} ]     OpenerView and Toggler  OpenerView is a particularly nice formatting element which lets expressions be hidden but a title displayed:      OpenerView@{&quot;Updating dynamic thing&quot;, Dynamic[ Pause[.5]; Graphics@{RandomColor[],Disk[]}, UpdateInterval1]} (*Out:*)       Its really a subclass of Toggler (well its parent function Opener is) but worth mentioning because of how useful it is. A nice way to add underlines is to use Column :      OpenerView@{ Column[ {&quot;Updating dynamic thing&quot;}, Dividers{ {},{2Gray}} ], Dynamic[ Pause[.5]; Graphics@{RandomColor[],Disk[]}, UpdateInterval1]} (*Out:*)       Toggler just toggles between expressions when clicked      Toggler[1,Table[iFramed[ Style[i,FontColorIf[i&lt;5,White,Black]], RoundingRadius5, FrameStyleNone, BackgroundGrayLevel[i/10]],{i,10}]] (*Out:*)       And Toggler can similarly be used as a variable setter:      togglerVar=1; Toggler[Dynamic@togglerVar,Table[i-&gt;Framed[ Style[i,FontColor-&gt;If[i&lt;5,White,Black]], RoundingRadius-&gt;5, FrameStyle-&gt;None, Background-&gt;GrayLevel[i/10]],{i,10}]] (*Out:*)          togglerVar
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/interfaces.html</guid>
    <pubDate>Fri 29 Dec 2017 23:24:03</pubDate>
  </item>
  <item>
    <title>The Front End</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/the-front-end.html</link>
    <description>
        The Front End  The front end is what most people think of when they think of Mathematica. It&#39;s the collection of cells and notebooks and palettes and windows that you use to program, do your homework, write your resume, etc.  This is separate from the back end, also known as the kernel. That is where all your definitions and variables live. That&#39;s where the your code actually runs.  The two communicate, but it&#39;s important to understand that they are separate entities altogether    The Front End  The front end can be accessed via the symbol $FrontEnd . This is the most global way to set options, change formatting, etc. For example, we can get the current default window size:      WindowSize/.Options[$FrontEnd,WindowSize] (*Out:*) {808,755}    We can also change this, but often the better thing to do is just to change the value on the symbol $FrontEndSession which only applies the changes for the current session. $FrontEnd keeps track of any changes applied and caches them permanently.      SetOptions[$FrontEndSession,WindowSize-&gt;{100,100}]    This will change how big any windows we make appear, although it will not change the size of windows made with File  New or  +** ****N** . We can test this out using CreateDocument though:      CreateDocument[]    We can also remove this:      SetOptions[$FrontEndSession,WindowSize-&gt;Inherited]    Since $FrontEndSession inherits from $FrontEnd this reverts the change    Notebooks  A notebook is any window Mathematica creates. We can find all of the notebooks:      Notebooks[]    Or notebooks matching a name:      Notebooks[&quot;Mathematica For Chemists&quot;]    A notebook is represented by a NotebookObject . A NotebookObject only exists for a given front end session. We can see why if we look at its InputForm :      CreateDocument[]//InputForm    This is a symbolic form that represents an object communicating with the front end specified by the FrontEndObject ( LinkObject refers to a link to a kernel processsomething beyond the scope of what we&#39;re working with here). Its ID is the last argument. Every time we create a new notebook the ID increments, so that within a given front end session no two notebooks will ever have the same ID.  Mathematica has a special notebook that always exists:      First@Notebooks@&quot;Messages&quot;    Mathematica will dump all messages generated without a notebook to this notebook. Generally this means dynamically generated messagesthat is, messages generated by Dynamic or other front-end events.  In a given evaluation, Mathematica keeps track of the notebook that started it. This can be obtained as follows:      EvaluationNotebook[]    Note that this applies even in the case of Dynamic evaluations:      Dynamic@EvaluationNotebook[]// CreateDocument[#, WindowSize-&gt;Small, WindowTitle-&gt;&quot;Different notebook&quot;]&amp;; Dynamic@EvaluationNotebook[]    In most cases this is the most useful notebook to have, but there are a number of others that may be of interest.  This will give the notebook that currently has keyboard focus. This is very useful when making palettes.      InputNotebook[]    If the current evaluation was started by a button, this gives the notebook that button was in. Again, useful for palettes and similar functionality.      ButtonNotebook[]    We can get and set options on notebooks just like the front end:      SetOptions[ CreateDocument[], Background-&gt;RandomColor[] ]    We can also write data to a notebook:      nb=CreateDocument[]; NotebookWrite[nb,&quot;some_string&quot;]    We&#39;ll go more into detail of what exactly can be written and where when discussing Cells and Boxes .  One final thing: although a displayed notebook is referenced by a NotebookObject , it is stored as an expression with the head Notebook and for a given NotebookObject there is a way to get this expression:      NotebookGet@EvaluationNotebook[]    This pulls the entire Notebook expression for the current notebook.    Cells  As we just saw, at the symbolic level, a notebook is a list of Cell or CellGroupData expressions plus some options. In practice, though, this turns into a column of cells. We can get this list of cells by doing the following:      Cells@EvaluationNotebook[]    In the case of this notebook, this is a very large list of cells. Let&#39;s just look at the form of the first of these:      First@Cells@EvaluationNotebook[]//InputForm (*Out:*) CellObject[131425]    You&#39;ll notice it&#39;s just an ID, because the CellObject doesn&#39;t need to track a LinkObject the way a NotebookObject does. But otherwise it can largely be treated like a NotebookObject in terms of setting and getting options.  There are a number of ways to get a CellObject :      EvaluationCell[] NextCell[] PreviousCell[] (*Out:*)          (*Out:*)          (*Out:*)       As with a NotebookObject there is a stored symbolic form for a CellObject :      First@Cells@EvaluationNotebook[]//NotebookRead Cell[&quot;Mathematica For Chemists&quot;,&quot;Title&quot;,CellChangeTimes-&gt;{ {3.684256503623343`*^9,3.684256508302112`*^9}}]    And when we use NotebookWrite we often use it on these sorts of Cell expressions:      NotebookWrite[EvaluationNotebook[], Cell[&quot;A newly written cell&quot;,&quot;Output&quot;,CellDingbat-&gt;Cell[&quot;NEW!!&quot;,Background-&gt;None] ] ]    NotebookWrite can also be used to overwrite cells:      bg=Darker@Red; fg=Orange; CellPrint@Cell[ &quot;The phoenix burns to ashes...&quot;, &quot;Output&quot;, FontColor-&gt;fg, Background-&gt;bg ]; Do[ NotebookWrite[ NextCell[], Cell[ &quot;The phoenix burns to ashes...&quot;, &quot;Output&quot;, FontColor-&gt;Blend[{fg,Darker[bg,i/10]},i/10], Background-&gt;Darker[bg,i/10] ] ], {i,10} ]; Pause[.25]; Do[ NotebookWrite[NextCell[], Cell[&quot;And is reborn there from&quot;, &quot;Output&quot;, FontColor-&gt;Blend[{Darker[bg,1-i/10],fg},i/10], Background-&gt;Darker[bg,1-i/10] ] ], {i,10} ]    A general Cell expression has a deterministic form:      Cell[data_,style_,options__]    data will generally either be a String , BoxData expression, or TextData expression. The differences between these forms will become clearer in the section on Boxes  When working with a cell, it&#39;s possible to view and edit this symbolic representation using Cell  Show Expression or +E   Boxes  If notebooks are windows and cells are elements of a notebook, then Boxes describe front-end content. Every piece of content except for primitives such as strings and numbers has a box form for display. Boxes allow for the interesting formatting that Mathematica permits, by giving a low-level spec for various styling options. We can view the boxes in an expression using ToBoxes :      Framed[Style[ &quot;Something super cool&quot;, FontColor-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}] ], RoundingRadius-&gt;5, FrameStyle-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}], Background-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,Background}] ] (*Out:*) &quot;Something super cool&quot; ToBoxes@ Framed[Style[ &quot;Something super cool&quot;, FontColor-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}] ], RoundingRadius-&gt;5, FrameStyle-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}], Background-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,Background}] ] (*Out:*)       To make content like Dynamic work these boxes can&#39;t be static objects, though. Much like CellObject and NotebookObject there is a BoxObject which we can access, although with more difficulty. Easiest, though, is just to use EvaluationBox :      Dynamic[EvaluationBox[]]    Note that this really does have to be wrapped in Dynamic . Before it is displayed, this box doesn&#39;t exist. But we can do something fun with this now:      Dynamic[box=EvaluationBox[]] NotebookWrite[box, ToBoxes@ Framed[Style[ &quot;And the box disappears...&quot;, ShowStringCharacters-&gt;False, FontColor-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}] ], RoundingRadius-&gt;5, FrameStyle-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,FontColor}], Background-&gt;CurrentValue[{StyleDefinitions,&quot;Section&quot;,Background}] ]]    This gives us a way to use NotebookWrite to overwrite data without overwriting a cell itself.    Stylesheets  Stylesheets give us the power to leverage the multitudinous styling options available to cells to make cascading stylesheets for giving custom styles to notebooks. On the whole this process is straightforward once you know how to get started.  For a given notebook, you can access its stylesheet by going to Format  Edit Stylesheet . There you can edit the default cell styles or define your own.  What the front end pays attention to are cells formatted like this:      Cell[StyleData[style_],options___]    This will set options on all cells with style style by default. To inherit definitions from a different cell style use:      Cell[StyleData[style_,StyleDefinitions-&gt;StyleData[parent_]],options___]    That&#39;s pretty much it. Past that it&#39;s simply a matter of figuring out what styles work best and knowing which options do what you want done.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/the-front-end.html</guid>
    <pubDate>Tue 17 Jul 2018 13:19:33</pubDate>
  </item>
  <item>
    <title>Remote Kernels</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/remote-kernels.html</link>
    <description>
        Remote Kernels  As mentioned in the previous section, in addition to the front-end there is the kernel. One very useful feature of Mathematica, though, is that it allows for multiple kernels to be running.  Remember that the kernel is where your code runs, so if you have a particularly time-intensive calculation running in one kernel it can be convenient to have a secondary kernel running.    Add kernels  We start another kernel via the front end. Go to Evaluation  Kernel Configuration Options... and then click Add... and give a name to your new kernel.  Then in a new notebook go to Evaluation  Notebook&#39;s Kernel and choose this new kernel you created.    Add kernels via FrontEndTokens  We&#39;ll discuss FrontEndTokens more later, but for now just consider them a mechanism to use all front end functionality from the kernel.  For our cases here, we can make our lives a little bit easier by using a special FrontEndToken     FrontEndExecute@FrontEndToken[&quot;ModifyEvaluatorNames&quot;]    or more simply:      FrontEndTokenExecute[&quot;ModifyEvaluatorNames&quot;]    This gives us the add dialog. Unfortunately FrontEndTokens are not particularly well documented and so the command for setting a notebook&#39;s kernel remains opaque.    Remote kernels  One useful feature of kernels is that they can be run anywherenot just on your local computer. If, then, Mathematica exists on a remote server, call it &quot;server.place.dom&quot; , say, a kernel can be initiated there and connected to your local front end, by passing X-Windows or a similar remote GUI system.  We can access this by going back to Evaluation  Kernel Configuration Options... or doing the same via the following:      FrontEndTokenExecute[&quot;ModifyEvaluatorNames&quot;]    Then in Add... under Basic Options select Remote Machine and input your info. If the server is &quot;server.place.dom&quot; , put that as the Remote host and give your info as the Remote user .  Then whenever you give that kernel as a notebook name and try to evaluate anything or start the kernel, Mathematica will pop up a dialog asking for your password.  If you have RSA authentication enabled, this password step becomes unnecessary.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/higher-level-functionality/remote-kernels.html</guid>
    <pubDate>Mon 16 Jul 2018 18:48:38</pubDate>
  </item>
  <item>
    <title>Compile</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/performance-tuning/compile.html</link>
    <description>
        Mathematica is what is often called a high-level programming language, because when you are writing programs, you don&#39;t need to worry about how the computer is doing its job. This provides notable gains in simplicity and scalability of large programs, but it comes at the cost of the speed and efficiency of low-level computations.      Basics of Compilation  To get around this Mathematica provides the function Compile which will generate a low-level function that we can then apply with fantastic results. For example, in the section on Nest I provided a random vector generator:  This creates a compiled function that will perform the task at hand, in this case taking a vector of Real numbers and returning a vector. Just so we can see the difference let&#39;s create the same function, uncompiled and compare the two:      randomVector= Compile[{{mag,_Real}}, mag*(#/Norm[#])&amp;@RandomReal[{-1,1},3] ] (*Out:*)          randomVectorU= Function[mag, mag*Normalize@RandomReal[{-1,1},3] ];    Then we&#39;ll compare them using a little timing function:      compareTiming[f1_,f2_,its_:1]:= With[{ tf1=First@AbsoluteTiming[Do[f1,its]],tf2=First@AbsoluteTiming[Do[f2,its]]}, (tf2-tf1)/Max@{tf1,tf2} ]; compareTiming~SetAttributes~HoldAll; compareTiming[ randomVector[1], randomVectorU[1], 10^6 ] (*Out:*) 0.5244177474084153`    So we get a 52% speed boost from essentially just changing Function to Compile on the simplest function imaginable. If we had a more involved function the speed boost would likely be even larger. But since it&#39;s so simple we can easily dissect what is giving the speed boost:    Analyzing Compile  We&#39;ll build from the bottom up:      randomReal3=Compile[{},RandomReal[{-1,1},3]]; randomReal3U=Function[RandomReal[{-1,1},3]]; compareTiming[randomReal3[], randomReal3U[],10^6] (*Out:*) 0.4059389866935647`    This alone is 40% faster! Of course when we know how many vectors we&#39;ll need ahead of time the fastest thing is to use the syntax RandomReal[range,{count,3}] which can, for example, generate 10^8 random vectors in a fraction of a second, which is much, much faster than our compiled form:      compareTiming[Do[randomReal3[], 10^7], RandomReal[{-1, 1}, {3, 10^7}]] (*Out:*) -0.9477078222470973`    Ignoring the correct way to do this, though, and considering out surprising result, this is likely an artifact of type-checking in the compiled function that has to be performed at each call in the uncompiled one.  When we add our normalization now:      randomVectorNoMag= Compile[{}, (#/Norm[#]&amp;)@RandomReal[{-1,1},3] ]; randomVectorNoMagU= Function[ Normalize@RandomReal[{-1,1},3] ]; compareTiming[randomVectorNoMag[], randomVectorNoMagU[], 10^6] (*Out:*) 0.4923576135986387`    Now we&#39;re a full 50% faster than we were (that this is greater than our original 40 is likely just a lack of consistency between runs).  Note that I&#39;m in the CompiledFunction I&#39;m not using Normalize . This is because Normalize cannot be directly compiled.  We can see this by looking at the intermediate representation generated when we use it:      &lt;&lt;CompiledFunctionTools` CompilePrint@ Compile[{}, Normalize@RandomReal[{-1,1}, 3] ]//Snippet[#, -5]&amp;       (*Out:*) 1 R0 = I1 2 R1 = I2 3 T(R1)1 = RandomReals[ R0, R1, T(I1)0]] 4 T(R1)2 = MainEvaluate[ Hold[Normalize][ T(R1)1]] 5 Return    The call to &quot;MainEvaluate&quot; means that the compiled function couldn&#39;t handle this and thus it returns the value to the main evaluator to process.    Drastic Examples  The previous case was simple so that it could easily be analyzed, but for more complicated cases we can much bigger gains. Consider the primary gradient function we used in the section on FixedPoint :      gradient= Compile[{{pos,_Real,1}}, { Piecewise[{ {Sqrt@-(#+2),#&lt;-3}, {(-(#+2)^3),-3&lt;#&lt;0}, {-((#-2)^3),0&lt;=#&lt;3}, {-Sqrt@(#-2),3&lt;=#} },#]&amp;@pos[[1]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[2]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[3]] } ];    And then consider its uncompiled cousin:      gradientU= Function[pos, { Piecewise[{ {Sqrt@-(#+2),#&lt;-3}, {(-(#+2)^3),-3&lt;#&lt;0}, {-((#-2)^3),0&lt;=#&lt;3}, {-Sqrt@(#-2),3&lt;=#} },#]&amp;@pos[[1]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[2]], Piecewise[{ {Sqrt@-(#),#&lt;-1}, {(-(#)^3),-1&lt;=#&lt;=1}, {-Sqrt@(#),1&lt;=#} },#]&amp;@pos[[3]] } ]; With[{grid=RandomReal[{-5,5},{10^5,3}]}, compareTiming[ gradient@g, gradientU@g, {g,grid}] ] (*Out:*) 0.8961919038258733`    So the simple application of Compile provides a 90% speed boost.  As another example, one can implement numerical integration of a volume over a surface via:      compDotCross= Compile[{{coords, _Real, 2}, {abc,_Integer,1}}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]] ]; vol[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, (MeshCells[s, 2]/.Polygon[g_List] :&gt; compDotCross[coords, g]) //Total ]/6    then get an interesting surface:      surf= RegionUnion@@ With[ { graphics= FirstCase[ ChemicalData[&quot;Caffeine&quot;, &quot;SpaceFillingMoleculePlot&quot;], _GraphicsComplex, None,  ] }, Cases[ graphics[[2]], Sphere[s_, r_]:&gt;Ball[graphics[[1, s]], r] ] ]//BoundaryDiscretizeRegion[#, MaxCellMeasure-&gt;{1-&gt;20}]&amp; (*Out:*)       And compute its volume:      vol@surf//RepeatedTiming (*Out:*) {0.0989207000000000003`2.,1.6728430521905467`*^8} Volume@surf//RepeatedTiming (*Out:*) {0.0010948070175438598`2.,1.6728430521905503`*^8}    Our little compiled implementation is much slower than the built-in implementation, of course, but it&#39;s still incredibly fast for the level of mesh refinement.  Personally, I this it for computing atomic orbital volumes derived from orbital contour plots.  Lets then to a version without the compiled dot-cross:      uncompDotCross= Function[{coords, abc}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]] ]; volU[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, (MeshCells[s, 2]/.Polygon[g_List] :&gt; uncompDotCross[coords, g]) //Total ]/6 compareTiming[vol@surf, volU@surf] (*Out:*) 0.9539375762845481`    Ours is a whopping 95% faster. As the surface refinement increases this can be the difference between a function being nearly instantaneous versus a major speed bump in the research process.  We can also compare the version where we compile to C (i.e. we use CompilationTarget-&gt;&quot;C&quot;     compDotCross= Compile[{{coords, _Real, 2}, {abc,_Integer,1}}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]], CompilationTarget-&gt;&quot;C&quot; ]; volC[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, With[{compiledDotCross=compDotCross}, (MeshCells[s, 2]/.Polygon[g_List] :&gt; compiledDotCross[coords, g]) //Total ]/6 ] compareTiming[volC@surf, vol@surf] (*Out:*) 0.13463908089141324`    And simply compiling to C made the function 13% faster. More performance can be eked but by using the difference RuntimeOptions and things.    Using Compile  It&#39;s often unclear whether a given function can be compiled or not, but happily Mathematica provides all of the possible compilable functions in Compile`CompilerFunctions . We can use this to make a compileableQ type function:      compilableQ[f_]:= MemberQ[Compile`CompilerFunctions[], f]    For example, we can see that, say, RandomVariate is compilable:      compilableQ@RandomVariate (*Out:*) True    Alternatively we can figure out which Random functions are compilable:      compilableSelect[p_]:= Select[Compile`CompilerFunctions[], StringMatchQ[ToString@#,p]&amp;] compilableSelect@&quot;Random*&quot; (*Out:*) {RandomChoice,RandomSample,RandomInteger,RandomVariate,RandomComplex,RandomReal,Random}    Once we have that, Compile has a very simple call structure that is similar to Module :      Compile[ { {var1,type1,arraySize1}, {var2,type2,arraySize2}, ... }, expression, ops ]    This will generate a CompiledFunction which is just a function in either Mathematica byte code or C byte code, as specified by the CompilationTarget option. In most cases Mathematica byte code is more than fast enough, but there are cases where the C code is a significantly better choice.      See Also:    https://mathematica.stackexchange.com/questions/1803/how-to-compile-effectively     https://mathematica.stackexchange.com/questions/1096/list-of-compilable-functions
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/performance-tuning/compile.html</guid>
    <pubDate>Thu 19 Jul 2018 01:20:53</pubDate>
  </item>
  <item>
    <title>Special Array Types</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/performance-tuning/special-array-types.html</link>
    <description>
        Packed Arrays  Mathematica has a wide variety of low-level optimizations that we never run into in our high-level usage. One of the most useful of these is the concept of the PackedArray .  These are efficiently stored arrays of a single type of object that perform much faster on many simple numerical manipulations than their &quot;unpacked&quot; companions.  Most internal functions that return arrays will return them in packed form. We can check that an array is packed with Developer`PackedArrayQ :      reals = RandomReal[{-1, 1}, {1000, 1000}]; Developer`PackedArrayQ@reals (*Out:*) True    The memory footprint of these is much lower than standard arrays:      ByteCount@reals (*Out:*) 8000152 ureals=Developer`FromPackedArray@reals; Developer`PackedArrayQ@ureals ByteCount@ureals (*Out:*) False (*Out:*) 24208200    And operations that can return a packed array are faster than their unpacked variants:      1+reals//RepeatedTiming//First (*Out:*) 0.0024315980392156863`2. 1+ureals//RepeatedTiming//First (*Out:*) 0.0096411960784313737`2.     Unpacking  The biggest thing to worry about with packed arrays is the time/memory footprint that occurs when a packed array must be unpacked to be processed by a function that can&#39;t handle it in packed form.  For instance the function Chop necessarily unpacks as it replaces the Real number 0. with the Integer number 0 . This means Chop will actually be slower on a packed array:      Chop@reals//RepeatedTiming//First (*Out:*) 0.1129493750000000046`2. Chop@ureals//RepeatedTiming//First (*Out:*) 0.052316666666666671`2.    But if we use a function that can leverage the packing of the array it will be faster. For instance, let&#39;s look at the Real variant of Chop , a function called Threshold :      Threshold@reals//RepeatedTiming//First (*Out:*) 0.0030930624999999999`2. Threshold@ureals//RepeatedTiming//First (*Out:*) 0.0107768695652173899`2.    The packed version is much faster now.      RawArray  The RawArray is a relatively new addition to the language. It works rather like PackedArray in its requirement ot use a single type of object in it, but is a fundamentally different object.  It&#39;s main benefit is how little memory it consumes:      reals//ByteCount (*Out:*) 8000152    If we use a 64-bit real we get similar memory consumption to the packed array:      raw64=RawArray[&quot;Real64&quot;, reals]; raw64//ByteCount (*Out:*) 8000096    But we can specify that it out to use half as many bytes, as the memory usage will drop correspondingly:      raw32=RawArray[&quot;Real32&quot;, reals]; raw32//ByteCount (*Out:*) 4000096    These can also be used more effectively via Library Link but we won&#39;t get into that now. For many data-intensive custom Import formats RawArray can help cut down on the memory consumption, particularly where some large portions of the data may not be immediately useful.      SparseArray  We won&#39;t discuss SparseArray much, as the sparse array is a well-known concept especially in numerical linear algebra.  It is worth keeping in mind, though, for places where one has highly sparse data. One classic place this can show up is in quantum mechanical calculations in a direct-product basis constructed from orthonormal bases. Here often one will obtain expressions that looks like      H[n, m, i, j] = H1*[i, j] + H2*[n, m]    Assuming N1 elements in the first basis and N2 in the second, this can be more efficiently represented as:      H = KroneckerProduct[H1, IdentityMatrix[N2]] + KroneckerProduct[IdentityMatrix[N1], H2]    And now if we visualize this with H1 and H2 being odd-looking matrices which arise in this context:      H1=Table[(-1)^(i-j)/2 If[i==j, ^2/3, 2/(i-j)^2], {i, 50}, {j, 50}]; H2=Table[(-1)^(i-j)/(2*(.05)^2) If[i==j, ^2/3, 2/(i-j)^2], {i, 75}, {j, 75}]; H1//MatrixPlot (*Out:*)       We can directly construct H in a the standard fashion:      H = KroneckerProduct[H1, IdentityMatrix[Length@H2]] + KroneckerProduct[IdentityMatrix[Length@H1], H2];//AbsoluteTiming//First (*Out:*) 4.523075`    It takes a while and we see it has a large memory footprint:      H // ByteCount (*Out:*) 340260728    But if we visualize it we see it&#39;s most zeros:      H // MatrixPlot (*Out:*)       If we build it instead use SparseArray nothing will be done with that vast field of zeros, so it&#39;ll be faster and less memory intensive:      HS = KroneckerProduct[H1, IdentityMatrix[Length@H2, SparseArray]] + KroneckerProduct[IdentityMatrix[Length@H1, SparseArray], H2];//AbsoluteTiming//First (*Out:*) 0.118826` HS//ByteCount (*Out:*) 11191512    And even better, when we ask for its smallest 5 Eigenvalues these will be computed faster, and increasingly so with matrix size:      Eigenvalues[H, -5]//AbsoluteTiming (*Out:*) {4.943048`,{0.3917953580905429`,0.3745580141408224`,0.3611510903074643`,0.35157483336542145`,0.34582905618130677`}} Eigenvalues[HS, -5]//AbsoluteTiming (*Out:*) {3.733548`,{0.39179535809072363`,0.37455801414116613`,0.3611510903079675`,0.35157483336567635`,0.34582905618161475`}}
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/mathematica-programming/performance-tuning/special-array-types.html</guid>
    <pubDate>Sat 7 Jul 2018 00:12:57</pubDate>
  </item>
  <item>
    <title>Packages in Mathematica</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/basics/packages-in-mathematica.html</link>
    <description>
        Packages  We talked briefly before about packages in the context of programming, but we haven&#39;t talked about packages as an organizational structure in Mathematica.  As with most languages, packages provide a way to bundle together different code files and resources. By creating a package a developer allows disparate functionality to act as a single unit. There are packages in C, Java, Python, etc. and while they all have subtle differences in setup and exact usage, they all serve the same purpose. In this regard, Mathematica is no different.  We&#39;ll go more into how to set up one&#39;s own packages in a later post, but first we&#39;ll deal with some terminology.    Package File  Mathematica packages come in two variants. The first is simply bundling a number of functions into a single file with the extension &quot;.m&quot; or &quot;.wl&quot;  We talked about this earlier so in order to minimize repeating myself I won&#39;t go into this here.  The main case where this type of package is useful is when the size of the code is not particularly large, there aren&#39;t any external resources that should be distributed with the package, versioning and updating is not a concern, and no metadata needs to be stored.  Surprisingly this covers the major use case most casual coders will handle.  A package file can simply be installed via Get , so often one need not install a package file explicitly to make use of it.    Paclet  Since the term &quot;package&quot; was already used, what most programming languages call a package Mathematica calls a &quot;paclet&quot;.  A paclet is simply a .zip archive by another name that bundles code, resources, and metadata in a way that Mathematica&#39;s native package manager (the PacletManager system) can deal with. Paclets provide an easy way to install code, resources, stylesheets, palettes, and documentation via the PacletInstall function.  When we discuss packages for the rest of this section we will generally be talking about paclets, not package files themselves.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/basics/packages-in-mathematica.html</guid>
    <pubDate>Tue 17 Jul 2018 13:10:33</pubDate>
  </item>
  <item>
    <title>Paclets</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/basics/paclets.html</link>
    <description>
        Paclets  As we discussed previously, paclets provide a way to distribute code, resources, and other things in Mathematica. They are the native format for this type of distribution and are tightly bound into the system.  Paclets can provide any or all of the following:  Code Resources Style Sheets Palettes Documentation  In general the most common thing we&#39;ll want to provide is code, but the others are common things to distribute as well.    Paclet Structure  A paclet provides any of the aforementioned components and then also provides a file PacletInfo.m that supplies metadata. At its absolute simplest this might look like:      + PacletInfo.m Kernel + init.m MyPaclet.m     This will then get distributed as a ZIP file with the extension .paclet and name MyPaclet-version.paclet where version is formatted for semantic versioning.  We can distribute paclets in a more sophisticated manner via a server, but we&#39;ll talk about that and paclet construction after we go over some more basic usage.      See Also:    https://mathematica.stackexchange.com/questions/131101/how-to-distribute-mathematica-packages-as-paclets     https://mathematica.stackexchange.com/questions/1660/what-is-a-paclet     https://mathematica.stackexchange.com/questions/29324/creating-mathematica-packages     https://mathematica.stackexchange.com/questions/132064/pacletinfo-m-documentation-project     https://mathematica.stackexchange.com/q/141887/38205
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/basics/paclets.html</guid>
    <pubDate>Tue 17 Jul 2018 13:10:40</pubDate>
  </item>
  <item>
    <title>Multipackage Paclets</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/multipackage-paclets.html</link>
    <description>
        Paclets in the simplest case provide a single main package with the all of the functions implemented by the paclet. On the other hand, for any sufficiently complex package multiple packages will be needed. However, with the context mechanism Mathematica supplies it is not always clear what the best way to divide code over multiple packages is, so we&#39;ll provide a few different approaches      Predeclared Symbols / Shared Context  In the simplest case, every piece of the package will have the same context and simply directly share symbols. To make this work right, all of the package-level symbols need to be declared before any of the implementation files are loaded. One way this could work is having a directory structure like      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m ... + MyPaclet.m     And then have MyPaclet.m look like:      BeginPackage[&quot;MyPaclet`&quot;] MyPacletSym1::usage=&quot;...&quot;; MyPacletSym2::usage=&quot;...&quot;; ... Begin[&quot;`Private`&quot;]; Get/@ Select[ FileNames[&quot;*.m&quot;, FileNameJoin@{DirectoryName[$InputFileName], &quot;Kernel&quot;}], FileNameTake[#]!=&quot;init.m&quot;&amp; ]; End[]; EndPackage[];    And then each Component*.m file will simply provide definitions for the functions provided.      Folder-Based Contexts  A step up from this allows for different contexts to be supplied, taken from the folder the file is found in. This adds a layer of complexity, as we&#39;ll need a more complicated structure when declaring our symbols, but given the following directory layout:      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m Subcontext + Component1.m + Component2.m ... + MyPaclet.m     We could use the following loader:      BeginPackage[&quot;MyPaclet`&quot;] MyPacletSym1::usage=&quot;...&quot;; MyPacletSym2::usage=&quot;...&quot;; ... BeginPackage[&quot;`Subcontext`&quot;] MySubcontextSym1::usage=&quot;...&quot;; MySubcontextSym2::usage=&quot;...&quot;; EndPackage[]; With[{`Private`dirPath=FileNameJoin@{DirectoryName[$InputFileName], &quot;Kernel&quot;}}, Map[ Function[ Begin[ StringRiffle[ Join[ Most@ FileNameSplit[ FileNameDrop[ DirectoryName[#], FileNameDepth[`Private`dirPath]] ], { &quot;Private&quot;, &quot;&quot; } ], &quot;`&quot; ] ]; Get@#; End[] ], Select[ FileNames[&quot;*.m&quot;, `Private`dirPath, Infinity], FileNameTake[#]!=&quot;init.m&quot;&amp; ] ] ]; EndPackage[];        Packages with Autoloading  Depending on the size of the code, rather than simply load the entire package in when Get is called it can be efficient to introduce autoloading.  What this mean is that we determine which symbols are declared in which packages by inspecting the package header, but instead of loading the package we set the OwnValues to be a function that loads the package and then returns the symbol. By doing things this way we drastically cut down the load time for each function and keep parts of our package more appropriately contained.  The code for this can be a little bit long, so we won&#39;t get into it here, but more info on this can be found here .      Other Approaches  A list of other approaches with detailed pros-and-cons may be found here .
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/multipackage-paclets.html</guid>
    <pubDate>Mon 16 Jul 2018 19:18:14</pubDate>
  </item>
  <item>
    <title>Function Preparation</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/function-preparation.html</link>
    <description>
        Function Preparation  When making a production grade function there are a number of things we need to set:  Usage message templates Syntax hints Autocompletions Bad argument protection  Mathematica doesn&#39;t make it terribly simple to do this, but neither does it make it terribly difficult. There are, perhaps, 5 or so points of boiler plate to be covered. We&#39;ll handle these in turn, by considering some function, packageFunction , which is defined as follows:      Options[packageFunction]=Options[Panel]; packageFunction[ style:&quot;NewStyle&quot;|&quot;OldStyle&quot;, cont:_String?(StringEndsQ[&quot;`&quot;]), name_String?(StringMatchQ[LetterCharacter~~WordCharacter..]), ops:OptionsPattern[] ]:= Panel[ StringForm[&quot;`` is a `` package from the context ``&quot;, name, style, cont ], ops ]    It doesn&#39;t do terrible interesting things, but it&#39;ll be illustrative:      packageFunction[&quot;NewStyle&quot;, &quot;ctxt`&quot;, &quot;asd&quot;] (*Out:*)       This is how the function will start, and we&#39;ll incrementally add things to it    Usage Messages  Every symbol exposed to the public in a package should have a usage message. Not only does this give a usage hint if asked for, the system also uses it to format function templates that may be conveniently filled in.  For instance, if we look at the usage for MatrixQ we get the following:      ?MatrixQ      MatrixQ[ expr ] gives True if expr is a list of lists or a two-dimensional SparseArray object that can represent a matrix, and gives False otherwise. MatrixQ[ expr , test ] gives True only if test yields True when applied to each of the matrix elements in expr .    The nice thing is, if we type MatrixQ and then K we&#39;ll get a function template that we just fill out:      MatrixQ[expr,test]    We can set up a similar thing for our function. We take the call signature and strip all pattern constructs, but things like List constructs are totally fine to leave in.      packageFunction[style, cont, name, ops]    Then we turn this into a string and add a space and a short description of what it does:      &quot;packageFunction[style, cont, name, ops] tells us about a package function&quot;    Then once we assign this to the function&#39;s ::usage message we too can get that template:      packageFunction::usage= &quot;packageFunction[style, cont, name, ops] tells us about a package function&quot;; ?packageFunction      &quot;packageFunction[style, cont, name, ops] tells us about a package function&quot;        packageFunction[style, cont, name, ops]     Syntax hints  When we type something that Mathematica knows is an incorrect usage of a function it lets us know by some syntax hint in the front end. There are four different types of hints it can give us:  Missing / Excess argument hints  If I have too few arguments:      Plot[]    it inserts a red caret where it knows it need more arguments.  If I have too many:      MatrixQ[a, b, c, d, e]    it highlights the excess ones (the last three) in red  Bad option names  If I have a function with Options and I feed it an invalid option (according to a predefined list) the front-end can let me know:      Plot[x, {x, 0, 1}, BadOption-&gt;val]    that option name gets colored in Red  Local variable hints  If I have a function like Table or Solve the front-end can tell me which variables should be tagged as local. For instance in Table     Table[x*y*z, {x, 0, 1}, {y, 0, 1}]    the iterator variables ( x and y ) get colored teal  In Solve     Solve[x+y==1, x]    The solve variables ( x ) get colored teal  Misused equal signs  In things like If and Solve generally we want == , but sometimes accidentally type = . To help out with this rather subtle error Mathematica supplies a syntax hint highlighting this. For instance in:      If[x=1, ...]    The = is colored red  Now, we can set all of these different syntax hints on our function via the function SyntaxInformation . I won&#39;t get too much into this, as the reference page actually documents this quite well, but for completeness sake there&#39;s an undocumented hint &quot;OptionNames&quot; that allows one to provide valid option names without needing an explicit OptionsPattern in the &quot;ArgumentsPattern&quot; .  We&#39;ll ignore that, though, and just note that all we need for our function to have good syntax hints is to give it:      SyntaxInformation[packageFunction]= { &quot;ArgumentsPattern&quot;-&gt;{_, _, _, OptionsPattern[]} };     Autocompletions  This is probably the most useful bit of info we can attach to a function, especially if it&#39;s something like a router function, i.e. one that looks like:      $methodAssoc=&lt;|&quot;Method1&quot;-&gt;meth1, &quot;Method2&quot;-&gt;meth2, &quot;SpecialMethod&quot;-&gt;specMeth|&gt;; methodExecute[key_String?(KeyExistsQ[$methodAssoc, #]&amp;), args___]:= Module[{fn, res}, fn=$methodAssoc[key]; res=fn[args]; res/;Head[res]=!=fn ]    Autocompletions are a life-saver there, making it so one doesn&#39;t have to remember a plethora of string arguments for each method.  There is an undocumented way we can add autocompletion to our own functions via the front-end function FEPrivate`AddSpecialArgCompletion . This looks like:      FrontEndExecute@ FrontEnd`Value@ Map[ FEPrivate`AddSpecialArgCompletion, { &quot;name&quot;-&gt;{completions...} ... } ]    Where the completions are any of  {&quot;val1&quot;, &quot;val2&quot;, ...}  a list of possible completions 0  no completions 2 absolute file path 3  relative file path 4  a color 7  a package 8  a directory 9  an interpretable type &quot;MenuList*&quot;  any of the valid front-end menu lists (I won&#39;t list them all here, but they include styles and fonts)  For our function we only need to add a single autocompletion to the first argument, so we&#39;d do that like:      FrontEndExecute@ FrontEnd`Value@ FEPrivate`AddSpecialArgCompletion[ &quot;packageFunction&quot;-&gt;{{&quot;NewStyle&quot;, &quot;OldStyle&quot;}} ];    And now when we type      packageFunction[&quot;    We&#39;ll be prompted to pick one of those choices  There is also a special package level file specialArgFunctions.tr that we can use to hold all these completions, but I tend to set them at load-time instead.    Bad Argument Protection  The final thing we need to configure for our function is the set of fallbacks if incorrect arguments are passed. We&#39;ll start with argument validation. So to our original definition we&#39;ll add one that assumes just the argument types are wrong, but the right number of arguments were passed. We&#39;ll use a template message that gets filled for all the parameters:      packageFunction::invp=&quot;Value `` is invalid for parameter ``. Expected ``&quot;; packageFunction[ style_, cont_, name_, ops:OptionsPattern[] ]:= Module[ { par, val, expect }, Which[ !MatchQ[style, &quot;NewStyle&quot;|&quot;OldStyle&quot;], par=&quot;style&quot;; val=style; expect=&quot;\&quot;NewStyle\&quot; or \&quot;OldStyle\&quot;&quot;, !MatchQ[cont, _String?(StringEndsQ[&quot;`&quot;])], par=&quot;context&quot;; val=cont; expect=&quot;a string ending in `&quot;, !MatchQ[name, _String?(StringMatchQ[LetterCharacter~~WordCharacter..])], par=&quot;name&quot;; val=name; expect=&quot;a string composed of letters and numbers&quot; ]; Null/;Message[packageFunction::invp, val, par, expect] ]    To this we&#39;ll also want one that tells us if the wrong number of arguments was passed. The heart of this will be the function System`Private`ArgumentsWithRules , which checks argument counts and emits a message if incorrect.      packageFunction[ args___ ]:= ( Null/;System`Private`ArgumentsWithRules[packageFunction[args], 3, Hold] )    Now we can test the various cases for our function:  Invalid argument     packageFunction[1, 2, 3]         packageFunction::invp:       Value 1 is invalid for parameter &quot;style&quot;. Expected &quot;\&quot;NewStyle\&quot; or \&quot;OldStyle\&quot;&quot;           (*Out:*) packageFunction[1,2,3]    Too few arguments     packageFunction[&quot;NewStyle&quot;, &quot;ctx`&quot;]         packageFunction::argrx:       packageFunction called with 2 arguments; 3 arguments are expected.           (*Out:*) packageFunction[&quot;NewStyle&quot;,&quot;ctx`&quot;]    Too many arguments     packageFunction[&quot;NewStyle&quot;, &quot;ctx`&quot;, &quot;asd&quot;, 1]         packageFunction::nonopt:       Options expected (instead of 1) beyond position 3 in packageFunction[&quot;NewStyle&quot;,&quot;ctx`&quot;,&quot;asd&quot;,1]. An option must be a rule or a list of rules.           (*Out:*) packageFunction[&quot;NewStyle&quot;,&quot;ctx`&quot;,&quot;asd&quot;,1]    Finally with all this we have a production grade function that our users can easily use. This is a lot of work per function, but that&#39;s in some senses useful, encouraging us to use a small, tight public interface to our package and allowing most of the work to be done by our behind-the-scenes functions. There are also utilities out there to make this process simpler in general.      See Also:    https://mathematica.stackexchange.com/questions/56984/argument-completions-for-user-defined-functions/129910#129910     https://mathematica.stackexchange.com/questions/164007/how-can-i-automatically-generate-all-the-front-end-settings-for-a-function
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/function-preparation.html</guid>
    <pubDate>Wed 18 Jul 2018 14:16:26</pubDate>
  </item>
  <item>
    <title>New-Style Packages</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/newstyle-packages.html</link>
    <description>
        New-Style Packages  As of version 10 or so there is a new package format that may be used to more easily handle complicated package setups. It involves a set of static tokens that one uses to tell the system how to distribute definitions and expose contexts and things. These are:  Package  must be at the top of a package file, tells the system it&#39;s a package and the package name PackageExport  tells the system that a given symbol will be exposed at top level PackageScope  tells the system that a given symbol should be exposed at the package level PackageImport  tells the system to import a given context and expose it within that file  Any symbol not tagged with PackageExport or PackageScope gets a context that is private to that file.  A sample paclet structure might look like:      MyPaclet + PacletInfo.m Kernel + init.m MyPaclet.m Component1.m Component2.m ...     Each component would look like:      Package[&quot;MyPaclet`&quot;] PackageImport[&quot;Dependency1`&quot;] PackageImport[&quot;Dependency2`&quot;] ... PackageExport[&quot;Symbol1&quot;] PackageExport[&quot;Symbol2&quot;] ... PackageScope[&quot;PkgSym1&quot;] PackageScope[&quot;PkgSym2&quot;] ... sym1[]:=... Symbol1[]:=... ...    Note a few interesting features:  There is no Begin or BeginPackage or anything like that The tokens must be declared standalone, without even a ; at the end We don&#39;t explicitly tell the system to load all the componentsit does this automatically  This allows for much simpler package construction and is a good clean strategy for developing packages    Package` Context  Even better, there are tools at hand for analyzing/working with these packages. These are the functions in the &quot;Package`&quot; context. There&#39;ll be a little reference guide on them, but for now here&#39;s a quick rundown of how they work:  PackageInformation  extracts info for new style packages LoadPackage  loads a new style package DeclareLoad  sets up autoloading for a package ActivateLoad  set by DeclareLoad to delegate to LoadPackage CreatePackageCache  generates a .mx redux of a package for optimized loading      See Also:    https://mathematica.stackexchange.com/questions/114956/what-are-package-context-symbols-for     https://mathematica.stackexchange.com/questions/176434/declaring-package-with-dependencies-in-multiples-files/176489#176489     Package context reference
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/newstyle-packages.html</guid>
    <pubDate>Tue 17 Jul 2018 17:19:47</pubDate>
  </item>
  <item>
    <title>Special Paclets</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/special-paclets.html</link>
    <description>
        Special Paclet Formats  Mathematica uses a number of specially constructed paclets to drive some of its frameworks. We&#39;ll briefly talk about these frameworks and how they showcase what paclets can do.      Curated Data  The curated data framework has been in Mathematica since version 6. As I understand it, it is the Ur-usage for paclets. These paclets drive almost all the functions ending in Data , like ChemicalData , ElementData , and ExampleData .  A curated data function is in some sense a paclet is a divided into 3 chunks.  There is a code paclet that looks like:      &lt;DataType&gt;Data + PacletInfo.m Kernel + init.m &lt;DataType&gt;Data.m     which configures a function &lt;DataType&gt;Data that acts as a router to two resource paclets.  The first resource paclet is looks like      &lt;DataType&gt;Data_Index + PacletInfo.m Data + Index.wdx + Functions.wdx + Names.wdx + Groups.wdx + Properties.wdx + PrivateGroups.wdx     And the raw data distributes over a number of paclets that look like      &lt;DataType&gt;Data_Part01 + PacletInfo.m Data + Part01.wdx      ExampleData  The ExampleData system works in a similar way to the bulk curated data, but since it provides more specialized resources it serves them in a slightly different way. Each of its resources looks like:      ExampleData_&lt;DataName&gt; + PacletInfo.m Data + &lt;DataName&gt;.wdx     You can leverage this to make it serve your own resources with a bit of work.      Service Connections  The Service Connections Framework is a good example of the flexibility of the paclet system. It provides a general set of high-level functions ServiceConnect , ServiceExecute , ServiceDisconnect , and low-level infrastructure that allow paclets to provide flexible connections to APIs with little effort.  Every service in the $Services list provides a paclet which looks like:      ServiceConnection_&lt;ServiceName&gt; + PacletInfo.m Kernel + load.m + &lt;ServiceName&gt;.m + &lt;ServiceName&gt;Load.m + &lt;ServiceName&gt;Functions.m     The framework first calls load.m which then loads the other packages. In the end a single set of functions is returned that encapsulates all the API parameters that the service provides.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/higher-level-features/special-paclets.html</guid>
    <pubDate>Tue 17 Jul 2018 15:43:08</pubDate>
  </item>
  <item>
    <title>PacletInfo and Paclet Structure</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/pacletinfo-and-paclet-structure.html</link>
    <description>
        Paclet Structure  We briefly mentioned what a paclet looks like previously, but we didn&#39;t discuss what the different types of paclets will look like and how this will be reflected in the PacletInfo.m file.  First we&#39;ll handle some PacletInfo.m basics then get into more details on how paclet structure is reflected here.    PacletInfo.m  The PacletInfo.m file supplies a Paclet expression that encodes metadata in rules. The absolute simplest example might be:      Paclet[ Name-&gt;&quot;MyPaclet&quot;, Version-&gt;&quot;1.0.0&quot; ]    This simply tells the system there is a paclet named &quot;MyPaclet&quot; that has version &quot;1.0.0&quot; . There are many different parameters we can supply though:  WolframVersion  specifies the minimum version of Mathematica necessary to get the paclet to function properly  This should be a string that looks like &quot;11.0.1+&quot; or &quot;10+&quot; or similar  SystemID  specifies the operating system or systems on which the paclet may be expected to work.  The valid IDs are the valid IDs for $SystemID .  Loading  specifies the loading mode for the paclet  The valid loading modes are Manual (default), Automatic , and &quot;StartUp&quot; . With the &quot;StartUp&quot; mode, the paclet is loaded right after the PacletManager . The Automatic mode will configure autoloading for any symbols that are provided as part of the &quot;Kernel&quot; extension (we&#39;ll get into this later).  There are also a number of useful bits of descriptive metadata that are used by the Installed Add-Ons Guide and other third-party interfaces:  Description  provides a brief description for the paclet Creator  specifies the creator of the paclet  This should generally be a name and an email as one string, e.g. &quot;b3m2a1 &lt;b3m2a1@gmail.com&gt;&quot;  Publisher  specifies the organization publishing the paclet, if relevant Thumbnail  relative path to an icon for the paclet  Other bits of standard data are:  License  the license for the paclet Copyright  the copyright holder of the paclet Support  contact info for support   Extensions  The Paclet expression can also supply an &quot;Extensions&quot; parameter that tells the manager what kinds of things may be done with it. A paclet with extensions will look like:      Paclet[ Name-&gt;&quot;MyPaclet&quot;, Version-&gt;&quot;1.0.0&quot;, Extensions-&gt; { {&quot;Extension1&quot;, &quot;Prop1&quot;-&gt;val1, ...}, {&quot;Extension2&quot;, &quot;Prop1&quot;-&gt;val1, ...}, ... } ]    The different extensions are what allow different types of resources to be served by the PacletManager . We&#39;ll break these down in turn.    Kernel  The first and probably most common extension we&#39;ll want is the &quot;Kernel&quot; extension. If a paclet supplies code, it will want a &quot;Kernel&quot; extension.  It has three main parameters it can take:  &quot;Root&quot;  this is the root off of which the &quot;Kernel&quot; folder should be located. Defaults to &quot;.&quot; . &quot;Context&quot;  this supplies the contexts the paclet can load &quot;Symbols&quot;  this supplies a set of symbols that the paclet provides. If the Loading is set to Automatic , autoloading will be set up for everyone of these symbols.  For a paclet structure that looks like  ```  MyPaclet + PacletInfo.m Kernel + init.m MyPaclet.m SubContext.m ```  We&#39;d write the extension to look like:  ```{ &quot;Kernel&quot;, &quot;Root&quot;-&gt;&quot;.&quot;, &quot;Context&quot;-&gt;{&quot;MyPacle &quot;, &quot;MyPaclet SubContex &quot;, ...} }  ``    FrontEnd  The &quot;FrontEnd&quot; extension tells the PacletManager to make the supplied front-end resources available system-wide. It has a few parameters:  Root  the path to the front-end root directory. Defaults to &quot;FrontEnd&quot; . Prepend  if True the resources are prepended to the lookup path for the FE  We can supply four different types of FE resources, each within a sub-folder of the &quot;FrontEnd&quot; folder:  &quot;StyleSheets&quot;  the folder containing stylesheet notebooks  These notebook will appear in the main menu under Format  Stylesheet . If placed within a sub-folder, they&#39;ll be place in the group with that name in the menu. If nested twice they won&#39;t appear in the menu at all.  &quot;Palettes&quot;  the folder containing palette notebooks  These operate fundamentally the same as the stylesheets with respect to the sub-folders and appearing in the menu.  &quot;TextResources&quot;  the folder containing .tr files that serve resources for FrontEndResource  More info on these text resources can be found here or elsewhere on the Mathematica StackExchange.  &quot;SystemResources&quot;  the folder containing various system resources that may be used by the front-end. There are two subfolders:&quot;Bitmaps&quot;  the sub-folder containing various bitmaps and icons to be served &quot;AutocompletionData&quot;  the sub-folder containing pieces of autocompletion data to be served, especially the specialArgFunctions.tr file or .trie files  Anytime we want front-end resources we provide to be used we should add the extension:      { &quot;FrontEnd&quot;, Prepend-&gt;True }     Documentation  Allows documentation files to be found and searched automatically. It has the following parameters:  &quot;Language&quot;  the target language for the docs (defaults to All ) &quot;Root&quot;  the root path for the docs (defaults to &quot;Documentation&quot; ) &quot;LinkBase&quot;  the path root (e.g. &quot;PacletManager&quot; in &quot;PacletManager/ref/PacletInstall&quot; ) &quot;MainPage&quot;  the default landing page for the paclet  If we want to add English-language documentation to our paclet we&#39;d set up the paclet like:      MyPaclet + PacletInfo.m Documentation English ReferencePages Symbols + MySymbol1.nb + MySymbol2.nb ... Guides + MyPaclet.nb + OtherGuide.nb ... Tutorials + Feature1.nb + Feature2.nb ...    Then our extension would look like:      { &quot;Documentation&quot;, &quot;Language&quot;-&gt;&quot;English&quot;, &quot;LinkBase&quot;-&gt;&quot;MyPaclet&quot;, &quot;MainPage&quot;-&gt;&quot;Guides/MyPaclet&quot; }     Resource  The &quot;Resource&quot; extension may be used multiple times and supplies different resources that can be accessed via PacletResource .  Each resource takes a set of parameters  &quot;Root&quot;  the root from which lookups are done &quot;Resources&quot;  a set of relative paths to the resources &quot;SystemID&quot;  a specific system ID for the resource (defaults to All )  Each elements in the &quot;Resources&quot; should either be the relative path or a list {name, path} where name is a nickname for the resource.  As an example, if we wanted to supply a set of resources we could have our paclet setup like:      MyPaclet + PacletInfo.m Resources + MyResource1.mx SubResources + SubResource1.mx    And then the extension would look like      { &quot;Resource&quot;, &quot;Root&quot;-&gt;&quot;Resources&quot;, &quot;Resources&quot; -&gt; { {&quot;Resource&quot;, &quot;MyResource1.mx&quot;}, {&quot;SubResource&quot;, &quot;SubResources/SubResource1.mx&quot;} } }     JLink  Automatically adds the supplied .jar files to the classpath. Has the following parameters:  &quot;Root&quot;  specifies the root directory (defaults to &quot;Java&quot; ) &quot;WolframVersion&quot;  the versions for which the .jar files are valid &quot;SystemID&quot;  the systems for which the .jar files are valid   LibraryLink  Automatically makes the supplied library files locatable via FindLibrary . Note that FindLibrary will find the file Root/$SystemID . Has the same kind of parameters as &quot;JLink&quot; :  &quot;Root&quot;  specifies the root directory (defaults to &quot;LibraryResources&quot; ) &quot;WolframVersion&quot;  the versions for which the library files are valid &quot;SystemID&quot;  the systems for which the library files are valid   AutoCompletionData  Provides autocompletion data for lookup. Only supplies the &quot;Root&quot; parameter.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/pacletinfo-and-paclet-structure.html</guid>
    <pubDate>Fri 13 Jul 2018 20:19:17</pubDate>
  </item>
  <item>
    <title>Paclet Development</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/paclet-development.html</link>
    <description>
        Paclet Development  Now that we know how a paclet should be structured, we can get into the details of developing a paclet. We&#39;ll make a paclet that has a bit of everything in it to see how it all works.    Directory Structure  Our basic structure will start out looking like      MyPaclet + PacletInfo.m     And the PacletInfo.m will look like:      Paclet[ Name -&gt; &quot;MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;b3m2a1 &lt;b3m2a1@gmail.com&gt;&quot;, Description -&gt; &quot;A sample paclet to show the paclet developement process&quot; ]     Kernel and Main Package  The first thing we&#39;ll need to add to the paclet is a &quot;Kernel&quot; folder and a primary implementation package. For simplicity, we&#39;ll have our paclet provide a context &quot;MyPaclet`&quot; , and so our main package will have to create this context.  We&#39;ll change our structure to look like:      MyPaclet + PacletInfo.m Kernel + init.m MyPaclet.m     And the info will look like:      Paclet[ Name -&gt; &quot;MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;b3m2a1 &lt;b3m2a1@gmail.com&gt;&quot;, Description -&gt; &quot;A sample paclet to show the paclet developement process&quot;, Extensions -&gt; { {&quot;Kernel&quot;, &quot;Root&quot;-&gt;&quot;.&quot;, &quot;Context&quot;-&gt;{&quot;MyPaclet`&quot;}} } ]    Now we&#39;ll need to make the init.m file load MyPaclet.m , but this is no different than the standard way we might do this, e.g. via:      &lt;&lt;MyPaclet`MyPaclet`    Any other packages we provide should then be loaded in turn via MyPaclet.m . We won&#39;t get into the details of how to write a paclet with interacting piceces here, as there are many different ways people like to do this and we&#39;re trying to take a high-level overview, but we will return to that theme later.  After we do this it&#39;s possible to load the paclet with      &lt;&lt;MyPaclet`     FrontEnd Resources  Let&#39;s say we have some front-end resources we&#39;d like to bundle with our paclet:  A stylesheet called MyPacletStyles.nb An icon in MyPacletIconResource.png A helper palette in MyPacletHelper.nb  We&#39;ll add the following folder to our main directory:      FrontEnd StyleSheets MyPaclet + MyPacletStyles.nb Palettes MyPaclet + MyPacletHelper.nb SystemResources Bitmaps MyPaclet + MyPacletIconResource.png     And the info will look like:      Paclet[ Name -&gt; &quot;MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;b3m2a1 &lt;b3m2a1@gmail.com&gt;&quot;, Description -&gt; &quot;A sample paclet to show the paclet developement process&quot;, Extensions -&gt; { {&quot;Kernel&quot;, &quot;Root&quot;-&gt;&quot;.&quot;, &quot;Context&quot;-&gt;{&quot;MyPaclet`&quot;}}, {&quot;FrontEnd&quot;} } ]    We can then link to this stylesheet by setting      StyleDefinitions-&gt;FrontEnd`FileName[{&quot;MyPaclet&quot;}, &quot;MyPacletStyles.nb&quot;]     Or if we want to use the paclet icon we can do so with the appropriate FrontEnd`FileName . This time we&#39;ll want FrontEnd`FileName[{&quot;MyPaclet&quot;}, &quot;MyPacletIconResource.png&quot;] . Here&#39;s an example of this:      RawBoxes@ DynamicBox[ FEPrivate`ImportImage@ FrontEnd`FileName[{&quot;MyPaclet&quot;}, &quot;MyPacletIconResource.png&quot;] ]      Documentation  If we have some documentation pages we have either built with Workbench or any of a number of third-part interfaces ( here&#39;s mine ), we can add these to our package too. Assuming we have the following English-language documentation pages to add:  A symbol page, MyPacletSym.nb A guide, MyPaclet.nb A tutorial, MyPacletOverview.nb  We&#39;ll add the following folder to our directory      Documentation English ReferencePages Symbols + MyPacletSym.nb Guides + MyPaclet.nb Tutorials + MyPacletOverview.nb     And we&#39;ll add the following extension to the paclet info:      { &quot;Documentation&quot;, &quot;Language&quot; -&gt; &quot;English&quot;, &quot;MainPage&quot; -&gt; &quot;Guides/MyPaclet&quot;, &quot;LinkBase&quot; -&gt; &quot;MyPaclet&quot; }    After this is installed, when people search for MyPacletSym the page will appear.    Resources  Finally, let&#39;s say we want to bundle resources with our paclet, maybe we have a template notebook, MyTemplate.nb and a bunch of data stored in .mx files, MyDat1.mx , MyDat2.mx , and MyDat3.mx  We can add the following folder structure:      Resources + MyTemplate.nb Data + MyDat1.mx + MyDat2.mx + MyDat3.mx     And then add the extension:      { &quot;Resource&quot;, &quot;Resources&quot; -&gt; { {&quot;Template&quot;, &quot;MyTemplate.nb&quot;}, {&quot;Data1&quot;, &quot;Data/MyDat1.mx&quot;}, {&quot;Data2&quot;, &quot;Data/MyDat2.mx&quot;}, {&quot;Data3&quot;, &quot;Data/MyDat3.mx&quot;} } }    Now we can use      PacletResource[&quot;MyPaclet&quot;, &quot;Template&quot;]     and we&#39;ll get the file path to the template notebook
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/paclet-development.html</guid>
    <pubDate>Mon 16 Jul 2018 16:42:59</pubDate>
  </item>
  <item>
    <title>Paclet Distribution</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/paclet-distribution.html</link>
    <description>
        Paclet Distribution  We can distribute paclets in either of two ways. We can distribute a packed .paclet file directly or distribute via a server.  Whichever route we go, though, we&#39;ll first need the .paclet file.    Creating a .paclet File  To create a .paclet file we use the PackPaclet function in the &quot;PacletManager`&quot; context. We can call it one of two ways:  PackPaclet[dir]  creates a packed .paclet file from dir and places it in dir PackPaclet[dir, dest]  creates a packed .paclet file from dir and places it in dest  Say, for the sake of argument, that I am Etienne Bernard and write the Machine Learning functionality packaged into Mathematica. I can find my paclet directory like      dir = PacletFind[&quot;MachineLearning&quot;][[1]][&quot;Location&quot;] (*Out:*) &quot;/Applications/Mathematica.app/Contents/SystemFiles/Components/MachineLearning&quot;    Then this can be packed into a .paclet file like:      paclet = PackPaclet[dir, $TemporaryDirectory] (*Out:*) &quot;/private/var/folders/9t/tqc70b7d61v753jkdbjkvd640000gp/T/MachineLearning-1.1.0.paclet&quot;    And now this can be distributed    Direct Distribution  Once a paclet is packed it can be distributed directly as it. For instance, I can put this in on my Wolfram Cloud account:      CopyFile[ paclet, CloudObject[&quot;user:b3m2a1.testing/MachineLearning.paclet&quot;, Permissions-&gt;&quot;Public&quot;] ]//Most (*Out:*) CloudObject[]    And now anyone could come along and install this with:      PacletInstall@ &quot;http://www.wolframcloud.com/objects/b3m2a1.testing/MachineLearning.paclet&quot;    Often we want something a little more sophisticated, though.      Paclet Servers  Paclet servers exist to make it easy to serve many paclets from the same location. The PacletManager indexes all the paclet servers available to it and figures out where to install paclets from if simply provided with a name. Therefore it&#39;s useful for us to be able to set up our own servers.  To do this we simply need to add a Paclets directory to our server and provide a compressed metadata file PacletSite.mz . Overall our server will look like:      Server PacletSite.mz Paclets Paclet1-version1.paclet Paclet1-version2.paclet Paclet2-version1.paclet ...      PacletSite.mz  The paclet manager indexes the paclets on the server by looking at PacletSite.mz , which is much like a PacletInfo.m file, except instead of containing a single Paclet expression it contains a PacletSite expression that bundles up a bunch of different Paclet expressions.  In all it&#39;ll look like:      PacletSite[ Paclet[ Name-&gt;&quot;MyPaclet1&quot;, ... ], Paclet[ Name-&gt;&quot;MyPaclet2&quot;, ... ], ... ]    Then this gets written to a file as an expression and ZIP compressed.  In general we don&#39;t need to handle this ourselves, though, as there&#39;s a function in the PacletManager that does this. If we call PacletManager`Package`BuildPacletSiteFiles on our target directory it will do this for us.  For instance, I could call:      PacletManager`Package`BuildPacletSiteFiles@ ExpandFileName@&quot;~/Documents/GitHub/GitHubServer&quot;    And all of the files in the Paclets sub-folder will get indexed into a PacletSite.m and PacletSite.mz file.    Setting Up a Paclet Server  Once the construction is done locally, the server should be served over HTTP if possible. Older versions of the PacletManager failed to deal appropriately with HTTPS content.  I tend to serve mine via the Wolfram Cloud or GitHub.  An example of the former is here and the latter is here .      See Also:    https://mathematica.stackexchange.com/questions/131101/how-to-distribute-mathematica-packages-as-paclets
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/paclet-distribution.html</guid>
    <pubDate>Tue 17 Jul 2018 13:11:45</pubDate>
  </item>
  <item>
    <title>Tips and Tricks</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/tips-and-tricks.html</link>
    <description>
        Paclet Directories  When developing a paclet it can be useful to be able to test code without having to uninstall and reinstall the paclet. That&#39;s why there&#39;s a PacletDirectory* mechanism that makes this easier. We can use the function PacletDirectoryAdd to add another directory in which paclets will be looked for. When we&#39;re done with this we can use PacletDirectoryRemove to clear the directory and test what development looks like without the code being directly accessible.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/tips-and-tricks.html</guid>
    <pubDate>Mon 16 Jul 2018 17:58:10</pubDate>
  </item>
  <item>
    <title>Sample Paclet Structures</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/sample-paclet-structures.html</link>
    <description>
        Sample Paclets  It can be unclear what type of directory/paclet info structure we want, so we&#39;ll go over a number of the different common types.  Keep in mind that you can always mix-and-match with these template structures. I&#39;m just showing how a pure, modularized paclet of each type can be constructed.    Code Paclet  The most common type of paclet is one that just serves code and maybe some front-end/system resources. To get this type of paclet up-and-running we&#39;ll take our directory structure to look something like:      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m ... + MyPaclet.m     And the PacletInfo.m will be     Paclet[ Name -&gt; &quot;MyPaclet&quot;, Version -&gt; &quot;1.0.0&quot;, Creator -&gt; &quot;me &lt;me@me.me&gt;&quot;, Description -&gt; &quot;A world-changing application&quot;, Extensions -&gt;{ {&quot;Kernel&quot;, &quot;Root&quot;-&gt;&quot;.&quot;, &quot;Context&quot;-&gt;{&quot;MyPaclet`&quot;}} } ]     Documentation Paclet  Sometimes we just want to distribute documentation, as it can be bulky and unwieldy. If this is the case, we&#39;ll want to use a directory structure that looks like:  The most common type of paclet is one that just serves code and maybe some front-end/system resources. To get this type of paclet up-and-running we&#39;ll take our directory structure to look something like:      Documentation_MyPaclet + PacletInfo.m Documentation English ReferencePages Symbols + SymbolPage1.nb + SymbolPage2.nb ... Guides + MyPaclet.nb + Guide1.nb ... Tutorials + Tutorial1.nb + Tutorial2.nb ...     And the PacletInfo.m will be     Paclet[ Name -&gt; &quot;Documentation_MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;me &lt;me@me.me&gt;&quot;, Description -&gt; &quot;Documentation for MyPaclet&quot;, Extensions -&gt;{ { &quot;Documentation&quot;, &quot;Root&quot;-&gt;&quot;.&quot;, &quot;LinkBase&quot;-&gt;&quot;MyPaclet&quot;, &quot;MainPage&quot;-&gt;&quot;Guides/MyPaclet&quot; } } ]    We use a small version number that won&#39;t conflict with the main MyPaclet ever    FrontEnd Paclet  Sometimes we want to package versioned FE resources separately from a package, or simply pass around standalone palettes and stylesheets. If this is the case we want a front-end paclet, which has a directory structure like:      FrontEnd_MyPaclet + PacletInfo.m FrontEnd StyleSheets MyPaclet + StyleSheet1.nb ... Palettes MyPaclet + Palettes.nb ... SystemResources MyPaclet + SystemResource1.nb + SystemResource2.txt + SystemResource3.png ... Bitmaps MyPaclet + Bitmap1.png + Bitmap2.png ... TextResources MyPaclet + TextResource1.tr + TextResource2.tr ...     And we&#39;d have a pretty simple PacletInfo.m     Paclet[ Name -&gt; &quot;FrontEnd_MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;me &lt;me@me.me&gt;&quot;, Description -&gt; &quot;FrontEnd resources for MyPaclet&quot;, Extensions -&gt;{ {&quot;FrontEnd&quot;} } ]     Resource Paclet  Sometimes we want to package versioned FE resources separately from a package, or simply pass around standalone palettes and stylesheets. If this is the case we want a front-end paclet, which has a directory structure like:      Resources_MyPaclet + PacletInfo.m Resources + Resource1.mx Templates + Template1.nb + Template2.nb ... ...    And we&#39;ll have a PacletInfo.m that looks like:      Paclet[ Name -&gt; &quot;Resources_MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;me &lt;me@me.me&gt;&quot;, Description -&gt; &quot;Basic resources for MyPaclet&quot;, Extensions -&gt;{ { &quot;Resource&quot;, &quot;Root&quot;-&gt;&quot;Resources&quot;, &quot;Resources&quot;-&gt; { {&quot;Resource1&quot;, &quot;Resource1.mx&quot;}, {&quot;Template1&quot;, &quot;Templates/Template1.mx&quot;}, {&quot;Template2&quot;, &quot;Templates/Template2.mx&quot;} } } } ]     Data Paclet  Before its curated data system got wrapped into the Entity Framework , Mathematica distributed its curated data via the DataPaclets system. These are resource paclets that simply distribute version controlled data.  We can still make use of this system ourselves, though, as done here . Even if we don&#39;t want to hook into that system directly, we can make use of this kind of setup by setting up a directory like:      Data_MyPaclet + PacletInfo.m Data + MyPacletData.wdx + MyPacletHDF5Data.h5 ...     Then the PacletInfo.m looks almost exactly like a resource paclet      Paclet[ Name -&gt; &quot;Data_MyPaclet&quot;, Version -&gt; &quot;0.0.1&quot;, Creator -&gt; &quot;me &lt;me@me.me&gt;&quot;, Description -&gt; &quot;Data for MyPaclet&quot;, Extensions -&gt;{ { &quot;Resource&quot;, &quot;Root&quot;-&gt;&quot;Data&quot;, &quot;Resources&quot;-&gt; { {&quot;Data&quot;, &quot;MyPacletData.wdx&quot;}, {&quot;HDF5Data&quot;, &quot;MyPacletHDF5Data.h5&quot;}, ... } } } ]
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-development/sample-paclet-structures.html</guid>
    <pubDate>Tue 17 Jul 2018 02:56:49</pubDate>
  </item>
  <item>
    <title>Installation</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-usage/installation.html</link>
    <description>
        Paclets  As we discussed previously, paclets provide a way to distribute code, resources, and other things in Mathematica. They are the native format for this type of distribution and are tightly bound into the system.  Paclets can provide any or all of the following:  Code Resources Style Sheets Palettes Documentation  In general the most common thing we&#39;ll want to provide is code, but the others are common things to distribute as well.  We&#39;ll talk briefly about how to install and work with these paclets. Everything in this section requires the &quot;PacletManager`&quot; context, so, if you have to, run:      Needs[&quot;PacletManager`&quot;]      Installation  As the paclet system is tightly bound into Mathematica, installation is very easy via the PacletInstall function.  We can use it in a few ways:  PacletInstall[fileOrURL]  installs a .paclet file at the given path PacletInstall[name]  looks for and installs the paclet named name PacletInstall[{name, version}]  looks for and installs the paclet named name with version number version  We can also pass a few options to PacletInstall . The main ones are:  &quot;Site&quot;  provides a server to look for the paclet on &quot;IgnoreVersion&quot;  installs the paclet even if a different version has already been installed  If we pass a &quot;Site&quot; it should be the path to a &quot;paclet server&quot;, which we&#39;ll talk about more later.  Here&#39;s an example of this:      PacletInstall[&quot;ChemTools&quot;, &quot;Site&quot;-&gt;&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot; ] (*Out:*)       Once we do this we can load the package with:      &lt;&lt;ChemTools`      Finding Paclets / Paclet Information  We can use the PacletFind and PacletInformation functions to find the installed paclet and get information about a paclet. We can call PacletFind in a few ways:  PacletFind[name]  finds the installed paclet name PacletFind[{name, version}]  finds the installed paclet name with version number version  PacletFind can take a number of filters as Options :  &quot;Location&quot;  where to search for the paclets &quot;Qualifier&quot;  search for paclets with a given qualifier &quot;SystemID&quot;  search for paclets stated to work on a given system &quot;WolframVersion&quot;  search for paclets targeted for a given Mathematica version or verions &quot;Enabled&quot;  search for paclets that are enabled &quot;Loading&quot;  search for paclets with a given loading mode &quot;Creator&quot;  search for paclets created by a specific person/persons &quot;Publisher&quot;  search for paclets published by a given entity &quot;Internal&quot;  search for internal paclets &quot;IncludeDocPaclets&quot;  allow paclets that only server system-level documentation to be included &quot;Context&quot;  search for paclets that serve a given context &quot;Extension&quot;  search for paclets that serve a given extension  Here&#39;s a way to use this. We&#39;ll make use of the fact that PacletFind will expand the &quot;*&quot; wildcard to find every paclet ending in &quot;Link&quot; which also provide the &quot;LibraryLink&quot; extension and which work in Mathematica 11.0.1 or before:      PacletFind[&quot;*Link&quot;, &quot;Extension&quot;-&gt;&quot;LibraryLink&quot;, &quot;WolframVersion&quot;-&gt;&quot;11.0.1&quot;] (*Out:*)       We can then find information about these paclets with PacletInformation . This can be called in a few ways:  PacletInformation[paclet]  returns information about the Paclet expression paclet PacletInformation[name]  returns information about the first paclet found via PacletFind[name]     PacletInformation[&quot;DAALLink&quot;] (*Out:*) { &quot;Name&quot;-&gt;&quot;DAALLink&quot;, &quot;Version&quot;-&gt;&quot;1.0&quot;, &quot;BuildNumber&quot;-&gt;&quot;&quot;, &quot;Qualifier&quot;-&gt;&quot;&quot;, &quot;WolframVersion&quot;-&gt;&quot;11.0+&quot;, &quot;SystemID&quot;-&gt;All, &quot;Description&quot;-&gt;&quot;Link to the Intel DAAL Library&quot;, &quot;Category&quot;-&gt;&quot;&quot;, &quot;Creator&quot;-&gt;&quot;Sebastian Bodenstein &lt;sebastianb@wolfram.com&gt;&quot;, &quot;Publisher&quot;-&gt;&quot;&quot;, &quot;Support&quot;-&gt;&quot;&quot;, &quot;Internal&quot;-&gt;False, &quot;Location&quot;-&gt;&quot;/Applications/Mathematica.app/Contents/SystemFiles/Links/DAALLink&quot;, &quot;Context&quot;-&gt;{&quot;DAALLink`&quot;}, &quot;Enabled&quot;-&gt;True, &quot;Loading&quot;-&gt;Automatic }     Removal  If we have a paclet installed, but want to remove it, we can do so with PacletUninstall . This can be called either on a Paclet or with a name that works for PacletFind .
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-usage/installation.html</guid>
    <pubDate>Fri 13 Jul 2018 20:20:28</pubDate>
  </item>
  <item>
    <title>Paclet Servers</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-usage/paclet-servers.html</link>
    <description>
        Paclet Servers  We talked about the basic paclet installation process before, but one place where paclets are very useful is when setup to be distributed on a server.  Wolfram Research has a main paclet server it distributes its paclets from, but users can also create their own servers. As an example of this, some members of the Mathematica StackExchange have built a custom public paclet server that serves paclets developed by members of the community.    PacletSites  The PacletManager keeps track of the active set of servers via its PacletSites system. We can see the currently configured set:      PacletSites[] (*Out:*) {PacletSite[&quot;http://pacletserver.wolfram.com&quot;,&quot;Wolfram Research Paclet Server&quot;,&quot;Local&quot;-&gt;False]}    We can add a server via PacletSiteAdd :      PacletSiteAdd[ &quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;, &quot;Public paclet server&quot; ] (*Out:*) PacletSite[&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;,&quot;Public paclet server&quot;,&quot;Local&quot;-&gt;False]    This is now permanently added to the PacletSites :      PacletSites[] (*Out:*) {PacletSite[&quot;http://pacletserver.wolfram.com&quot;,&quot;Wolfram Research Paclet Server&quot;,&quot;Local&quot;-&gt;False],PacletSite[&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;,&quot;Public paclet server&quot;,&quot;Local&quot;-&gt;False]}    If we want to check for updates on our sites we can use PacletSiteUpdate to do so:      PacletSiteUpdate[&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;] (*Out:*) PacletSite[&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;,&quot;Public paclet server&quot;,&quot;Local&quot;-&gt;False]    Finally, if we want to remove this we can do so with PacletSiteRemove :      PacletSiteRemove[&quot;http://raw.githubusercontent.com/paclets/PacletServer/master&quot;] (*Out:*) {PacletSite[&quot;http://pacletserver.wolfram.com&quot;,&quot;Wolfram Research Paclet Server&quot;,&quot;Local&quot;-&gt;False]}     Finding Paclets on a Server  We can find paclets located on a server with PacletFindRemote . First we&#39;ll add a different paclet server:      PacletSiteAdd[&quot;http://www.wolframcloud.com/objects/b3m2a1.paclets/PacletServer&quot;]; PacletSiteUpdate[&quot;http://www.wolframcloud.com/objects/b3m2a1.paclets/PacletServer&quot;];     Now we&#39;ll look for a version of the &quot;BTools&quot; package on that server      PacletFindRemote[{&quot;BTools&quot;, &quot;2.1.25&quot;}] (*Out:*)       Now that we&#39;re done with this we can remove it again:      PacletSiteRemove[&quot;http://www.wolframcloud.com/objects/b3m2a1.paclets/PacletServer&quot;];     Installing Paclets off A Server  If a paclet server has been added, it&#39;s easy to install paclets off of it, as PacletInstall will do this by default. If not, we can always pass the site in the &quot;Site&quot; option to it.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/package-usage-and-development/paclet-usage/paclet-servers.html</guid>
    <pubDate>Fri 13 Jul 2018 20:20:51</pubDate>
  </item>
  <item>
    <title>Overview</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/overview.html</link>
    <description>
        Undocumented Functions  Mathematica is a sprawling system and WRI loves to brag about the number of functions in it. Unfortunately it also often under-performs due to this sprawl. Targeted, highly-specialized functions get buried deep in the system, while the most general form of the function exists at the &quot;System`&quot; level.  Therefore, a lot of using Mathematica well comes from taking advantage of the nominally undocumented, unsupported parts of the system.  To make this easier, I&#39;ve attempted to compile lists of useful undocumented functionality, separated by context.      See Also:    https://mathematica.stackexchange.com/questions/805/what-are-some-useful-undocumented-mathematica-functions
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/overview.html</guid>
    <pubDate>Tue 17 Jul 2018 13:10:09</pubDate>
  </item>
  <item>
    <title>Internal</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/internal.html</link>
    <description>
        Internal  The &quot;Internal`&quot; context is one of the core contexts that Mathematica uses. It&#39;s got no targeted focus, but rather appears to be a place where developers dump the cruft they don&#39;t know what to do with.    Bag  Provides a general purpose container that has efficient push and pop behavior. Especially useful in Compile .  See here   StuffBag  Used with Internal`Bag  See here   BagPart  Used with Internal`Bag  See here   WithLocalSettings  Allows for a setup block that will be evaluated before a code block and a tear-down block that will evaluate no matter what errors are raised in the code block . This is highly-useful for error handling.  The function GeneralUtilities`SetupTeardown provides a mild generalization on this.  See here or here   InheritedBlock  Allows for definitions to be preserved, but otherwise uses Block semantics. Very useful for metaprogramming and overloading.  See here   WithTimestampsPreserved  This is a tricky function that tells the kernel to preserve some amount of old-state for efficiency/control reasons.  See here   LoadingPanel  This just makes a nicely formatted panel with a 9-patch Appearance argument:      Internal`LoadingPanel@&quot;Hello World&quot; (*Out:*)        Handlers  A system of internal handlers for various events that occur. Generally best used with Internal`HandlerBlock .  See here   HandlerBlock  This acts in much the same way to the handlers, but can treat them in a Block -like fashion.    LocalizedBlock  Like Block but can localize some non- Symbol arguments.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/internal.html</guid>
    <pubDate>Tue 17 Jul 2018 01:41:09</pubDate>
  </item>
  <item>
    <title>FrontEnd</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/frontend.html</link>
    <description>
        Front End Programming  The Mathematica front-end is almost as complex as the Mathematica kernel, but much worse understood. There are a number of contexts which implement different functionality that it uses.      FrontEnd  The &quot;FrontEnd`&quot; context supplies things like &quot;front-end packets&quot; which tell the front-end to do things.  There is a decent listing of these with usages here .      FE  The &quot;FE`&quot; context provides utilities used by the front-end    makePlainText   Evaluate      FEPrivate  The &quot;FEPrivate`&quot; context supplies a mini-language that the front-end understands. Here are some of it&#39;s useful structures.  The language itself is much more rigid and inflexible, given that it&#39;s closer to a DSL than a standard language.    If   Part   FrontEndResource   ImportImage      See Also:    https://mathematica.stackexchange.com/questions/13451/what-is-the-complete-list-of-valid-frontend-packet-types
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/frontend.html</guid>
    <pubDate>Tue 17 Jul 2018 13:18:39</pubDate>
  </item>
  <item>
    <title>System`*`</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/system-%2A.html</link>
    <description>
        Syste *  The &quot;System`*`&quot; contexts provide similar functionality to the &quot;Internal`*`&quot; context in terms of low-level usage.  There are a huge number of these contexts, so we&#39;ll just focus on a few of them.      Syste Private   SetNoEntry  This is a special function that tags an expression as being treated as atomic (i.e. it cannot be &quot;entered&quot; by Part )  See here   NoEntryQ  This tests whether an expression has had SetNoEntry called on it    EntryQ  Opposite of NoEntryQ   HoldSetNoEntry  SetNoEntry but with held argument    HoldEntryQ  EntryQ but with held argument    ConstructNoEntry  Constructs an atomic object, rather than having this set after the fact    Arguments  Collects the arguments to an expression and checks that the number of them is within an expected range. It holds its first argument.  Single Number     System`Private`Arguments[test[1, 2, 3], 3] (*Out:*) {{1,2,3},{}}    Variable Number     System`Private`Arguments[test[1, 2], {2, 3}] (*Out:*) {{1,2},{}}    Different Head     System`Private`Arguments[test[1, 2, 3], 3, Hold] (*Out:*) {Hold[1,2,3],Hold[]}    With Options     Options[test]={&quot;Option1&quot;-&gt;1, &quot;Option2&quot;-&gt;2}; System`Private`Arguments[test[1, 2, 3, &quot;Option1&quot;-&gt;2], 3, Hold] (*Out:*) {Hold[1,2,3],Hold[&quot;Option1&quot;-&gt;2]}    Bad option     Options[test]={&quot;Option1&quot;-&gt;1, &quot;Option2&quot;-&gt;2}; System`Private`Arguments[test[1, 2, 3, &quot;Option&quot;-&gt;2], 3, Hold]      test::optx:   Unknown option &quot;Option&quot; in test[1,2,3,&quot;Option&quot;-&gt;2].       (*Out:*) {}    Incorrect Number     System`Private`Arguments[test[1, 2, 3], 5]      test::argrx:   test called with 3 arguments; 5 arguments are expected.       (*Out:*) {}     ArgumentsWithRules  Like Arguments but reports that it expects to have options if too many non-option arguments are passed:      System`Private`ArgumentsWithRules[test[1, 2, 3, 4, &quot;Option1&quot;-&gt;4], 3]      test::nonopt:   Options expected (instead of 4) beyond position 3 in test[1,2,3,4,&quot;Option1&quot;-&gt;4]. An option must be a rule or a list of rules.       (*Out:*) {}        Syste Utilities  These tend to be a bit more developer oriented than many of the &quot;System`Private`&quot; functions and a bit higher-level.    SymbolList  Extracts the list of symbols in an expression. Doesn&#39;t hold its argument.  All symbols     System`Utilities`SymbolList[a[b[c[d]]]] (*Out:*) {d,b,a,c}    Wrapped in a Head     System`Utilities`SymbolList[a[b[c[d]]], Hold] (*Out:*) {Hold[d],Hold[b],Hold[a],Hold[c]}    Ignored contexts     System`Utilities`SymbolList[Hold@Print@Hold@Print@a[b[c[d]]], Hold, {&quot;System`&quot;}] (*Out:*) {Hold[d],Hold[b],Hold[a],Hold[c]}     HashTable  Makes a new HashTable object. Less useful since version 10 with the introduction of Association .  See here   HashTableAdd   HashTableGet   HashTableRemove  Bits of the HashTable API
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/system-%2A.html</guid>
    <pubDate>Tue 17 Jul 2018 15:12:42</pubDate>
  </item>
  <item>
    <title>Language</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/language.html</link>
    <description>
        Language  The &quot;Language`&quot; context is a relatively new addition. We won&#39;t get into it too much since it&#39;s already well handled here      See Also:    https://mathematica.stackexchange.com/questions/165843/language-documentation-project     https://mathematica.stackexchange.com/questions/152823/what-can-the-mutationhandler-functions-do     https://mathematica.stackexchange.com/questions/52414/error-changing-dataset-using-part
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/language.html</guid>
    <pubDate>Tue 17 Jul 2018 15:14:58</pubDate>
  </item>
  <item>
    <title>GeneralUtilities</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/generalutilities.html</link>
    <description>
        GeneralUtilities  The &quot;GeneralUtilities`&quot; context is new as of version 10. It provides a wide arrary of useful functionality, of which I only know a small part.    PrintDefinitions   PrintDefinitionsLocal   WithMessageHandler   ThrowFailure   ToMessage
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/generalutilities.html</guid>
    <pubDate>Tue 17 Jul 2018 15:18:28</pubDate>
  </item>
  <item>
    <title>Package</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/package.html</link>
    <description>
        Package  The &quot;Package`&quot; context drives the new-style package system. It&#39;s functions are:    DeclarePackage  Declares a package to be loaded by the autoload mechanism. It&#39;s called like      Package`DeclareLoad[ {syms...}, context, ops ]    Where it takes as options  HiddenImport  whether or not to expose the context after loading ( False by default) Path  the path to use when finding the context file HiddenContexts  apparently unused? ExportedContexts  apparently unused?  Here&#39; an example with the &quot;Macros`&quot; package:      Package`DeclareLoad[ { &quot;Macros`SetArgumentCount&quot;, &quot;Macros`$FailRHS&quot; }, &quot;Macros`&quot;, Package`HiddenImport-&gt;True ]    Then the autoloading was configured on all these packages:      Macros`SetArgumentCount//OwnValues (*Out:*) {HoldPattern[Macros`SetArgumentCount]:&gt;Package`ActivateLoad[Macros`SetArgumentCount,{Macros`$FailRHS,Macros`SetArgumentCount},&quot;Macros`&quot;,{Package`HiddenImport-&gt;True,Path-&gt;Automatic}]}    But if we let the autoloader work the OwnValues are cleared:      Macros`SetArgumentCount Macros`SetArgumentCount//OwnValues (*Out:*) {}     ActivateLoad  Used by DeclaredLoad to auto-load the package. Called like      Package`ActivateLoad[sym, {pkgSyms...}, context, ops ]    As options it takes  HiddenImport  whether or not to expose the context after loading ( False by default) Path  the path to use when finding the context file   PackageInformation  Extracts package info for a package declared in this new style:      Package`PackageInformation[&quot;NumericArrayUtilities`&quot;]//Keys (*Out:*) {&quot;PackageExports&quot;,&quot;PackageFragments&quot;}    If a package hasn&#39;t been loaded it throws an error:      Package`PackageInformation[&quot;CacheManager`&quot;]      Package`PackageInformation::nonpack:   -- Message text not found -- (&quot;CacheManager`&quot;)    This can be quieted by setting Package`ForceLoad to False :      Package`PackageInformation[&quot;CacheManager`&quot;, Package`ForceLoad-&gt;False]    If the package is loaded it works again:      Block[{$ContextPath={&quot;System`&quot;}}, &lt;&lt;CacheManager`]; Package`PackageInformation[ &quot;CacheManager`&quot;, Package`ForceLoad-&gt;False ]~Lookup~&quot;PackageExports&quot; (*Out:*) HoldComplete[CacheManager`CacheData,CacheManager`$DefaultCacheMethod,CacheManager`$DefaultCacheSize,CacheManager`CacheSize,CacheManager`CacheSymbolQ,CacheManager`$Caches,CacheManager`GetCache,CacheManager`CreateCache,CacheManager`RemoveCache,CacheManager`CacheGet,CacheManager`CacheSet,CacheManager`CacheUnset,CacheManager`CacheKeys,CacheManager`iKeys,CacheManager`CacheInformation,CacheManager`makeCacheSymbol,CacheManager`makeCacheFile,CacheManager`CacheDirectory,$CacheBaseDirectory,CacheManager`$FlushInterval,CacheManager`$AllowAutoFlushing,CacheManager`CacheDirtyQ,CacheManager`CacheDirtiness,CacheManager`FlushCacheDeferred,CacheManager`FlushDirtyCaches,CacheManager`FlushCache,CacheManager`SpillCache,CacheManager`CachedExpression,CacheManager`CachedFunction,CacheManager`CachedMap]     LoadPackage  Not entirely clear how this works. Ought to do the actual work of loading the package, but can&#39;t figure out what actually changes after using it.    CreatePackageCache  Creates a .mx cache of a package for optimized loading, but I can&#39;t remember how exactly this works. Is prone to crashing kernels without a destination directory or throwing cascades of errors.      See Also:    https://mathematica.stackexchange.com/questions/114956/what-are-package-context-symbols-for
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/reference-guides/undocumented-contexts/package.html</guid>
    <pubDate>Tue 17 Jul 2018 17:10:04</pubDate>
  </item>
  <item>
    <title>Types</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/types.html</link>
    <description>
        Types  Mathematica has 2 basic types of things in it:  Numbers Words  It also has 2 basic ways to have multiple values together  Lists Key-Value Sets   Numbers  A number is simply any number you&#39;d like, for example:      1 (*Out:*) 1    It can be real:      2.1232 (*Out:*) 2.1232`       -1.33 (*Out:*) -1.33`    Irrational (You can access special characters by pressing  typing a shortcut and pressing  again)       E I (*Out:*)  (*Out:*) E (*Out:*) I    Just as mathematicians distinguish between integers, real numbers, and complex numbers, so does Mathematica.  In general it is good practice to assume that if you can find a mathematical term on Wikipedia, you can find it in Mathematica, although its name may be a bit tough to discover.    Words  A word is a string of letters or other characters enclosed in double quotes. Because it&#39;s a string of characters this type is called String .  For instance, we can have a single character:      &quot;a&quot; (*Out:*) &quot;a&quot;    Or a sequence of them:      &quot;abcdefg&quot; (*Out:*) &quot;abcdefg&quot;    We can include punctuation:      &quot;Hi Mom!&quot; (*Out:*) &quot;Hi Mom!&quot;    And non-standard characters:      &quot; is my favorite irrational number&quot; (*Out:*) &quot; is my favorite irrational number&quot;    Mathematica has a built-in set of characters:      &quot;&quot; (*Out:*) &quot;&quot;    Finally, a String can be of any length:      &quot;When in the Course of human events, it becomes necessary for one people to dissolve the political bands which have connected them with another, and to assume, among the Powers of the earth, the separate and equal station to which the Laws of Nature and of Nature&#39;s God entitle them, a decent respect to the opinions of mankind requires that they should declare the causes which impel them to the separation. - Winston Churchill (1984)&quot; (*Out:*) &quot;When in the Course of human events, it becomes necessary for one people to dissolve the \npolitical bands which have connected them with another, and to assume, among the Powers of the \nearth, the separate and equal station to which the Laws of Nature and of Nature&#39;s God entitle \nthem, a decent respect to the opinions of mankind requires that they should declare the causes \nwhich impel them to the separation.\n\n - Winston Churchill (1984)&quot;     Lists  A List is an ordered collection of any type of thing enclosed in curly brackets, for example:      {1, 2, 3} (*Out:*) {1,2,3}    A List of String :      {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} (*Out:*) {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}    A mixed-type list:      {1, 2, {1, 2, 3}, {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, 10, 11, 12 } (*Out:*) {1,2,{1,2,3},{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;},10,11,12}    We get values from lists using the Part function, which can be typed as [[ ]] , for example:      {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}[[1]] (*Out:*) &quot;a&quot;    We can also count from the end using negative indices      {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}[[-1]] (*Out:*) &quot;c&quot;     Key-Value Sets  A key value set is a collection of key-&gt;value pairs enclosed in &lt;| |&gt;  These are useful for associating things by key rather than having to find them by positions, because it&#39;s associating keys and values this type is called Association , for example      &lt;|1-&gt;&quot;a&quot;, 2-&gt;&quot;b&quot;, 3-&gt;&quot;c&quot;|&gt; (*Out:*) &lt;|1-&gt;&quot;a&quot;,2-&gt;&quot;b&quot;,3-&gt;&quot;c&quot;|&gt;    We get values using the Lookup function, which can be typed using [ ] , for example      &lt;|1-&gt;&quot;a&quot;, 2-&gt;&quot;b&quot;, 3-&gt;&quot;c&quot;|&gt;[1] (*Out:*) &quot;a&quot;        See Also:    Getting Started
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/types.html</guid>
    <pubDate>Wed 18 Jul 2018 21:32:46</pubDate>
  </item>
  <item>
    <title>Variables</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/variables.html</link>
    <description>
        Variables   Set  Variables in Mathematica are simple. Just type a name and give it a value with the equals sign ( = ).  Here we&#39;ll set the variable thisIsAVariable     thisIsAVariable=10 (*Out:*) 10    We can suppress the output by ending the line with a semicolon     thisIsAVariable=10;    (for those interested, the semi colon denotes that this is a CompoundExpression where the return value is Null )    SetDelayed  A variable can also have a &quot;delayed&quot; value. That is, its value is calculated when requested. Here we&#39;ll set the variable randomValuedVariable .  Use colon-equals ( := ) to do this.      randomValuedVariable:=RandomReal[];    When we ask for its value, the return value will change every time.      randomValuedVariable (*Out:*) 0.12257688426972924` randomValuedVariable (*Out:*) 0.13807713447085046`     Clear  The value of a variable can be removed via Clear     Clear[randomValuedVariable]    The variable now has no value      randomValuedVariable (*Out:*) randomValuedVariable     Simple expressions  We can use variables in expressions to store values for us.  For example, let&#39;s do a simple ideal gas law computation for the volume occupied by 2 mols of ideal gas at one atmosphere of pressure and 273 K.  We&#39;ll use Mathematica&#39;s built in constant data to get the value R in L atm / mol K.      R$gasConstant= QuantityMagnitude[ UnitConvert[Quantity[&quot;MolarGasConstant&quot;], &quot;Liters&quot;*&quot;Atmospheres&quot;/(&quot;Moles&quot;*&quot;Kelvins&quot;)] ] (*Out:*) 0.0820573382679496654`5.937562804821409    Then we can set up our constants:      n$quantityOfGas=2 (*mols*); P$externalPressure=1(*atm*); T$temperatureOfGas=273 (*K*);    And finally calculate our volume:      V$volumeOccupied=n$quantityOfGas*R$gasConstant*T$temperatureOfGas/P$externalPressure (*Out:*) 44.8033066943005173068`5.937562804821409
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/variables.html</guid>
    <pubDate>Fri 13 Jul 2018 20:25:16</pubDate>
  </item>
  <item>
    <title>Functions</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/functions.html</link>
    <description>
        Functions  Functions are common to all programming languages. They work exactly like the name suggests. A single input or set of inputs is mapped to a single output.  In Mathematica, functions are defined using variables followed by an underscore square brackets and can be defined with either = or := , which has the same meaning as with variables.  = uses the immediate values of the right hand side while := recalculates these when called for.  The := definition works most similarly to standard programming languages and is the definition I would suggest using by default  Here we&#39;ll define a simple function to add two primes using :=     primeSum[n1_,n2_]:=Prime[n1]+Prime[n2] primeSum[1,10] (*Out:*) 31    The same works with plain =     primeSum[n1_,n2_]=Prime[n1]+Prime[n2]; primeSum[1,10] (*Out:*) 31     Differences between = and :=  Let&#39;s write a more complex function that moves a position around randomly. This position could be the position of an atom, say as hydrogen. Let&#39;s start it out at the origin.      hydrogenPosition={0,0,0};    Now we&#39;ll define a function to move our hydrogen around randomly and return where it is now.      moveOurH[]:= Row@{ &quot;H is at:&quot;, hydrogenPosition+= { RandomReal[{-1,1}], RandomReal[{-1,1}], RandomReal[{-1,1}] } } moveOurH[] (*Out:*) Row[{&quot;H is at:&quot;, {-0.839815, 0.504928, -0.876682}}]    We can move it again and again, and it&#39;ll randomly walk around:      moveOurH[] moveOurH[] moveOurH[] (*Out:*) Row[{&quot;H is at:&quot;, {-0.523173, -0.378415, -0.278032}}] (*Out:*) Row[{&quot;H is at:&quot;, {-0.464874, 0.338277, -0.101727}}] (*Out:*) Row[{&quot;H is at:&quot;, {-0.973597, 0.327556, -0.682705}}]    Now let&#39;s try to do the same, but using =     hydrogenPosition={0,0,0}; moveOurH[]= Row@{ &quot;H is at:&quot;, hydrogenPosition+= { RandomReal[{-1,1}], RandomReal[{-1,1}], RandomReal[{-1,1}] } }; moveOurH[] moveOurH[] moveOurH[] (*Out:*) Row[{&quot;H is at:&quot;, {-0.939441, 0.210649, -0.231079}}] (*Out:*) Row[{&quot;H is at:&quot;, {-0.939441, 0.210649, -0.231079}}] (*Out:*) Row[{&quot;H is at:&quot;, {-0.939441, 0.210649, -0.231079}}]    You&#39;ll notice our position doesn&#39;t change. That&#39;s because the right hand side was evaluated as the function was defined.  Note that this is not always a bug. Sometimes this can be a feature as there are instances where having most values set is useful.    Function  There is also a special object called a Function which is defined as follows:      Function[{var1,var2,var3,...,varn}, code]    This is useful primarily in complicated code when a simple function needs to be used just once or twice and it is not worth defining a full function to do this.  This form of function can also be defined as follows:      (code&amp;)    where var1,var2,var3,...,varn are replaced by ``````#1,#2,...,# in the code. For example:      Function[ {a,b,c}, { {&quot;a is:&quot;,a}, {&quot;b is:&quot;,b}, {&quot;c is:&quot;,c} } ]    could be written as:      ({ {&quot;a is:&quot;,#1}, {&quot;b is:&quot;,#2}, {&quot;c is:&quot;,#3} }&amp;)    And to see that they are in fact the same function. We call the first:      Function[ {a,b,c}, { {&quot;a is:&quot;,a}, {&quot;b is:&quot;,b}, {&quot;c is:&quot;,c} } ][1,2,3] (*Out:*) {{&quot;a is:&quot;,1},{&quot;b is:&quot;,2},{&quot;c is:&quot;,3}}    And then the second:      ({ {&quot;a is:&quot;,#1}, {&quot;b is:&quot;,#2}, {&quot;c is:&quot;,#3} }&amp;)[1,2,3] (*Out:*) {{&quot;a is:&quot;,1},{&quot;b is:&quot;,2},{&quot;c is:&quot;,3}}    And note that they give exactly the same output.  In Mathematica these are known as pure functions, to distinguish them from functions defined the way we&#39;ve done before.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/functions.html</guid>
    <pubDate>Wed 18 Jul 2018 22:31:03</pubDate>
  </item>
  <item>
    <title>Loops and Scoping</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/loops-and-scoping.html</link>
    <description>
        Loops and Scoping  For most simple tasks (i.e. most computations a chemist has to perform), making a notebook with a bunch of input and output cells is sufficient and possibly even best.  However, sometimes the task at hand is not so simple and so we&#39;ll need to progress to more complex structures.    Table and Do  Both Table and Do list over a range or a set of inputs and apply a function.  For example we can iterate over the numbers going from 1 to 10     Table[i*i, {i,10}] (*Out:*) {1,4,9,16,25,36,49,64,81,100}    Or over an arbitrary list of inputs      Table[i*i, {i, {a, b, c, d, e}}] (*Out:*) {a^2,b^2,c^2,d^2,e^2}    The difference is that Table returns a List while Do returns either Null or anything returned from Return  Usually this means one wants to use Table , however this behavior gives Do two distinct advantages. The first is that Table must return something at every step, while Do used in conjunction with Reap and Sow need not. For example let&#39;s get the prime numbers between 1 and 1000 :      Reap[ Do[If[PrimeQ[i],Sow[i]],{i,1000}] ][[2,1]] (*Out:*) {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997}    Table would return Null every time there wasn&#39;t a prime meaning we&#39;d have vastly too many outputs.  Secondly and most critically, Do can go over an infinite range, when used with Break or Return which acts like a ``````While[True, body loop, but cleaner. In general, Do can be used in this way whenever While would have been used. For example:      Do[If[RandomReal[]&lt;.00001, Return[i]], {i,}] (*Out:*) 210319    This simulates the following loop:      i=1; While[RandomReal[]&gt;.00001, i+=1 ]; i (*Out:*) 184158    But Do is a cleaner construct, owing to its automatic scoping of the i and implicit incrementor    Module, With, and Block  Module , With , and Block are called scoping constructs. That is, they let you use a variable or multiple variables without having to change or set them globally, or. This is easiest to show in an example:  Consider the following chunk of code:      a=2; squareA[]:=(a=a*a); {squareA[],squareA[],squareA[]} (*Out:*) {4,16,256}    Then check the current value of a     a (*Out:*) 256    Now try checking a in a Module where the variable a has been scoped      Module[{a}, a ] (*Out:*) a$736    Notice that the value of a is not its global value. This is because Module creates its own scope to execute the code in.  This is the basic use of a scoping construct, protecting code from being influenced by the global state.  Each construct has its own peculiarities, but these will be discussed more later. For now, we&#39;ll only discuss Module as its usage is the clearest.    Module  Module has the following form:      Module[{var1,var2,...,varn}, codeBlock ]    where var1,var2,...,varn are either simple variable names or variable names with initial values.  Past that, one can write code with Module just as one would normally.  Consider the following:      Module[{v1,v2=10,v3=50,v4}, v3=10; v4=v3*v2; {v1,v2,v3,v4} ] (*Out:*) {v1$739,10,10,100}    The code executes just as one would expect, the only difference being that v1 has been renamed. If one runs the following it becomes clear how Module works:      Module[ {v1, v2=10, v3=50, v4}, v3=10; Clear@v4; {v1,v2,v3,v4} ] (*Out:*) {v1$740,10,10,v4$740}    All module does is replace each variable in the first argument with the variable name followed by $i where i is an integer (given by the value of the global variable $ModuleNumber when the Module is executed).
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/loops-and-scoping.html</guid>
    <pubDate>Wed 18 Jul 2018 23:09:31</pubDate>
  </item>
  <item>
    <title>Errors</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/errors.html</link>
    <description>
        Errors  Obviously code doesn&#39;t always do what one expects it to. Often this is because the programmer or user is trying to do something wrong.  In many programming languages, the code will stop evaluating and the language will return an error. In Mathematica however, one of two things will happen:    Errors as Messages  Particularly with built-in functions, when an error is encountered Mathematica will print an error message. For example, try evaluating the following      Plot[Sin]         Plot::argr:       Plot called with 1 argument; 2 arguments are expected.           (*Out:*) Plot[Sin]    You&#39;ll notice that Mathematica prints a small message telling us that Plot requires two arguments. Note however that what is returned is exactly what was input. This is because when Mathematica doesn&#39;t now how to evaluate a function, it simply returns the function and its arguments as is.    Silent Errors  This behavior, returning expressions it can&#39;t evaluate, is critical to Mathematica programming, but can lead to some nasty bugs.  Consider the following:      F[a_]:=&quot;~~Wow~~~&quot;    Now say we want to format a big grid, but replace a random element with our the result of our function:      thisCallsF[b_]:= Grid@ReplacePart[Partition[Range[200],10],{RandomInteger[20], RandomInteger[10]}-&gt;f[b]] thisCallsF[x] (*Out:*)       Our grid isn&#39;t what we wanted it to be because we typed f instead of F and Mathematica saw no issue with our mistake. This is why it&#39;s critical to check your code to make sure you typed everything correctly--Mathematica won&#39;t do that for you.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/errors.html</guid>
    <pubDate>Wed 18 Jul 2018 22:26:15</pubDate>
  </item>
  <item>
    <title>Clear</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/clear.html</link>
    <description>
        Clear  Before we can really begin working with Mathematica we also need to discuss the function Clear , which can be a life-saver.  It just removes any definitions we&#39;ve given to a symbol, which can be a bigger deal than one might think. Consider the following case:     aVariableIUsedBefore=1000; aVariableIUsedBefore[x_]:=x*10;         SetDelayed::write:       Tag Integer in 1000[x_] is Protected.        Notice we get an error because the way Mathematica reads this, we&#39;re trying to assign a function to the number 1000.  Here, though, all we need to do is use Clear and we&#39;re good to go.      Clear[aVariableIUsedBefore]    Sometimes we&#39;ve made a lot of definitions and we want to Clear them all, just to prevent hard to find errors from cropping up. In this case we can do the following:      Clear[&quot;Global`*&quot;]    What this does is removes all the definitions for any symbol that looks like Global`symbolName which is usually every symbol we&#39;ve defined.  Sometimes we want to protect some symbols, like fundamental constants, from being erased. In this case we just need to make a symbol that doesn&#39;t look like Global`symbolName . A useful way to do this is to put the type of thing it is before it:      Constant`PlanckConstant = 6.626*10 -34 (*J*s*);     This sort of thing is discussed more at length in the Contexts section, but first let&#39;s just see that this does what we want it to. First let&#39;s define a bunch of things:      a=100; b=2.50; c[x_]=RandomReal[]*x; x[x_]:=x[x]; a b c[10] x[10] (*Out:*) 100 (*Out:*) 2.5` (*Out:*) 9.548010769916973` (*Out:*) 10[10]    And now we&#39;ll clear them:      Clear[&quot;Global`*&quot;] a b c[10] x[10] (*Out:*) a (*Out:*) b (*Out:*) c[10] (*Out:*) x[10]    But our constant is fine:      Constant`PlanckConstant (*Out:*) 6.6260000000000015`*^-34    And for those who don&#39;t want to type out a long name every time they use this constant in a problem, here&#39;s a trick: use some variable just for the problem to which you assign the value of the constant. e.g:      Constant`SpeedOfLight=3*10 8 (*m/s*);        h=Constant`PlanckConstant; c=Constant`SpeedOfLight; =1*10^-3 (*m*); h*c/ (*J*) (*Out:*) 1.9878000000000004`*^-22    Then just clear all of this before starting the next problem:      Clear[&quot;Global`*&quot;]    And now none of that can leak into the next problem:      h c  (*Out:*) h (*Out:*) c (*Out:*)
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/basics/clear.html</guid>
    <pubDate>Wed 18 Jul 2018 14:29:56</pubDate>
  </item>
  <item>
    <title>Function Aliases</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/function-aliases.html</link>
    <description>
        Function Aliases  Mathematica has a series of useful function aliases that make coding more concise and readable.  Technically, these are called infix operators , a term that also encapsulates + , - , and * , but that&#39;s unimportant for their usage here.    @ (Prefix)  The @ alias is like a pair of square brackets. The following illustrates its usage:      N@ (*Out:*) 3.141592653589793`    It only applies to a single argument however. For example, Mathematica will not evaluate the following command      N@,12     /@ (Map)  /@ takes a function and applies to every element in a list, returning the list of results. Example:      Sin/@(*{0,1/4,1/2,3/4,1,1+1/4,1+1/2,1+3/4,2}) (*Out:*) {0,,1,,0,-,-1,-,0}    When using this alias care should be taken that the right-hand side is wrapped in parentheses, as was done above, if it&#39;s more than just a simple list.    @@ (Apply)  @@ applies a function to all the arguments in a list. That is, the elements of the list become the arguments to the function. Example:      N@@{,12} (*Out:*) 3.14159265358979323846264338327950419984`12.     // (Postfix)  // is more or less a reversed form of @ . Example:      //N (*Out:*) 3.141592653589793`    But there is a small difference in terms of how the two work with other operators.  Consider you&#39;re trying to apply the function f to the list of results generated by using g/@{1,2,3,4} One might first try the following:      f@g/@{1,2,3,4} (*Out:*) {f[g][1],f[g][2],f[g][3],f[g][4]}    This clearly doesn&#39;t work. f is applied to g before being mapped across {1,2,3,4} .  In this case there are two options:      f@(g/@{1,2,3,4}) (*Out:*) f[{g[1],g[2],g[3],g[4]}]    or      g/@{1,2,3,4}//f (*Out:*) f[{g[1],g[2],g[3],g[4]}]    because /@ evaluates before // , this works. What is said is that // has a low precedence .  Precedences for any operator can be checked using the function Precedence , if the function name is known. Function names for a given operator can be found by selecting the operator and using F on Mac or F1 on Windows.  For example, knowing that // is an alias for the function Postfix     Precedence@Postfix (*Out:*) 70.`    And we&#39;ll compare that to the function Prefix for which @ is an alias      Prefix//Precedence (*Out:*) 640.`     ~ (Infix)  ~ takes a function and applies it to the preceding and following arguments as follows:      ~N~12 (*Out:*) 3.14159265358979323846264338327950419984`12.    This is useful and worth knowing, but it can often be cleaner simply to use @@ , potentially in combination with //   @* (Composition)  @* takes a two functions and composes them. For example:      (f@*g)[1] (*Out:*) f[g[1]]    This is particularly useful when negating a function, that is, applying the Not function to it. We can make a simple NotTrueQ function by doing this:      NotTrueQ=(Not@*TrueQ); NotTrueQ@1 NotTrueQ@False NotTrueQ@True (*Out:*) True (*Out:*) True (*Out:*) False        See Also:    https://mathematica.stackexchange.com/questions/18393/what-are-the-most-common-pitfalls-awaiting-new-users/25616#25616
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/function-aliases.html</guid>
    <pubDate>Tue 17 Jul 2018 13:24:49</pubDate>
  </item>
  <item>
    <title>Documentation</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/documentation.html</link>
    <description>
        Documentation   Getting Documentation  Mathematica has a rich, if somewhat overly complex documentation system. To learn about a given symbol there are a few things you can do. Probably the quickest is to use the built in function Definition which prints out the description all the definitions on a symbol. You can do this by putting ? before a symbol      ?Print      Print[ expr ] prints expr as output.       ?Plot      Plot[ f ,{ x , x *min* , x *max* }] generates a plot of f as a function of x from x *min* to x *max* . Plot[{ f 1 , f 2 ,},{ x , x *min* , x *max* }] plots several functions f *i* . Plot[{, w [ f *i* ],},] plots f *i* with features defined by the symbolic wrapper w .Plot[,{ x }&amp;Element; reg ] takes the variable x to be in the geometric region reg .        ?Quantity      Quantity[ magnitude , unit ] represents a quantity with size magnitude and unit specified by unit .Quantity[ unit ] assumes the magnitude of the specified unit to be 1.        ?GeneralUtilities`PrintDefinitions      PrintDefinitions[ symbol ] creates a window containing a browseable hyperlinked listing of definitions associated with symbol .     To find out the most about a symbol it&#39;s best to use the built in documentation notebooks however. Just type a symbol name and click the  icon in the little menu that appears. This will open the Documentation Center where you can look around, find links to other functions and symbols, explanations, and most crucially examples.  This menu can also be gotten by placing the cursor immediately following a symbol name or piece of one and pressing +K  Another way to open the documentation center is to highlight a piece of text and press ++F. This is often more useful, as getting the icon to appear can be annoying and this also works in any environment.    Documentation Issues  Mathematica has no automatic documentation procedure. It&#39;s all done manually. This allows for commonly used function to be incredibly well documented, but also means that less used functions get somewhat short shrift and many aren&#39;t documented at all (although this is often intentional, as a feature isn&#39;t ready for prime-time)  Another common problem is that Mathematica&#39;s built in autocomplete features only match from the beginning of the word you&#39;re typing. Say you know there should be a function that converts a number into a string, so you start typing something like NumberToString , but as you&#39;re typing you notice Mathematica will give you NumberString , but when you check its documentation page its not what you wanted at all. For that, I provide the following helpful function using the built in function Names :      FindMySymbol[piecesOfAName__String]:= Riffle[ ConstantArray[ Alternatives[piecesOfAName], Length@{piecesOfAName} ], ___ ]// Append[#,___]&amp;// Prepend[#,___]&amp;// StringExpression@@#&amp;// Names    And we&#39;ll see that this works:      FindMySymbol[&quot;String&quot;,&quot;To&quot;] (*Out:*) {&quot;ByteArrayToString&quot;,&quot;StringToByteArray&quot;,&quot;StringToStream&quot;,&quot;ToString&quot;}    Notice it won&#39;t find anything if we use all parts of our name:      FindMySymbol[&quot;String&quot;,&quot;To&quot;,&quot;Number&quot;] (*Out:*) {}    But that&#39;s okay. Just add or drop pieces as necessary. Or use the following and just provide a guess of your name:      GuessedSymbols[nameGuess_String, matchComponents_:2]:= With[{nameSegments= SequenceCases[ StringSplit[nameGuess, l_?UpperCaseQ:&gt;l], s:{_?UpperCaseQ,_?(LowerCaseQ@StringTake[#,1]&amp;)}:&gt;StringJoin@s ]}, FindMySymbol[Sequence@@#,False]&amp;/@ Subsets[nameSegments,{matchComponents}]// Join@@#&amp;//DeleteDuplicates ]; GuessedSymbols[name_Symbol,matchComponents_:2]:= GuessedSymbols[ToString@name,matchComponents]    To verify it works:      GuessedSymbols@&quot;StringToNumber&quot; (*Out:*) {&quot;ByteArrayToString&quot;,&quot;StringToByteArray&quot;,&quot;StringToStream&quot;,&quot;ToString&quot;,&quot;NumberFieldClassNumber&quot;,&quot;NumberString&quot;,&quot;ToNumberField&quot;}        See Also:    https://mathematica.stackexchange.com/questions/18393/what-are-the-most-common-pitfalls-awaiting-new-users/18606
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/documentation.html</guid>
    <pubDate>Wed 18 Jul 2018 14:30:22</pubDate>
  </item>
  <item>
    <title>Keyboard Aliases and Special Characters</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/keyboard-aliases-and-special-characters.html</link>
    <description>
        Keyboard Aliases and Special Characters  As mentioned before, there are many useful keyboard aliases. Remember that you get one by pressing  typing an alias and pressing  again.  Here&#39;s a partial list of them:      Pane[ Column[ DeleteCases[ Table[Switch[First@i, &quot;ia&quot;,None, _,First@i-&gt;DisplayForm@Last@i ],{i,InputAliases/.Options[EvaluationNotebook[],InputAliases]}], None ], ItemSize-&gt;{1000, Automatic}, Dividers-&gt;Center ], {250, 250}, Scrollbars-&gt;{False, True} ] (*Out:*)       It&#39;s worth playing around with lots of different combinations through. For instance, here&#39;s the alias for each keyboard character      Thread[ Join[ Alphabet[], Capitalize/@Alphabet[] ]-&gt; { &quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;, &quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;J&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;, &quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;V&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot; } ]// Pane[ Column[ DeleteCases[ Table[ Switch[First@i, &quot;ia&quot;, None, _, First@i-&gt;DisplayForm@Last@i ], {i,#} ], None ], ItemSize-&gt;{1000,Automatic}, Dividers-&gt;Center ], {250,250}, Scrollbars-&gt;{False, True} ]&amp; (*Out:*)       On top of these alias symbols there&#39;s another group of symbols that can be gotten via \[&lt;name&gt;]  For example, by doing this with the name EscapeKey one gets the following: . There are also fun things like  HeartSuit:  SmallCircle:  CheckedBox:   Plus a host of others. In general, any cell that will autocomplete symbol name will also autocomplete these names.  Finally, I&#39;ve made a little cell that will start looking for names the moment you type the first character of the name. You can generate it with the following code. If you then press backspace while the cell is empty it will automatically print \[ for you. Hopefully this will make searching for special characters somewhat easier.      Cell[ BoxData[&quot;&quot;], &quot;Code&quot;, CellDingbat-&gt;TextData[{&quot;Search&quot;, &quot; &quot;, &quot;Cell&quot;, &quot; &quot;, &quot;&quot;}], CellEventActions-&gt;{ &quot;KeyDown&quot; :&gt; If[ MatchQ[ And[CurrentValue[&quot;EventKey&quot;] === &quot; &quot;, First[ NotebookRead[ EvaluationCell[] ] ] ], BoxData[&quot;&quot;] ], NotebookWrite[ EvaluationNotebook[], &quot;\\[ &quot; ] ], PassEventsDown -&gt; True}, CodeAssistOptions-&gt;{ &quot;AutoPopupDelay&quot;-&gt;0., &quot;MinimalSize&quot;-&gt;1, &quot;StringCompleteEnable&quot;-&gt;True }, Evaluatable -&gt; False ]//CellPrint
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/keyboard-aliases-and-special-characters.html</guid>
    <pubDate>Wed 18 Jul 2018 14:30:15</pubDate>
  </item>
  <item>
    <title>Palettes and Toolbars</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/palettes-and-toolbars.html</link>
    <description>
        Palettes and Toolbars  Mathematica provides a series of toolbars and palettes.  Toolbars are found under Window  Toolbar  Palettes are found under the Palettes menu  Most useful of the toolbars for every day use is the Formatting toolbar.  All of the palettes are useful, but perhaps the Writing Assistant more so than the others.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/palettes-and-toolbars.html</guid>
    <pubDate>Fri 29 Dec 2017 01:49:00</pubDate>
  </item>
  <item>
    <title>Styles</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/styles.html</link>
    <description>
        Styles  Different cells have different styles, which you can access via the style menu ( Format  Style ) or keyboard shortcuts. Here are a few of them:  There are many other styles of cells and there is even a way to change the styling of cells (as I have done to make this document appear the way it does), but for most projects and purposes, such as homework assignments, these styles suffice.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/interface/styles.html</guid>
    <pubDate>Wed 18 Jul 2018 14:36:12</pubDate>
  </item>
  <item>
    <title>Plotting</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/plotting.html</link>
    <description>
        Plotting  Mathematica has a host of different plot functions, but usually one only needs three of them:    Plot  Plot takes a function as its first argument and a variable and range as its second one. Example:      Plot[Sin[x], {x, -, }, ImageSize -&gt; Small] (*Out:*)       The function can also be defined outside of the Plot function itself:      sinx = Sin[x]; Plot[sinx, {x, -, }, ImageSize -&gt; Small] (*Out:*)       User defined functions are also valid, but they must first be called on the variable one wants to use.  Thats why the following fails:      mySin[x_] := Sin[x]; Plot[mySin, {x, -, }, ImageSize -&gt; Small] (*Out:*)       But the following will work:      mySin[x_] := Sin[x]; Plot[mySin[x], {x, -, }, ImageSize -&gt; Small] (*Out:*)       Plot can also plot many functions simultaneously, if the first argument is a list of appropriate functions:      Plot[{Sin[x], Cos[x], Tan[x]}, {x, -, }, ImageSize -&gt; Small] (*Out:*)       These functions can be distinguished from each other via legends and styling. For example:      Plot[{Sin[x], Cos[x], Tan[x]}, {x, -, }, PlotLegends -&gt; &quot;Expressions&quot;, PlotStyle -&gt; { Directive[Dashed, Gray], Directive[Thick, Purple], Directive[Thin, Red] }, ImageSize -&gt; Small ] (*Out:*)        ListPlot  ListPlot is a variant of Plot that just takes a list of values and plots them. For example, lets plot the first 1000 primes. The function were using here, Table , is explained more in the next section.      ListPlot[Table[Prime[n], {n, 1000}], ImageSize -&gt; Small] (*Out:*)       Similarly to Plot , we can plot multiple data sets:      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, ImageSize -&gt; Small] (*Out:*)       And again we can apply styling rules:      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, PlotLegends -&gt; {&quot;prime n for \ n=2,4,6,...,1000&quot;, &quot;-prime n for n=1,3,5,...,999&quot;}, PlotStyle -&gt; {Directive[AbsolutePointSize[5], Red], Directive[AbsolutePointSize[.1], Purple]}, ImageSize -&gt; Small ]        (*Out:*)       We can also join the points to plot out a line      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, PlotLegends -&gt; {&quot;prime n for \ n=2,4,6,...,1000&quot;, &quot;-prime n for n=1,3,5,...,999&quot;}, PlotStyle -&gt; {Directive[Dashed, Red], Directive[Thick, Purple]}, Joined -&gt; True, ImageSize -&gt; Small ]        (*Out:*)        Plot3D  Plot3D works just like Plot , but takes two ranges      Plot3D[Sin[x + y], {x, -, }, {y, 0, 2 }, ImageSize -&gt; Small] (*Out:*)       Multiple functions:      Plot3D[{Sin[x], Cos[y]}, {x, -, }, {y, 0, 2 }, ImageSize -&gt; Small] (*Out:*)       Styling:      Plot3D[{Sin[x], Cos[y]}, {x, -, }, {y, 0, 2 }, PlotLegends -&gt; &quot;Expressions&quot;, MeshStyle -&gt; None, PlotStyle -&gt; { Directive[Specularity[Gray, 10], White], Directive[Purple, Specularity[Gray, 100], Opacity[.3]]}, Lighting -&gt; &quot;Neutral&quot;, ImageSize -&gt; Small] (*Out:*)        Special Plots  Mathematica, being the massive system it is, has more-or-less every plot type one could desire built in. Most of these will not be generally useful, but it is worth keeping in mind that any plot type one could want, like, say, a 3D point-wise density-estimating plot, Mathematica has it. See: ListDensityPlot3D .  That specific plot will be useful later in finding local sinks from gradient functions and is not the kind of run-of-the-mill plot one sees everywhere.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/plotting.html</guid>
    <pubDate>Thu 28 Dec 2017 02:19:10</pubDate>
  </item>
  <item>
    <title>Symbolic Algebra</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/symbolic-algebra.html</link>
    <description>
        Symbolic Algebra  As is explained more fully in the Mathematica Programming section, the language Mathematica is built around is almost 100% symbolic, which makes it perfect for algebraic manipulations.  One of the simplest examples of things one can do in Mathematica is generate and combine polynomials:      simplePolynomial[var_,order_]:= Total@Table[RandomInteger[10]*Power[var,n],{n,order}];    We&#39;ll make a few of these polynomials and add them:      pX1=simplePolynomial[x,2] pX2=simplePolynomial[x,2] pX1+pX2 (*Out:*) 6 x+6 x^2 (*Out:*) 8 x+9 x^2 (*Out:*) 14 x+15 x^2    This works just as well at any polynomial order. Here we&#39;ll add five randomly generated polynomials of order less than or equal to 15 .      Array[(simplePolynomial[x, RandomInteger[15]])&amp;, 5]//Total (*Out:*) 22 x+26 x^2+15 x^3+28 x^4+10 x^5+9 x^6+12 x^7+13 x^8+19 x^9+11 x^10+9 x^11+13 x^12+6 x^13+4 x^14    Here&#39;s that again, but formatted nicer:  $$4 x^{14}+6 x^{13}+13 x^{12}+9 x^{11}+11 x^{10}+19 x^9+13 x^8+12 x^7+9 x^6+10 x^5+28 x^4+15 x^3+26 x^2+22 x$$  For those interested, the &amp; specifies that what comes before should be treated as a function, but absent any variables we simply get our expression as a result.    Simplify  For more complex things we&#39;ll need to explicitly simplify them:      sphericalHarmonicSum= Total@ Array[ SphericalHarmonicY[RandomInteger[5], RandomInteger[5], , ]&amp;, 5]    We can then have Mathematica simplify this expression for us more:      Simplify[sphericalHarmonicSum]    $$\frac{1}{64} \sqrt{\frac{3}{2 \pi }} e^{i \phi } \sin (\theta ) \left(2 \left(\sqrt{11}+4\right) \sqrt{35} e^{i \phi } \sin (2 \theta )+3 \sqrt{385} e^{i \phi } \sin (4 \theta )-32\right)$$  Sometimes we also need to use the function FullSimplify to get everything simplified:      FullSimplify[sphericalHarmonicSum]    $$\frac{1}{32} \sqrt{\frac{3}{2 \pi }} e^{i \phi } \sin (\theta ) \left(-16+\sqrt{35} e^{i \phi } \sin (2 \theta ) \left(3 \sqrt{11} \cos (2 \theta )+\sqrt{11}+4\right)\right)$$  It often makes sense to go for Simplify over FullSimplify , despite the fact that we can get more simplification out of FullSimplify , because sometimes the Simplify is all we need to see a pattern ourselves, while FullSimplify can over-simplify and obliterate that pattern.  It&#39;s good to keep in mind that while Mathematica may know more than we do, we&#39;re still smarter than it is.    Solve  Mathematica can also solve equations for us. We&#39;ll try this on a nice quartic polynomial:      polynomialInX=simplePolynomial[x, 4]    $$6 x^4+3 x^3+5 x^2+6 x$$  Note that there&#39;s no nice way to find the roots of this polynomial by hand. But Mathematica doesn&#39;t mind:      Solve[polynomialInX==0,x] (*Out:*) { {x-&gt;0}, {x-&gt;1/6 (-1-9/(-94 + Sqrt[9565])^(1/3)+(-94 + Sqrt[9565])^(1/3))}, {x-&gt;-1/6+(3 (1 + I Sqrt[3]))/(4 (-94 + Sqrt[9565])^(1/3))-1/12 (1-I Sqrt[3]) (-94 + Sqrt[9565])^(1/3)}, {x-&gt;-1/6+(3 (1 - I Sqrt[3]))/(4 (-94 + Sqrt[9565])^(1/3))-1/12 (1+I Sqrt[3]) (-94 + Sqrt[9565])^(1/3)} }    Here&#39;s one of those solutions in easier-to-read form:  $$\frac{1}{6} \left(\sqrt[3]{\sqrt{9565}-94}-\frac{9}{\sqrt[3]{\sqrt{9565}-94}}-1\right)$$  As mentioned before, Mathematica knows more math than any of us. It sees a quartic polynomial and knows that by the fundamental theorem of algebra there are four solutions to this equation, we just might need to find complex solutions.  Usually this isn&#39;t what we want, unfortunately. Happily Mathematica can dumb itself down for us.      Solve[polynomialInX==0,x,Reals] (*Out:*) { {x-&gt;0},{x-&gt;Root[6+5 #1+3 #1^2+6 #1^3&amp;,1]} }    Notice that we get this odd Root expression. That&#39;s the way Mathematica represents a perfectly exact root. We can get its numerical one of two ways. Either we make the equation inexact:      Solve[polynomialInX==0., x, Reals] (*Out:*) { {x-&gt;-0.867733324263096`},{x-&gt;0} }    Or we numericize after the fact:      N[Solve[polynomialInX==0,x,Reals],6] (*Out:*) { {x-&gt;0},{x-&gt;-0.8677333242630958819`6.} }    One useful thing to know with Solve is why the results are returned so oddly. Each list is a different solution, which is more important with multivariate equations, which we&#39;ll get to, but first let&#39;s see a nice way to get out our solutions in a simple list:      x/.N[Solve[polynomialInX==0,x,Reals],6] (*Out:*) {0,-0.8677333242630958819`6.}    The /. is an alias for ReplaceAll , which is described in more detail later in the Replacement Patterns section. For now let&#39;s just note that any time it sees var on the left hand side it looks for var-&gt;val on the right hand side and replaces var with that.  Now let&#39;s also see how we can plot these solutions:      Show[ Plot[polynomialInX,{x,-2,2}], ListPlot[Table[{x,0}, {x,x/.Solve[polynomialInX==0.,x,Reals]}]] ] (*Out:*)       We have to use ListPlot to plot our discrete solutions, but we can see we get the result we expect.  We could even write a function that will solve the equation for an arbitrary value and plot the result:      solveAndPlot[eqInX_,val_]:= Show[ Plot[eqInX,{x,-2,2}], ListPlot[Table[{x,val}, {x,x/.Solve[eqInX==(1.val),x,Reals]}]], PlotLabel-&gt; Row@{ HoldForm[eqInX==val],&quot; @ &quot;, Row@Riffle[(x/.Solve[eqInX==(1.val),x,Reals]),&quot;, &quot;] } ];    Calling this on our solution:      solveAndPlot[polynomialInX,50] (*Out:*)       But that&#39;s getting distracted, I suppose.    Multivariate Solve  Let&#39;s move to multivariate equations now:      polynomialInXandY=simplePolynomial[x,3]+simplePolynomial[y,3] (*Out:*) 8 x+2 x^2+2 y+10 y^2+8 y^3    $$2 x^2+8 x+8 y^3+10 y^2+2 y$$  It can still solve this equation, although as it will admit, it may miss some solutions.      Solve[polynomialInXandY == 0,{x,y}, Reals]         Solve::svars:       &quot;Equations may not give solutions for all \&quot;solve\&quot; variables.&quot;           (*Out:*) { {x-&gt;ConditionalExpression[-2-Sqrt[4 - y - 5 y^2 - 4 y^3],y&lt;1/12 (-5+(829 - 6 Sqrt[19029])^(1/3)+(829 + 6 Sqrt[19029])^(1/3))]},{x-&gt;ConditionalExpression[-2+Sqrt[4 - y - 5 y^2 - 4 y^3],y&lt;1/12 (-5+(829 - 6 Sqrt[19029])^(1/3)+(829 + 6 Sqrt[19029])^(1/3))]},{x-&gt;-2-(4+1/12 (5-(829 - 6 Sqrt[19029])^(1/3)-(829 + 6 Sqrt[19029])^(1/3))-5/144 (-5 + (829 - 6 Sqrt[19029])^(1/3) + (829 + 6 Sqrt[19029])^(1/3))^2-1/432 (-5 + (829 - 6 Sqrt[19029])^(1/3) + (829 + 6 Sqrt[19029])^(1/3))^3),y-&gt;1/12 (-5+(829 - 6 Sqrt[19029])^(1/3)+(829 + 6 Sqrt[19029])^(1/3))} }    Here&#39;s one of the branches in human-readable form:  $$-\sqrt{-\frac{1}{432} \left(\sqrt[3]{6 \sqrt{19029}+829}+\sqrt[3]{829-6 \sqrt{19029}}-5\right)^3-\frac{5}{144} \left(\sqrt[3]{6 \sqrt{19029}+829}+\sqrt[3]{829-6 \sqrt{19029}}-5\right)^2+\frac{1}{12} \left(-\sqrt[3]{6 \sqrt{19029}+829}-\sqrt[3]{829-6 \sqrt{19029}}+5\right)+4}-2$$  Note that it also gives us these odd ConditionalExpression statements. This is because the solution could branch depending on how x and y interplay. Let&#39;s just get take one of these solutions:      conditionalSoln=First[x/.Solve[polynomialInXandY == 0.,{x,y}, Reals]]; N[conditionalSoln]         Solve::svars:       &quot;Equations may not give solutions for all \&quot;solve\&quot; variables.&quot;           (*Out:*) ConditionalExpression[-2.`-1.` Sqrt[4. - 1. y - 5. y^2 - 4. y^3],y&lt;0.6609358769285026`]    And plot it:     Plot[conditionalSoln,{y,-1,1},PlotLabel-&gt;&quot;Value of X for given Y&quot;] (*Out:*)       We can force a given branch of this conditional expression, however, by telling Mathematica what it can assume.    Assumptions  When Mathematica simplifies an expression it checks what we&#39;ve told it to about the expression. It does that by looking at the value of the variable $Assumptions     $Assumptions (*Out:*) True    This is the default value. But we can make it assume things for us. Let&#39;s assume that y satifies our ConditionalExpression . First we set the Assumptions :      $Assumptions=y&lt;.5 (*Out:*) y&lt;0.5`    Now Mathematica will use these when solving:      xAndyRoots={x, y}/.Solve[polynomialInXandY == 0, {x, y}, Reals]//First//Simplify         Solve::svars:       &quot;Equations may not give solutions for all \&quot;solve\&quot; variables.&quot;           (*Out:*) {-2-Sqrt[4 - y - 5 y^2 - 4 y^3],y}    And when we&#39;re done we simply reset the $Assumptions variable. We can also apply $Assumptions to a single Simplify expression or similar, but I will leave that to you to read up on.      See Also:    Symbolic Calculations     Simplifying Algebraic Expressions     Simplifying With Assumptions     Putting Expressions into Different Forms     Using Assumptions     Mathematica as Mathematician&#39;s Aid     Integration
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/symbolic-algebra.html</guid>
    <pubDate>Thu 19 Jul 2018 00:33:20</pubDate>
  </item>
  <item>
    <title>Calculus</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/calculus.html</link>
    <description>
        Calculus  Mathematica is useful for many types of mathematical operations, but of particular use are derivatives and integrals.    Derivatives  Derivatives can be taken using either the function D or the alias pd.  For example, to take the first derivative of x^2 one can use either of the following:      D[x^2,x] (*Out:*) 2 x    or      Subscript[, x]x^2 (*Out:*) 2 x    A derivative can be taken of a derivative:      Subscript[, x]Subscript[, x]x^2 (*Out:*) 2    But this is equivalent to a simple second derivative which Mathematica can also do:      D[x^2,{x,2}] (*Out:*) 2    or      Subscript[, x, x]x^2 (*Out:*) 2    We can also take derivatives in multiple variables:      Subscript[, x, y]1/Sqrt[x^2 + y^2] (*Out:*) (3 x y)/(x^2 + y^2)^(5/2)    Here&#39;s that but formatted better:  $$\frac{3 x y}{\left(x^2+y^2\right)^{5/2}}$$  And then for fun let&#39;s plot this:      dxy=Subscript[, x, y]1/Sqrt[x^2 + y^2]; Plot3D[dxy,{x,-5,5},{y,-5,5}] (*Out:*)        Integration  Mathematica also knows how to do more integrals than any chemist is likely to need. The function for integration is Integrate although like with derivatives there is an alias via intt for indefinite integrals and dintt for definite integrals  Here&#39;s the standard form for Integrate :      Integrate[2,x] (*Out:*) 2 x    And here&#39;s the alias form:      2x (*Out:*) 2 x    And just to show that Mathematica observes the fundamental theorem of calculus like the rest of us:      dxyxy (*Out:*) 1/Sqrt[x^2 + y^2]    Again, here&#39;s the same but formatted better:  $$\frac{1}{\sqrt{x^2+y^2}}$$  And we&#39;ll plot this too:      reversedxy=dxy xy; Plot3D[reversedxy,{x,-5,5},{y,-5,5}] (*Out:*)        Fun examples:  Mathematica is a great calculus tool and it knows many types of interesting functions so we&#39;ll have it integrate the following very nasty function for us:  ```Subscrip P, 3 d/dSubscrip P, 4 where Subscrip P, i is the i``` -th Legendre polynomial in $$\cos (\theta )$$ , which is to say, a nasty polynomial with a lot of trigonometric functions which is very difficult to integrate.     Integrate[LegendreP[3,Cos[]]Cot[]D[LegendreP[4,Cos[]],],{,0,}] (*Out:*) 0    but Mathematica has absolutely no problem evaluating this integral. It can even tell you that switching the derivative and cot terms makes the integral impossible to evaluate.      Integrate[LegendreP[3,Cos[]]D[Cot[]LegendreP[4, Cos[]],], {,0,}]    $$\int_0^{\pi } \frac{1}{2} \left(5 \cos ^3(\theta )-3 \cos (\theta )\right) \left(\frac{1}{8} \cot (\theta ) \left(60 \sin (\theta ) \cos (\theta )-140 \sin (\theta ) \cos ^3(\theta )\right)-\frac{1}{8} \left(35 \cos ^4(\theta )-30 \cos ^2(\theta )+3\right) \csc ^2(\theta )\right) \, d\theta$$  And when it sees that it simply returns the integral unevaluated
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/calculus.html</guid>
    <pubDate>Wed 18 Jul 2018 23:11:23</pubDate>
  </item>
  <item>
    <title>Built-in Data and Units</title>
    <link>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/builtin-data-and-units.html</link>
    <description>
        Built-in Data and Units  Mathematica provides access to a lot of data, most useful for chemistry is the built-in chemical, element, and isotope data and the physical constants it knows about    ElementData  ElementData is a function that gets data on an element from Mathematica&#39;s built in servers. Here&#39;s a way to get the atomic number of an element:      ElementData[&quot;W&quot;, &quot;AtomicNumber&quot;] (*Out:*) 74    We can also get things with units attached as a Quantity object:      ElementData[&quot;H&quot;, &quot;AtomicMass&quot;] (*Out:*) 1.00794u    Here is the full list of properties to query for each element:      Pane[Column@ElementData[&quot;Properties&quot;], ImageSize-&gt;{Automatic,{150,250}}, Scrollbars-&gt;{False, True}, AppearanceElements-&gt;None ]//Framed[#,Background-&gt;White]&amp; (*Out:*)       And here is a function to apply that to a given element      elementProperties[el_]:= Pane[Column@Table[With[{p=p}, Button[Mouseover[p,Style[p,Orange]], With[{next=NextCell[EvaluationCell[]],cell=Cell[BoxData@ToBoxes@(p-&gt;ElementData[el,p]),&quot;Output&quot;, CellFrame-&gt;{{0,0},{1,5}}, CellMargins-&gt;With[{m=CellMargins/.Options[EvaluationCell[],CellMargins]}, ReplacePart[m,{2,2}-&gt;0] ], &quot;CellFrameStyle&quot;-&gt;{{None,None},{Black,GrayLevel[.8]}}]}, If[next=!=None&amp;&amp;GeneratedCell/.Options[next,GeneratedCell]//TrueQ, NotebookWrite[next,cell], CellPrint@cell ]], Appearance-&gt;&quot;Frameless&quot;, Method-&gt;&quot;Queued&quot;, BaseStyle-&gt;&quot;Hyperlink&quot;] ], {p,ElementData@&quot;Properties&quot;}], ImageSize-&gt;{Full,{150,250}}, Scrollbars-&gt;{False, True}, AppearanceElements-&gt;None ]//Framed[#,Background-&gt;White]&amp; elementProperties[&quot;H&quot;] (*Out:*)       A list of all the elements can be generated via ElementData[] and I used that to generate a template for a periodic table. So finally here is a function that uses this template and the previously defined function to get all the possible information from ElementData.     periodicTable[]:= With[{dlen=10,slen=2,plen=6}, { {&quot;H&quot;}~Join~ConstantArray[Null,dlen+plen]~Join~{&quot;He&quot;}, {&quot;Li&quot;,&quot;Be&quot;}~Join~ConstantArray[Null,dlen]~Join~{&quot;B&quot;,&quot;C&quot;,&quot;N&quot;,&quot;O&quot;,&quot;F&quot;,&quot;Ne&quot;}, {&quot;Na&quot;,&quot;Mg&quot;}~Join~ConstantArray[Null,dlen]~Join~{&quot;Al&quot;,&quot;Si&quot;,&quot;P&quot;,&quot;S&quot;,&quot;Cl&quot;,&quot;Ar&quot;}, {&quot;K&quot;,&quot;Ca&quot;,&quot;Sc&quot;,&quot;Ti&quot;,&quot;V&quot;,&quot;Cr&quot;,&quot;Mn&quot;,&quot;Fe&quot;,&quot;Co&quot;,&quot;Ni&quot;,&quot;Cu&quot;,&quot;Zn&quot;,&quot;Ga&quot;,&quot;Ge&quot;,&quot;As&quot;,&quot;Se&quot;,&quot;Br&quot;,&quot;Kr&quot;}, {&quot;Rb&quot;,&quot;Sr&quot;,&quot;Y&quot;,&quot;Zr&quot;,&quot;Nb&quot;,&quot;Mo&quot;,&quot;Tc&quot;,&quot;Ru&quot;,&quot;Rh&quot;,&quot;Pd&quot;,&quot;Ag&quot;,&quot;Cd&quot;,&quot;In&quot;,&quot;Sn&quot;,&quot;Sb&quot;,&quot;Te&quot;,&quot;I&quot;,&quot;Xe&quot;}, {&quot;Cs&quot;,&quot;Ba&quot;,&quot;Lu&quot;,&quot;Hf&quot;,&quot;Ta&quot;,&quot;W&quot;,&quot;Re&quot;,&quot;Os&quot;,&quot;Ir&quot;,&quot;Pt&quot;,&quot;Au&quot;,&quot;Hg&quot;,&quot;Tl&quot;,&quot;Pb&quot;,&quot;Bi&quot;,&quot;Po&quot;,&quot;At&quot;,&quot;Rn&quot;}, {&quot;Fr&quot;,&quot;Ra&quot;,&quot;Lr&quot;,&quot;Rf&quot;,&quot;Db&quot;,&quot;Sg&quot;,&quot;Bh&quot;,&quot;Hs&quot;,&quot;Mt&quot;,&quot;Ds&quot;,&quot;Rg&quot;,&quot;Cn&quot;,&quot;Uut&quot;,&quot;Fl&quot;,&quot;Uup&quot;,&quot;Lv&quot;,&quot;Uus&quot;,&quot;Uuo&quot;}, ConstantArray[Null,slen]~Join~{&quot;La&quot;,&quot;Ce&quot;,&quot;Pr&quot;,&quot;Nd&quot;,&quot;Pm&quot;,&quot;Sm&quot;,&quot;Eu&quot;,&quot;Gd&quot;,&quot;Tb&quot;,&quot;Dy&quot;,&quot;Ho&quot;,&quot;Er&quot;,&quot;Tm&quot;,&quot;Yb&quot;}, ConstantArray[Null,slen]~Join~{&quot;Ac&quot;,&quot;Th&quot;,&quot;Pa&quot;,&quot;U&quot;,&quot;Np&quot;,&quot;Pu&quot;,&quot;Am&quot;,&quot;Cm&quot;,&quot;Bk&quot;,&quot;Cf&quot;,&quot;Es&quot;,&quot;Fm&quot;,&quot;Md&quot;,&quot;No&quot;} } ]//Grid[#,Alignment-&gt;Center]&amp;//ReplaceAll[#,{ e_String:&gt;With[{color=Replace[ ColorData[&quot;Atoms&quot;][e], Except[_RGBColor]-&gt;Gray]}, Item[ Button[ Mouseover[Style[e,If[ColorDistance[Black,color]&lt;.9//TrueQ, White, Black]], Style[e,Orange]],CreateDocument[{Cell[BoxData@ToBoxes@elementProperties@e,&quot;Output&quot;], Cell[&quot;&quot;,GeneratedCell-&gt;True]}, Background-&gt;color, WindowTitle-&gt;Capitalize@ElementData[e,&quot;Name&quot;], WindowSize-&gt;{400,365}, StyleDefinitions-&gt;Notebook@{ Cell[StyleData[StyleDefinitions-&gt;&quot;Default.nb&quot;]], Cell[StyleData@&quot;Output&quot;, Background-&gt;White, CellMargins-&gt;{{10, 0}, {0, 10}}] }, WindowElements-&gt;{}, WindowFrameElements-&gt;{&quot;CloseBox&quot;,&quot;ZoomBox&quot;,&quot;MinimizeBox&quot;}, Saveable-&gt;False, ScrollingOptions-&gt;{&quot;VerticalScrollRange&quot;-&gt;FitAll}], Appearance-&gt;&quot;Frameless&quot; ], Background-&gt;color, Frame-&gt;True ] ] }]&amp;//Deploy    Since this function calls elementProperties be sure to evaluate the definition for elementProperties before evaluating the following.      periodicTable[] (*Out:*)        IsotopeData  IsotopeData is similar to ElementData except one supplies an isotope instead. Known isotopes for a given element can be gotten via the following function      knownIsotopes[element_]:= Table[element&lt;&gt;ToString@i,{i,ElementData[element,&quot;KnownIsotopes&quot;]}] knownIsotopes@&quot;H&quot; (*Out:*) {&quot;H1&quot;,&quot;H2&quot;,&quot;H3&quot;,&quot;H4&quot;,&quot;H5&quot;,&quot;H6&quot;,&quot;H7&quot;}    We can similarly get all the properties for an isotope in the same way as for an element:      isotopeProperties[iso_]:= Pane[Column@Table[With[{p=p}, Button[Mouseover[p,Style[p,Orange]], With[{next=NextCell[EvaluationCell[]],cell=Cell[BoxData@ToBoxes@(p-&gt;IsotopeData[iso,p]),&quot;Output&quot;, CellFrame-&gt;{{0,0},{1,5}}, CellMargins-&gt;With[{m=CellMargins/.Options[EvaluationCell[],CellMargins]}, ReplacePart[m,{2,2}-&gt;0] ], &quot;CellFrameStyle&quot;-&gt;{{None,None},{Black,GrayLevel[.8]}}]}, If[next=!=None&amp;&amp;GeneratedCell/.Options[next,GeneratedCell]//TrueQ, NotebookWrite[next,cell], CellPrint@cell ]], Appearance-&gt;&quot;Frameless&quot;, Method-&gt;&quot;Queued&quot;, BaseStyle-&gt;&quot;Hyperlink&quot;] ], {p,IsotopeData@&quot;Properties&quot;}], ImageSize-&gt;{Full,{150,250}}, Scrollbars-&gt;{False, True}, AppearanceElements-&gt;None ]//Framed[#,Background-&gt;White]&amp; isotopeProperties[&quot;H2&quot;] (*Out:*)        ChemicalData  The final useful data set is the built in ChemicalData which can return properties of chemicals generally. At this point it should be clear how it works, but it&#39;s worth pointing out that the list of all the known chemicals can take a long time to load so only call ChemicalData without any arguments if you&#39;re sure your internet connection is good and your computer can handle the load.    Quantity  The interface to the units Mathematica knows about is called Quantity  This was used previously to get the value of the molar gas constant, but there is a host of useful units built in. For example let&#39;s convert between a wavelength and a frequency for electromagnetic radiation:  Let&#39;s start out with green light. Let&#39;s find a frequency that works using Mathematica&#39;s built-in ColorData , which knows the frequencies of the visible spectrum.  Unfortunately this can only convert from a wavelength to a color, but we can write a function to get close to the appropriate wavelength, knowing that in Mathematica a color is just RGBColor[redPercentage,greenPercentage,bluePercentage] .  First we write a distance function:      rgbDistance[color1_,color2_]:=(color1-color2)/.RGBColor-&gt;List//Norm;    Then we get the minimum distance to our given color of all the wavelengths in the visible spectrum: (for convenience I use a more complicated function declaration syntax, which is explained later)      closestWavelength[ color_, range:_List:ColorData[&quot;VisibleSpectrum&quot;][[3]], step:_?NumericQ:1 ]:=Quantity[ First@MinimalBy[ Range@@Append[range,step], rgbDistance[color,ColorData[&quot;VisibleSpectrum&quot;][#]]&amp;], &quot;Nanometers&quot;] =closestWavelength[Green] (*Out:*) 541nm    We can check that this is in fact a wavelength that corresponds to green light:      Plot[Sin[4x],{x,-,}, Axes-&gt;False, PlotStyle-&gt;ColorData[&quot;VisibleSpectrum&quot;][QuantityMagnitude@], ImageSize-&gt;Small ] (*Out:*)       Then we&#39;ll convert this to a frequency by recalling c=     =UnitConvert[Quantity[1.,&quot;SpeedOfLight&quot;]/,&quot;Hz&quot;] (*Out:*) 5.54145*10^14Hz    Another place this is incredibly useful is for simple unit conversion problems, such as a classic PV=nRT application. Here&#39;s a sample problem I found online:   Determine the volume of occupied by 2.34 grams of carbon dioxide gas at STP.    We can solve this trivially using this built-in data:      n = Quantity[2.34, &quot;Grams&quot;]/ChemicalData[&quot;CarbonDioxide&quot;, &quot;MolarMass&quot;]; P = Quantity[1, &quot;Atmospheres&quot;]; T = Quantity[273, &quot;Kelvins&quot;]; R = Quantity[&quot;MolarGasConstant&quot;]; V = UnitConvert[n*R*T/P, &quot;Liters&quot;] (*Out:*) 1.1911L    It performs all the tedious conversions and has all the data. All we need to do is supply the formula.
    </description>
    <guid>https://www.wolframcloud.com/objects/b3m2a1/tutorial/using-mathematica/useful-features/builtin-data-and-units.html</guid>
    <pubDate>Wed 18 Jul 2018 23:43:14</pubDate>
  </item>
  </channel>
</rss>
