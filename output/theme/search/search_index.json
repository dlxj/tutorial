{
	"pages":[
		{
			"title":"Trott-Strzebonski",
			"text":"‌   Trott-Strzebonski (replace with evaluation)  \nThis is the pattern we saw earlier for replacing a part of an expression with an evaluated expression:      Hold[holdReplace]\/.{holdReplaceWith[{eval=∫ 2 π Sin[θ]θ},eval\/;True]}        (*Out:*) Hold[1+Cos[2]]    \nIt is a nice trick to keep in mind for those cases when you need to insert something into a held context and it would be too much of a pain to wrap everything in a With .  \nThis pattern is really a side-effect of the way scoping constructs work in Mathematica. By placing a Condition (\/;) at the end of a scoping construct the whole construct evaluates or not depending on that condition.  \nWe take advantage of the fact that the scoping construct will always scan to the end if there is a condition there, plus the fact that With inserts values, not symbols, to force the evaluated chunk of code to be inserted in our otherwise unevaluated structure.",
			"tags":"tricks trott-strzebonski",
			"url":"mathematica-programming\/assorted-tricks\/trottstrzebonski.html",
			"note":""
		},
		{
			"title":"Villegas-Gayley",
			"text":"‌   Villegas-Gayley (internal function overloads)  \nThis is a way we can assign definitions to built-in functions cleanly. This takes advantage of a two main things, a conditional definition and the power of Block . We’ll use it to overload how MessageName works.      Unprotect@MessageName; (MessageName[o_,a:Except[\"usage\"]]\/;!TrueQ@$recursionBreakingVariable):= If[ MatchQ[o,object[_Association]], First[o][a], Block[{$recursionBreakingVariable=True}, MessageName[o,a] ] ]; Protect@MessageName;    \nNow we can do fun things with the MessageName operator, ::     object[<|\"a\"b,\"c\"d,\"e\"f|>]::a (*Out:*) b    \nUsually that would have thrown an error:      abject[<|\"a\"b,\"c\"d,\"e\"f|>]::a    \n  Message::name:   Message name MessageName[abject[Association[\"a\"->b,\"c\"->d,\"e\"->f]],\"a\"] is not of the form symbol::name or symbol::name::language.       (*Out:*) MessageName[abject[Association[\"a\"b,\"c\"d,\"e\"f]],\"a\"]    \nAnd the reason we did this the way we did is because if we assigned some object to a variable, variable::a would give us something meaningless. See:      variable=abject[<|\"a\"b,\"c\"d,\"e\"f|>]; variable::a (*Out:*) variable::a    \nBut if it’s an object it will be treated differently:      variable=object[<|\"a\"b,\"c\"d,\"e\"f|>]; variable::a (*Out:*) b    \nAnd because of the structure of the overload, MessageName still works normally in every other case.",
			"tags":"tricks villegas-gayley",
			"url":"mathematica-programming\/assorted-tricks\/villegasgayley.html",
			"note":""
		},
		{
			"title":"Import and ReadList",
			"text":"‌   Import and ReadList  \nImport has a peculiar feature. It requires vastly more memory than the size of the file being imported, which can lead to nasty behavior, sometimes. To get around this one would think of importing line-by-line as one does in python or C++ and the ReadLine function seems perfect for the job.  \nUnfortunately ReadLine is horrendously slow. So the better thing to do is to use ReadList , line, by line on an InputStream object.  \nFor example, let’s make an input stream from the following URL:      textFile=URLDownload[ \"https:\/\/www.w3.org\/TR\/PNG\/iso_8859-1.txt\", FileNameJoin@{$TemporaryDirectory,\"read_list_example.txt\"} ]; textStream=OpenRead@textFile (*Out:*)       \nNow let’s read some lines using ReadLine and do the same with ReadList and compare the performance:      AbsoluteTiming@ Table[ ReadLine@textStream, 25] (*Out:*) {0.001708`,{\"The following are the graphical (non-control) characters defined by\",\"ISO 8859-1 (1987). Descriptions in words aren't all that helpful,\",\"but they're the best we can do in text. A graphics file illustrating\",\"the character set should be available from the same archive as this\",\"file.\",\"Hex Description Hex Description\",\"20 SPACE\",\"21 EXCLAMATION MARK A1 INVERTED EXCLAMATION MARK\",\"22 QUOTATION MARK A2 CENT SIGN\",\"23 NUMBER SIGN A3 POUND SIGN\",\"24 DOLLAR SIGN A4 CURRENCY SIGN\",\"25 PERCENT SIGN A5 YEN SIGN\",\"26 AMPERSAND A6 BROKEN BAR\",\"27 APOSTROPHE A7 SECTION SIGN\",\"28 LEFT PARENTHESIS A8 DIAERESIS\",\"29 RIGHT PARENTHESIS A9 COPYRIGHT SIGN\",\"2A ASTERISK AA FEMININE ORDINAL INDICATOR\",\"2B PLUS SIGN AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\",\"2C COMMA AC NOT SIGN\",\"2D HYPHEN-MINUS AD SOFT HYPHEN\",\"2E FULL STOP AE REGISTERED SIGN\",\"2F SOLIDUS AF OVERLINE\",\"30 DIGIT ZERO B0 DEGREE SIGN\",\"31 DIGIT ONE B1 PLUS-MINUS SIGN\",\"32 DIGIT TWO B2 SUPERSCRIPT TWO\"}} AbsoluteTiming@ Table[ ReadList[textStream,String,1], 25] {0.00014`,{ {\"33 DIGIT THREE B3 SUPERSCRIPT THREE\"},{\"34 DIGIT FOUR B4 ACUTE ACCENT\"},{\"35 DIGIT FIVE B5 MICRO SIGN\"},{\"36 DIGIT SIX B6 PILCROW SIGN\"},{\"37 DIGIT SEVEN B7 MIDDLE DOT\"},{\"38 DIGIT EIGHT B8 CEDILLA\"},{\"39 DIGIT NINE B9 SUPERSCRIPT ONE\"},{\"3A COLON BA MASCULINE ORDINAL INDICATOR\"},{\"3B SEMICOLON BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\"},{\"3C LESS-THAN SIGN BC VULGAR FRACTION ONE QUARTER\"},{\"3D EQUALS SIGN BD VULGAR FRACTION ONE HALF\"},{\"3E GREATER-THAN SIGN BE VULGAR FRACTION THREE QUARTERS\"},{\"3F QUESTION MARK BF INVERTED QUESTION MARK\"},{\"40 COMMERCIAL AT C0 CAPITAL LETTER A WITH GRAVE\"},{\"41 CAPITAL LETTER A C1 CAPITAL LETTER A WITH ACUTE\"},{\"42 CAPITAL LETTER B C2 CAPITAL LETTER A WITH CIRCUMFLEX\"},{\"43 CAPITAL LETTER C C3 CAPITAL LETTER A WITH TILDE\"},{\"44 CAPITAL LETTER D C4 CAPITAL LETTER A WITH DIAERESIS\"},{\"45 CAPITAL LETTER E C5 CAPITAL LETTER A WITH RING ABOVE\"},{\"46 CAPITAL LETTER F C6 CAPITAL LETTER AE\"},{\"47 CAPITAL LETTER G C7 CAPITAL LETTER C WITH CEDILLA\"},{\"48 CAPITAL LETTER H C8 CAPITAL LETTER E WITH GRAVE\"},{\"49 CAPITAL LETTER I C9 CAPITAL LETTER E WITH ACUTE\"},{\"4A CAPITAL LETTER J CA CAPITAL LETTER E WITH CIRCUMFLEX\"},{\"4B CAPITAL LETTER K CB CAPITAL LETTER E WITH DIAERESIS\"}}}    \nYou’ll notice the performance is drastically different. Even getting the proper text has no discernible effect.      AbsoluteTiming@ Table[ First@ReadList[textStream,String,1], 25] (*Out:*) {0.000126`,{\"4C CAPITAL LETTER L CC CAPITAL LETTER I WITH GRAVE\",\"4D CAPITAL LETTER M CD CAPITAL LETTER I WITH ACUTE\",\"4E CAPITAL LETTER N CE CAPITAL LETTER I WITH CIRCUMFLEX\",\"4F CAPITAL LETTER O CF CAPITAL LETTER I WITH DIAERESIS\",\"50 CAPITAL LETTER P D0 CAPITAL LETTER ETH (Icelandic)\",\"51 CAPITAL LETTER Q D1 CAPITAL LETTER N WITH TILDE\",\"52 CAPITAL LETTER R D2 CAPITAL LETTER O WITH GRAVE\",\"53 CAPITAL LETTER S D3 CAPITAL LETTER O WITH ACUTE\",\"54 CAPITAL LETTER T D4 CAPITAL LETTER O WITH CIRCUMFLEX\",\"55 CAPITAL LETTER U D5 CAPITAL LETTER O WITH TILDE\",\"56 CAPITAL LETTER V D6 CAPITAL LETTER O WITH DIAERESIS\",\"57 CAPITAL LETTER W D7 MULTIPLICATION SIGN\",\"58 CAPITAL LETTER X D8 CAPITAL LETTER O WITH STROKE\",\"59 CAPITAL LETTER Y D9 CAPITAL LETTER U WITH GRAVE\",\"5A CAPITAL LETTER Z DA CAPITAL LETTER U WITH ACUTE\",\"5B LEFT SQUARE BRACKET DB CAPITAL LETTER U WITH CIRCUMFLEX\",\"5C REVERSE SOLIDUS DC CAPITAL LETTER U WITH DIAERESIS\",\"5D RIGHT SQUARE BRACKET DD CAPITAL LETTER Y WITH ACUTE\",\"5E CIRCUMFLEX ACCENT DE CAPITAL LETTER THORN (Icelandic)\",\"5F LOW LINE DF SMALL LETTER SHARP S (German)\",\"60 GRAVE ACCENT E0 SMALL LETTER A WITH GRAVE\",\"61 SMALL LETTER A E1 SMALL LETTER A WITH ACUTE\",\"62 SMALL LETTER B E2 SMALL LETTER A WITH CIRCUMFLEX\",\"63 SMALL LETTER C E3 SMALL LETTER A WITH TILDE\",\"64 SMALL LETTER D E4 SMALL LETTER A WITH DIAERESIS\"}}    \nNow this file is a text file that contains hex integer-description pairs, so let’s pull these out as rules. We’ll do this using patterns, Reap and Sow . Note that the relevant data looks like “<key> description” so we’ll use StringReplace on that pattern.      Replace[ Reap@Do[ With[{f=ReadList[textStream,String,1]}, If[MatchQ[f,{}], Replace[ ReadLine@textStream,{ EndOfFile:>Return[], s_String StringReplace[s, key__~~\" \"~~desc__~~(\" \"|EndOfString)Sow@{key,desc}] }], StringReplace[First@f, key:(Except[\" \"]..)~~\" \"~~desc:Shortest[__]~~(\" \"|EndOfString)Sow@{key,desc}] ]], ∞ ], {_,{data_}}data ] { {\"65\",\"SMALL LETTER E\"},{\"E5\",\"SMALL LETTER A WITH RING ABOVE\"},{\"66\",\"SMALL LETTER F\"},{\"E6\",\"SMALL LETTER AE\"},{\"67\",\"SMALL LETTER G\"},{\"E7\",\"SMALL LETTER C WITH CEDILLA\"},{\"68\",\"SMALL LETTER H\"},{\"E8\",\"SMALL LETTER E WITH GRAVE\"},{\"69\",\"SMALL LETTER I\"},{\"E9\",\"SMALL LETTER E WITH ACUTE\"},{\"6A\",\"SMALL LETTER J\"},{\"EA\",\"SMALL LETTER E WITH CIRCUMFLEX\"},{\"6B\",\"SMALL LETTER K\"},{\"EB\",\"SMALL LETTER E WITH DIAERESIS\"},{\"6C\",\"SMALL LETTER L\"},{\"EC\",\"SMALL LETTER I WITH GRAVE\"},{\"6D\",\"SMALL LETTER M\"},{\"ED\",\"SMALL LETTER I WITH ACUTE\"},{\"6E\",\"SMALL LETTER N\"},{\"EE\",\"SMALL LETTER I WITH CIRCUMFLEX\"},{\"6F\",\"SMALL LETTER O\"},{\"EF\",\"SMALL LETTER I WITH DIAERESIS\"},{\"70\",\"SMALL LETTER P\"},{\"F0\",\"SMALL LETTER ETH (Icelandic)\"},{\"71\",\"SMALL LETTER Q\"},{\"F1\",\"SMALL LETTER N WITH TILDE\"},{\"72\",\"SMALL LETTER R\"},{\"F2\",\"SMALL LETTER O WITH GRAVE\"},{\"73\",\"SMALL LETTER S\"},{\"F3\",\"SMALL LETTER O WITH ACUTE\"},{\"74\",\"SMALL LETTER T\"},{\"F4\",\"SMALL LETTER O WITH CIRCUMFLEX\"},{\"75\",\"SMALL LETTER U\"},{\"F5\",\"SMALL LETTER O WITH TILDE\"},{\"76\",\"SMALL LETTER V\"},{\"F6\",\"SMALL LETTER O WITH DIAERESIS\"},{\"77\",\"SMALL LETTER W\"},{\"F7\",\"DIVISION SIGN\"},{\"78\",\"SMALL LETTER X\"},{\"F8\",\"SMALL LETTER O WITH STROKE\"},{\"79\",\"SMALL LETTER Y\"},{\"F9\",\"SMALL LETTER U WITH GRAVE\"},{\"7A\",\"SMALL LETTER Z\"},{\"FA\",\"SMALL LETTER U WITH ACUTE\"},{\"7B\",\"LEFT CURLY BRACKET\"},{\"FB\",\"SMALL LETTER U WITH CIRCUMFLEX\"},{\"7C\",\"VERTICAL LINE\"},{\"FC\",\"SMALL LETTER U WITH DIAERESIS\"},{\"7D\",\"RIGHT CURLY BRACKET\"},{\"FD\",\"SMALL LETTER Y WITH ACUTE\"},{\"7E\",\"TILDE\"},{\"FE\",\"SMALL LETTER THORN (Icelandic)\"},{\"FF\",\"SMALL LETTER Y WITH DIAERESIS\"}}    \nThere’s a lot of boiler plate here, but I’ll leave it up to you to make a macro that will deal with all of that for any future imports.  \nJust remember, when one has to process a large file or needs a special import mechanism, this is often the best way to do it, otherwise a simple Import is likely fastest--although there are cases where this does not hold, and if a file takes particularly long to load, using a ReadList can be faster.",
			"tags":"tricks import readlist",
			"url":"mathematica-programming\/assorted-tricks\/import-and-readlist.html",
			"note":""
		},
		{
			"title":"CurrentValue and FrontEndTokens",
			"text":"‌   CurrentValue and FrontEndTokens  \nAs mentioned briefly under Highly Useful Functionality ▸ Kernels and Remote Computations Mathematica has a device called a FrontEndToken for accessing front end methods and information.    FrontEndToken  \nIn general, how this is structured is the following:      FrontEndToken[token_String]    \nor      FrontEndToken[feobject_,token_String]    \nAnd then the front end is actually accessed via FrontEndExecute . We can use this to, say, copy the previous cell as plaintext and paste it:      SelectionMove[PreviousCell@PreviousCell[],All,Cell]; FrontEndTokenExecute[\"CopySpecial\",\"Text\"]; SelectionMove[EvaluationCell[],After,Cell]; FrontEndTokenExecute[\"Paste\"];    \nVia front end tokens, it’s possible to do pretty much everything the front end can. A somewhat exhaustive list of them is presented below:      (*Out:*)       \nEach button in that list executes FrontEndTokenExecute[token] so test them out for yourself. Beware that many might be dangerous.  \nYou may know or recall that there are a series of event specifications that can be passed to EventHandler , CellEventActions , NotebookEventActions , and FrontEndEventActions . There are a number of documented event specifications, but there is one critical class of these that is missing. It looks like this:      {\"MenuCommand\",token_}    \nThis catches the front end event called by FrontEndTokenExecute[token] . Among the many uses of this, it can be used for changing the way an InputField evaluates using the \"HandleShiftReturn\" token:      validationFunction[variable_]:= (variable=StringReplace[variable,Except[DigitCharacter]->\"\"]); validationFunction~SetAttributes~HoldFirst; InputField[Dynamic[var],String]~EventHandler~{ {\"MenuCommand\",\"HandleShiftReturn\"}:>validationFunction[var]}    \nNow whenever you press + , validationFunction is applied. This is useful if you don’t want to put your side-effects as the second argument to Dynamic .  \nThis can also be used to make notebooks with custom actions, for, say, a save event:      CreateDocument[{ Cell[\"\",\"TopBarCell\"], Cell[\"Try saving this notebook\",\"Text\"]}, NotebookEventActions{ {\"MenuCommand\",\"Save\"} FrontEndExecute@ FrontEnd`AttachCell[ First@Cells[], Cell[TextData[{\"Notebook cannot be saved via the front end. Try \",ToBoxes@Unevaluated@Style[NotebookSave[],\"Input\"]}],\"Text\",FontColorRed], {Automatic,{Left,Bottom}}, {Left,Top}, \"ClosingActions\"{\"OutsideMouseClick\"} ], {\"MenuCommand\",\"SaveRename\"} FrontEndExecute@ FrontEnd`AttachCell[ First@Cells[], Cell[TextData[{\"Notebook cannot be deleted via the front end. Try \",ToBoxes@Unevaluated@Style[NotebookClose[],\"Input\"]}],\"Text\",FontColorRed], {Automatic,{Left,Bottom}}, {Left,Top}, \"ClosingActions\"{\"OutsideMouseClick\"} ] }, StyleDefinitions Notebook[{ Cell[StyleData[StyleDefinitions\"Default.nb\"]], Cell[StyleData[\"TopBarCell\"], CellMargins{ {0, 0}, {15, 0}}, CellFrame{ {0,0},{2,0}}, \"CellFrameStyle\"GrayLevel[.8], BackgroundGrayLevel[.9] ] }], WindowSize{500,400}]     CurrentValue  \nIn many ways, CurrentValue is just a wrapper to Options , SetOptions , and FrontEndToken but this makes it powerful.  \nFor instance, we can use it to query style options:      CurrentValue@{\"StyleDefinitions\",\"Section\",\"Background\"} (*Out:*)       \nFigure out what the current selection in a notebook is (restricted to content):      SelectionMove[EvaluationCell[],All,CellContents]; CurrentValue@\"SelectionData\" (*Out:*) RowBox[{RowBox[{RowBox[{\"SelectionMove\",\"[\",RowBox[{RowBox[{\"EvaluationCell\",\"[\",\"]\"}],\",\",\"All\",\",\",\"CellContents\"}],\"]\"}],\";\"}],\" \",RowBox[{\"CurrentValue\",\"@\",\"\\\"SelectionData\\\"\"}]}]    \nAnd determine whether a modifier key is pressed or not:      Dynamic@CurrentValue[\"ShiftKey\"]    \nIt can also be used to set options:      CurrentValue[EvaluationCell[],\"Background\"]=RandomColor[]; Pause[.5]; CurrentValue[EvaluationCell[],\"Background\"]=None;",
			"tags":"tricks current-value front-end front-end-tokens",
			"url":"mathematica-programming\/assorted-tricks\/currentvalue-and-frontendtokens.html",
			"note":""
		},
		{
			"title":"Info Scraping",
			"text":"‌   Info Scraping  \nMathematica, being so symbolic, is a particularly easy language to scrape and get information from, particularly given the rich pattern language it supports.  \nBecause of this, we can learn a lot by simply pulling relevant info from the source files of the program. First we need a way to get the source files:      internalFiles[namePattern_,directoryExtensions___,depth:_Integer|∞:∞]:= FileNames[namePattern, FileNameJoin@{ $InstallationDirectory, directoryExtensions }, depth];    \nThen we can pull things from these according to a pattern:      expressionsSearch[pat_,files__]:= Table[ f->Quiet@ Cases[ Switch[FileExtension@f, \"m\"|\"wl\", Import[f,\"HeldExpressions\"], _, Import[f] ], pat, ∞ ], {f,Replace[Hold[files], Except@Hold[_List]internalFiles[files] ]} ]\/\/DeleteDuplicates;    \nWe’ll use this to figure out how CurrentValue is used in Mathematica’s built-in stylesheets:      Join@@Last\/@expressionsSearch[c:_CurrentValueHoldForm[c], \"*.nb\",\"SystemFiles\",\"FrontEnd\",\"StyleSheets\"]\/\/DeleteDuplicates\/\/Sort (*Out:*) {CurrentValue[\"ControlsFontFamily\"],CurrentValue[\"ControlsFontSize\"],CurrentValue[\"HyperlinkModifierKey\"],CurrentValue[\"MenuFontFamily\"],CurrentValue[\"MenuFontSize\"],CurrentValue[\"MouseOver\"],CurrentValue[\"PanelBackground\"],CurrentValue[\"PanelFontFamily\"],CurrentValue[\"PanelFontSize\"],CurrentValue[\"ShiftKey\"],CurrentValue[\"ToolbarBackground\"],CurrentValue[\"TooltipFontFamily\"],CurrentValue[\"TooltipFontSize\"],CurrentValue[\"TooltipFrameMargins\"],CurrentValue[Enabled],CurrentValue[Evaluatable],CurrentValue[{\"SystemColor\",\"DialogText\"}],CurrentValue[{\"SystemColor\",\"DialogTextDisabled\"}],CurrentValue[{\"SystemColor\",\"Menu\"}],CurrentValue[{\"SystemColor\",\"MenuText\"}],CurrentValue[{\"SystemColor\",\"Tooltip\"}],CurrentValue[{\"SystemColor\",\"TooltipFrame\"}],CurrentValue[{\"SystemColor\",\"TooltipText\"}],CurrentValue[{StyleHints,\"CodeFont\"}],CurrentValue[EvaluationNotebook[],WindowElements],CurrentValue[EvaluationNotebook[],WindowMargins],CurrentValue[EvaluationNotebook[],WindowSize],CurrentValue[EvaluationNotebook[],{AutoStyleOptions,\"StringStyle\"}],CurrentValue[EvaluationNotebook[],{TaggingRules,\"ExampleCounter\"}],CurrentValue[EvaluationNotebook[],{TaggingRules,\"SlideShowSettings\",\"WindowSize\"}]}    \nThere’s a lot of info in the source files and by doing things like this you can mine a lot of it.",
			"tags":"tricks scraping",
			"url":"mathematica-programming\/assorted-tricks\/info-scraping.html",
			"note":""
		},
		{
			"title":"Object Oriented Programming",
			"text":"‌   Object Oriented Programming  \nMathematica is a functional programming language, which, for the purposes of the current discussion, basically means that everything has a purely symbolic representation. Often we talk about things not have state which is to say, they don’t have attributes.  \nThis makes Mathematica code very deterministic and results easy to store, but sometimes using something with state can be useful. We call these things with state objects and so programming with things with state is called object oriented programming (OOP).  \nThis is a very powerful programming paradigm and, in fact, the (probably) most popular languages are all object-oriented. Java, Python, and C++ all make extensive use of objects in the form of classes, instances, templates, interfaces, etc.  \nWe can work OOP into our standard Mathematica programming, although it can be a tough job to do.    Association Interfaces  \nThe simplest and probably most widely used form of OOP in Mathematica isn’t true OOP. We still have symbolic stateless objects, but, critically, it looks like they have state.  \nThe basic idea is that our object will be defined by an association, then we’ll give it a head so that it can be easily distinguished for pattern matching and operator overloading.  \nWe’ll do this for an object called SphereObject  \nFirst, we need a nice way to make a new one of these:      SphereObject[attrs:(_Rule|_RuleDelayed...)]:= SphereObject[ Merge[{<|\"Radius\"1,\"Color\"White,\"Position\"{0,0,0}|>,<|attrs|>},First] ];    \nThen we’ll need a way to set and get attributes. We’ll do this via SubValues . To be extra fancy, we’ll also write it so that if our returned argument is a Function , that gets called with the object and passed arguments:      SphereObject[attrs_Association][k_,args___]:= With[{r=attrs[k]}, If[MatchQ[r,_Function], r[SphereObject[attrs],args], r ] ];    \nThen do something for setting \/ removing attributes with UpValues :      SphereObject\/:HoldPattern[ Set[SphereObject[attrs_Association][k_],v_] ]:=SphereObject[Append[attrs,k->v]]; SphereObject\/:HoldPattern[ SetDelayed[SphereObject[attrs_Association][k_],v_] ]:=SphereObject[Append[attrs,k:>v]]; SphereObject\/:HoldPattern[ Unset[SphereObject[attrs_Association][k_]] ]:=SphereObject[KeyDrop[attrs,k]];    \nLast, assign some Format form to the object:      Format[SphereObject[attrs_]]:= With[{ r=Replace[attrs[\"Radius\"],_Missing1], c=Replace[attrs[\"Color\"],_MissingWhite], p=Replace[attrs[\"Position\"],_Missing{0,0,0}] }, Interpretation[ Deploy@ Style[ Row@{\"SphereObject\",\"[\", Graphics3D[{c,Sphere[p,r]}, Lighting\"Neutral\", BoxedFalse, Method{\"ShrinkWrap\" -> True}], \"]\"},ShowStringCharactersFalse], SphereObject[attrs] ] ]; SphereObject[] (*Out:*)          SphereObject[\"Color\"Red] (*Out:*)       \nNote that we can pull values from these objects:        (*Out:*)       \nAnd we can set them:        (*Out:*)       \nAnd unset them        (*Out:*)       \nEach of these is really just an Association at heart, though. There is no state. These aren’t real objects.    Managed Types  \nTo get state, we have to track state. And to track state, we need some form of state manager. So we’ll take a hint from our front end objects and write our own and then define objects relative to that.  \nThis time we’ll make a StringObject  \nWe’ll start with a manager. Just an association that will track things by ever-increasing ID.      $StringObjectCounter=1; $StringObjectManager=<||>;    \nThen a constructor, once more, but this time the constructor adds an entry to the manager table:      StringObject[s:_String:\"\",styleSpecs:((_Rule|_RuleDelayed)...)]:=( $StringObjectManager[$StringObjectCounter]= <|\"String\"s,styleSpecs|>; StringObject[$StringObjectCounter++] );    \nWe’ll use the same attribute get \/ set structure as before, except this time routed through an ID:      StringObject[ID_][k_,args___]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], With[{r=attrs[k]}, If[MatchQ[r,_Function], r[StringObject[ID],args], r ] ], Missing[\"NoObject\",StringObject[ID]] ] ]; StringObject\/:HoldPattern[ Set[StringObject[ID_][k_],v_] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], $StringObjectManager[ID][k]=v, Missing[\"NoObject\",StringObject[ID]] ] ]; StringObject\/:HoldPattern[ SetDelayed[StringObject[ID_][k_],v_] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], $StringObjectManager[ID][k]:=v, Missing[\"NoObject\",StringObject[ID]] ] ]; StringObject\/:HoldPattern[ Unset[StringObject[ID_][k_]] ]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], KeyDropFrom[$StringObjectManager[ID],k];, Missing[\"NoObject\",StringObject[ID]] ] ];    \nAnd build a similar format although this time we’ll want a special format if the object doesn’t exist:      Format[StringObject[ID_]]:= With[{attrs=$StringObjectManager[ID]}, If[!MatchQ[attrs,_Missing], With[{ s=Replace[attrs[\"String\"],_Missing\"\"], o=Sequence@@Normal@KeyDrop[attrs,\"String\"] }, Interpretation[ Deploy@ Style[ Row@{\"StringObject\",\"[\", Style[s, \"Output\", o, BackgroundNone, ShowStringCharactersFalse ], \"]\"},ShowStringCharactersFalse], StringObject[ID] ] ], Unevaluated[StringObject[ID]] ] ];    \nThen test this:      S=StringObject[\"obj\"] (*Out:*) StringObject[8]    \nBut now it’s got state:      With[{S=S},S[FontColor]=Red] (*Out:*)          S (*Out:*) StringObject[8] With[{S=S},S[\"String\"]=\"obj_changed\"] (*Out:*) \"obj_changed\" S (*Out:*) StringObject[8]    \nAll of these are the same object, though:      InputForm \/@ {StringObject[8], StringObject[8], StringObject[8]} (*Out:*) {StringObject[8],StringObject[8],StringObject[8]}    \nThis is now an object with attributes and state, which means that within a session it is more powerful, but we can’t figure out what it looks like (attribute wise) from the symbolic form alone. Here is where our manager comes into play:      $StringObjectManager (*Out:*)       \nThis is all the string data for all of the objects we made this session. By caching this, we can retrieve the state of our system trivially.   Types as Symbol Interfaces  \nThere is one last (common) way to do object orientation. Rather than using a centralized manager, which if it gets corrupted or deleted can destroy the state of our system, we can use a symbol interface.  \nWe do this by creating a symbol where before we created an ID. In fact, this really blurs the line between a managed type and an association interface.  \nThis time we’ll outline a timer object.  \nInstead of using ID, we’ll assign an association to a symbol. This means we need to hold our symbol, though, to prevent it from evaluating. We will also want to keep track of which symbols we have used. We’ll do this via an association because lookup in associations is much faster than in lists:      $TimerObjectCache=<||>; TimerObject[]:= With[{obj=Unique@\"timer\"}, $TimerObjectCache[TimerObject[obj]]=None; obj=<| \"CheckPoint\"->Now, \"EndPoint\"->None, \"Toggle\":>( With[{o=#}, o[\"EndPoint\"]= Replace[o[\"EndPoint\"],{ None->Now, _->None }] ]&) |>; TimerObject[obj] ]; TimerObject~SetAttributes~HoldFirst; TimerObject[sym_][attr_,args___]:= With[{r=sym[attr]}, If[MatchQ[r,_Function], r[TimerObject[sym],args], r ] ]; TimerObject\/: HoldPattern[HoldPattern[Set[TimerObject[sym_][attr_],v_]]]:=(sym[attr]=v); TimerObject\/: HoldPattern[SetDelayed[TimerObject[sym_][attr_],v_]]:=(sym[attr]:=v); TimerObject\/: HoldPattern[Unset[TimerObject[sym_],attr_]]:=(sym[attr]=.); Format[TimerObject[sym_]]:= With[{ start=sym[\"CheckPoint\"], end=Replace[sym[\"EndPoint\"],NoneNow]}, Interpretation[ Deploy@Style[ Row@{\"TimerObject\",\"[\", Framed[ NumberForm[end-start,3], RoundingRadius5, BackgroundLighter[Blend@{LightBlue,Gray},.8], FrameStyleGrayLevel[.6] ],\"]\"}, ShowStringCharactersFalse ], TimerObject[sym] ] ]; t=TimerObject[] Pause[1]; t (*Out:*) TimerObject[timer17] (*Out:*) TimerObject[timer17]    \nNote that these are obviously the same object  \nAnd we can access state:      With[{t=t},t[\"Toggle\"]] (*Out:*)          t Pause[1]; t (*Out:*) TimerObject[timer17] (*Out:*) TimerObject[timer17] t[\"EndPoint\"] (*Out:*)       \nThis is a more powerful method that using a manager and it’s harder to accidentally delete one’s data. Unfortunately, saving state is somewhat harder, though. This is why we tracked our objects built.      With[{objs=$TimerObjectCache\/\/Keys}, #ReleaseHold@#&\/@(HoldForm@@@objs) ] (*Out:*)       \nWe now have to save all of these definitions but it is doable.    Summary  \nThe order in which we’ve seen these object management structures more or less corresponds to their order of flexibility and also complexity.  \nUsing a state-less object-like wrapper (an interface to an association, basically) is easier but less flexible than using objects that reference an object manager, which are in turn harder to use and less powerful than objects that track their own state.  \nMoreover, this is just a primer on making objects. Languages such as Java, Python, and C++ have a much richer object interface, including classes, instances, interfaces, templates, etc. To implement all of that is beyond the scope of this tutorial, but the tools we have here are actually sufficient to do so (at least for classes and instances).  \nIn general, though, it is best to use the object you need for the project you need, until you’re comfortable enough to build a more general architecture.",
			"tags":"tricks object-oriented-programming",
			"url":"mathematica-programming\/assorted-tricks\/object-oriented-programming.html",
			"note":""
		},
		{
			"title":"Scoping Revisited",
			"text":"‌   Scoping Revisited   With, Module, and Block  \nWe finally have enough knowledge to understand the differences between the scoping constructs. We’ll start by writing the same chunk of code with each:      Module[{a=35}, a^2 ] (*Out:*) 1225 With[{a=35}, a^2 ] (*Out:*) 1225 Block[{a=35}, a^2 ] (*Out:*) 1225    \nEverything is normal as of now. So let’s try introducing some held expressions:      Module[{a=35}, a^2\/\/Hold ]        Hold[a$2424 2 ]        With[{a=35}, a^2\/\/Hold ]        Hold[35 2 ]        Block[{a=35}, a^2\/\/Hold ]        Hold[a 2 ]     \nThis alone should help in figuring out what is going on:  \nModule creates a new symbol with $ModuleNumber appended With inserts the given values into the expression  \nBut what is Block doing? Nothing seems changed.  \nLet’s look at a different example, just considering Module and Block as there is little more to discuss with With , although it should be noted that With is the cleanest and most useful of all these constructs.  \nLet’s try define a global function:      scopeProbe[x_]:=x*b;    \nFirst let’s use it inside Module     Module[{b=35}, scopeProbe[10] ] (*Out:*) 10 b    \nThis behavior makes perfect sense. The b defined in Module is not the global b so this is what we’d predict.      Block[{b=35}, scopeProbe[10] ] (*Out:*) 350    \nThis here is the critical difference between Module and Block . Block reassigns the values of its symbols temporarily, while Module makes new symbols with temporary values (they have been given the attribute Temporary ).  \nThis makes Block incredibly useful, but also potentially dangerous. Names used as variables to Block should always be made unique enough such that it’s unlikely they’ll have been used in a function that will be called by the Block .  \nAn example of how we can use this is in memoization for a recursive function:      recursiveFunction[arg_]:=Block[{`recursiveFunction`memoPad=<||>}, recursiveStep[arg] ]; recursiveStep[arg_]:= If[!KeyMemberQ[`recursiveFunction`memoPad,arg], `recursiveFunction`memoPad[arg]=If[Length@arg==0, Pause[.5]; Total@ToCharacterCode@ToString@arg, recursiveStep\/@(List@@arg)\/\/Total ], `recursiveFunction`memoPad[arg] ];    \nAnd to see that this is doing what we expect      recursiveFunction[a[a,a,a,a,a]]\/\/AbsoluteTiming (*Out:*) {0.500925`,485}    \nWhile without memoization this should take about 2.5 seconds:      recursiveNoMemo[arg_]:=If[Length@arg==0, Pause[.5]; Total@ToCharacterCode@ToString@arg, recursiveNoMemo\/@(List@@arg)\/\/Total ] recursiveNoMemo[a[a,a,a,a,a]]\/\/AbsoluteTiming (*Out:*) {2.506773`,485}    \nAnd just to check that we the Block wrapper does something:      recursiveStep@a[a,a,a,a,a]    \n  KeyMemberQ::invas:   The argument Global recursiveFunction memoPad is not a valid Association or rule.       (*Out:*) If[!KeyMemberQ[Global`recursiveFunction`memoPad,a[a,a,a,a,a]],Global`recursiveFunction`memoPad[a[a,a,a,a,a]]=If[Length[a[a,a,a,a,a]]0,Pause[0.5`];Total[ToCharacterCode[ToString[a[a,a,a,a,a]]]],Total[recursiveStep\/@List@@a[a,a,a,a,a]]],Global`recursiveFunction`memoPad[a[a,a,a,a,a]]]",
			"tags":"scoping",
			"url":"mathematica-programming\/code-structure\/scoping-revisited.html",
			"note":""
		},
		{
			"title":"Flow Control",
			"text":"Mathematica, being primarily a functional programming language, doesn't use standard flow-control techniques such as While , Break , Continue , etc . to the same degree that a primarily procedural language like python does.  \nDespite that, these are still useful things to know how to work with. We'll go through them pretty quickly, one-by-one.    While  \nOf all of these, While is likely the most common to be used, although as mentioned previously it can be emulated perhaps more cleanly by Do with Infinity as the iterator spec.  \nOn the other hand, particularly in the context of Compile or other cases where a predominantly procedural paradigm is use, While can be useful.    For  \nFor is never useful. Any time it could be used Table or Do would be a better choice.    Break \/ Continue \/ Return  \nAs noted, For isn't useful, which renders moot the primary use case of Break and Continue . They can potentially still be useful in Do and Table , though.  \nAll Mathematica functions have an implicit Return in them, which makes use of Return infrequent, but it has its place. Especially when there are multiple possible points of exit from a function Return can be highly useful.  \nIt also helpfully has a second argument specifying the scope from which the value should be returned, which can allow for somewhat more targeted usage in, say Do .  \nSimilarly, FixedPoint and other nested functional programming constructs provide support for Return , Break , and potentially Continue .",
			"tags":"flow-control",
			"url":"mathematica-programming\/code-structure\/flow-control.html",
			"note":""
		},
		{
			"title":"Error Handling",
			"text":"‌   Error Handling  \nAs we noted before, errors in Mathematica are much more subtle than in many languages.  \nThere is no compiler, so nothing will warn you about compile-time errors, and there is no real concept of an automatic runtime error—i.e. there is nothing in the language enforcing any type of strict semantics. Because of this we need to be particularly careful about validating errors ourselves.  \nWhen we catch one of these errors we then have the question of what to do with it. We'll work through this in order of least-to-most suggested.    Abort  \nWhen an error is caught, we could simply do as most programming languages do and simply abort the calculation, in this case via the function Abort .  \nThe problem with this is that it is a potential overreaction as if we are producing code that others will use, this Abort will be passed up into any of their functions, too.    Message  \nThe standard way Mathematica functions handle cases like this is by emitting a Message and then returning some type of failure tag, e.g. something like this:      Integrate[x, {1, 10}]    \n  Integrate::ilim:   Invalid integration variable or limit(s) in {1,10}.       (*Out:*) Integrate[x,{1,10}]    \nSince this was an unhandled-arguments type of error, the function simply bottoms out and says: \"I'm going to stay unevaluated\".  \nFor those interested, this type of behaviour most commonly occurs when a Condition is failed in either the pattern test of the function arguments or if a Condition is found at the end of a scoping construct, e.g.:      doNothing[]:= Module[ {}, doNothing::no=\"Nope :)\"; \"Something!\"\/;If[\"Something\"=!=Nothing, Message[doNothing::no], True] ] doNothing[]    \n  doNothing::no:   \"Nope :)\"       (*Out:*) doNothing[]    \nIf Abort is too much, this approach is too little. An error caught deep inside a function shouldn't have to be passed step-by-step up through the rest of the function.    Throw \/ Catch  \nThe Throw \/ Catch mechanism provides a much more robust way to handle errors in Mathematica. Catch takes a second argument that can be a pattern to catch the different error tags that Throw can attach to its results. By doing this we can get deeply-nested functions to throw to high-level and be caught only by the handlers we want, for instance we can do something like:      main[]:= NumberForm[Catch[{sub1[], sub2[], sub3[]}, \"err1\"|\"err2\"|\"err3\"], 3] sub1[]:= If[#<.25, Throw[StringForm[\"`` too large\", #], \"err1\"], #]&@RandomReal[] sub2[]:= If[#<.5, Throw[StringForm[\"`` two large\", #], \"err2\"], #]&@RandomReal[] sub3[]:= If[#<.75, Throw[StringForm[\"`` three large\", #], \"err3\"], #]&@RandomReal[]    \nAnd when we use this:      ToString\/@Table[main[], 10] (*Out:*) {\"0.137 two large\",\"0.18 too large\",\"0.704 three large\",\"0.18 too large\",\"0.0282 three large\",\"0.463 three large\",\"0.0129 too large\",\"0.634 three large\",\"0.104 too large\",\"0.464 two large\"}    \nWe see that the different errors were caught, each with their messages, and we didn't have to catch and pass up on each round.    Standardized Error Handling  \nWe can combine these approaches to make a more robust approach to error handling. We'll use Message to tell the user about the source of the error, Throw and Catch to pass the error to top-level cleanly, and finally we'll use the Failure object to capture the message feed them to Throw .  \nWe can go one step further, though, and allow any exceptions caught by Catch to optionally be passed up  \nHere's a sample way this could work:      Protect[$$tagStack]; catchExceptions[expr_, tags:{___}, passUp:True|False:True]:= Block[ { $$tagStack= If[ListQ@$$tagStack, {Join@@$$tagStack, tags}, {{}, tags}] }, Catch[expr, Alternatives@@tags, If[passUp, If[MemberQ[First@$$tagStack, #2], Throw[##], # ]&, #& ] ] ]; catchExceptions~SetAttributes~HoldFirst; raiseException[HoldPattern[msg:MessageName[sym_, tag_, ___]], params___]:= ( Message[msg, params]; Throw[ Failure[tag, <|\"MessageTemplate\":>msg, \"MessageParameters\"->{params}|>], tag ] ); raiseException~SetAttributes~HoldFirst;    \nWe create a function that sets up a stack of tags being checked for, calls Catch with the set of currently tracked tags, if the error is caught, it conditionally checks whether the tag is in the head of the stack and if so passes it up.  \nNext we take a function that will Throw to this Catch block and return a nice structure to go with it.  \nHere's this in action:      myCoolFunction::err1=\"Uh oh spaghetti-Os!\"; myCoolFunction::err2=\"Oh deary me!\"; myCoolFunction::err3=\"Why did you do this to me ``?\"; myCoolFunction[name_]:= catchExceptions[ winAwards@ callMeBy@ yourName@name, {\"err1\", \"err2\", \"err3\"} ]; winAwards[movie_]:= If[!StringQ@movie, raiseException[myCoolFunction::err1], StringForm[\"`` won an award!\", movie] ]; callMeBy[name_]:= If[RandomReal[]<.5, raiseException[myCoolFunction::err2], \"Call Me By \"<>name\/\/Quiet ]; yourName[name_]:= If[StringQ@name&&StringFreeQ[name, \" \"], raiseException[myCoolFunction::err3, name], name ];    \nAnd now we can use it on some examples:      myCoolFunction\/@ Join[ StringRiffle@*DeleteDuplicates\/@ Tuples[EntityValue[RandomEntity[\"GivenName\", 2], \"Label\"], 2], {1} ]    \n  myCoolFunction::err3:   Why did you do this to me \"Icelyn\"?    \n  myCoolFunction::err2:   \"Oh deary me!\"    \n  myCoolFunction::err3:   Why did you do this to me \"Shota\"?    \n  myCoolFunction::err1:   \"Uh oh spaghetti-Os!\"       (*Out:*)       \nAnd we can nest this without end and it will always throw all the way up to top-level:      catchExceptions[ catchExceptions[myCoolFunction[1], {\"err1\", \"err2\", \"err3\"}], {\"err1\", \"err2\", \"err3\"} ]    \n  myCoolFunction::err1:   \"Uh oh spaghetti-Os!\"       (*Out:*)       \nMore extensions can be built on top of this, but this gets us a good ways beyond passing failed arguments up through our call stack.",
			"tags":"errors",
			"url":"mathematica-programming\/code-structure\/error-handling.html",
			"note":""
		},
		{
			"title":"Symbols and Expressions",
			"text":"‌   Symbols and Expressions   Symbols  \nMathematica has one more basic type than those mentioned before: Symbol  \nIn reality, every variable we’ve used and function we’ve defined (excluding pure functions) has been a symbol.  \nOne thing to keep in mind is that the only things that can have properties or values in Mathematica are symbols, although a symbol need not have any.  \nAll of the following are symbols:      Automatic AxesLabel $ModuleNumber Rule SetDelayed (*Out:*) Automatic (*Out:*) AxesLabel (*Out:*) 1205 (*Out:*) Rule (*Out:*) SetDelayed     Expressions  \nIn Mathematica, they say everything is an expression. What this means, really, is that outside of the primitive types everything has one common form:      (head)[arg1,arg2,arg2,...,argn]    \nFurthermore, there are tools to parse these structures:      {1,2,3}\/\/FullForm (*Out:*) List[1,2,3]    \nThis even applies to things like graphics. Consider the following graphic:      Graphics3D[Sphere[],BoxedFalse,Lighting\"Neutral\",ImageSizeSmall]    \nIt is, however, still just an expression:      Graphics3D[Sphere[], BoxedFalse, Lighting\"Neutral\", ImageSizeSmall ]\/\/FullForm (*Out:*) Graphics3D[Sphere[List[0,0,0]],Rule[Boxed,False],Rule[Lighting,\"Neutral\"],Rule[ImageSize,Small]]",
			"tags":"symbols expressions",
			"url":"mathematica-programming\/code-structure\/symbols-and-expressions.html",
			"note":""
		},
		{
			"title":"Expressions Structure",
			"text":"‌   Expressions Structure   Heads  \nFor any expression the part before the square brackets is known as the Head of the expression and happily there is the conveniently named Head function extract it!      Head@<|1 -> 2, 3 -> 4, 5 -> 6|> (*Out:*) Association    \nThe Head of an expression can be anything:      Head@(f[1][<|a -> b|>][3]) (*Out:*) f[1][<|a -> b|>] Head@\"a\"[b] (*Out:*) \"a\" Head@( (12 s^2)[2]) (*Out:*) 12 s^2     Parts  \nEverything following the Head in the expression is simply a part of the expression and can be extracted with the Part function:      Part[((12 s^2)[2]), 1] (*Out:*) 2 Part[{1, 2, 3}, 2] (*Out:*) 2    \nPart also has an alias [[ ]]     {1, 2, 3}[[2]] (*Out:*) 2    \nBecause so often one needs the first or last components of an expression there are two dedicated functions to getting these parts:      First@Range[10] (*Out:*) 1 Last@Range[10] (*Out:*) 10    \nThere is also the function Rest which will take the second through last parts of an expression:      Rest@(A @@ Range[10]) (*Out:*) A[2, 3, 4, 5, 6, 7, 8, 9, 10]    \nThere is also the function Take which takes spans from an expression      Take[B @@ Range[10], {3, 5}] (*Out:*) B[3, 4, 5]     Manipulating Expressions  \nMathematica also supports the manipulation of expressions through a wide series of functions, a few of which will be explained here and more which will be explained later:  \nInsert takes an expression and inserts another expression in the index specified as its third argument      Insert[{1, 2, 4}, \"Hi\", -1] (*Out:*) {1, 2, 4, \"Hi\"} Insert[A[1, 2, 4], \"Hi\", -2] (*Out:*) A[1, 2, \"Hi\", 4] Insert[Graphics3D[{Sphere[]}, ImageSize -> Small], Sphere[{2, 2, 2}, .5], {1, -1}] (*Out:*)       \nAppend and Prepend take an expression and add an element at the end and beginning respectively      Append[Graphics3D[Sphere[], ImageSize -> Small], Lighting -> \"Neutral\"] (*Out:*)       \nDelete and Drop both remove parts from an expression. Delete drops a single part:      Delete[A[1, 2, 3, 4, 5], 4] (*Out:*) A[1, 2, 3, 5]    \nDrop removes a span of parts      Drop[A[1, 2, 3, 4, 5], -2] (*Out:*) A[1, 2, 3]     Sequence  \nOften one wants to do something like stick the arguments of one expression inside another one. For this purpose there is a special Head Sequence     A[1, 2, 3, Sequence[1, 2, 3]] (*Out:*) A[1, 2, 3, 1, 2, 3]    \nOr demonstrating how to put a list inside the expression:      A[1, 2, 3, Sequence @@ {1, 2, 3}] (*Out:*) A[1, 2, 3, 1, 2, 3]    \nSequence generally represents a sequence of arguments which will be used without a Head . It is used most often in pattern matching and function definitions, but has many uses.",
			"tags":"expressions",
			"url":"mathematica-programming\/code-structure\/expressions-structure.html",
			"note":""
		},
		{
			"title":"Patterns",
			"text":"‌   Patterns   Simple Patterns  \nPatterns and how to use them might be the most important thing to understand in Mathematica  \nAt some level, due to its expression-centered structure, Mathematica is just a huge pattern matching machine  \nThe most basic pattern is just an underscore, but of course it has an expression structure:      _ \/\/ FullForm (*Out:*) Blank[]    \nWe can also provide a name for our pattern which has in various function      p_\/\/FullForm (*Out:*) Pattern[p,Blank[]]    \nYou'll notice the Blank[] remains. Blank[] matches any single expression. For pattern matching there's the function MatchQ . It will return whether the expression as in its first argument matches the pattern in its second.  \nIt doesn't have to have a pattern as its second argument though:      MatchQ[a,a] (*Out:*) True    \nBut the following will also match:      MatchQ[a,_] (*Out:*) True MatchQ[a,p_] (*Out:*) True    \nPatterns can also have a Head that must match, which is specified after the underscore.     _a\/\/FullForm (*Out:*) Blank[a]    \nWith a head all the following match:      MatchQ[a[],_a] (*Out:*) True MatchQ[a[1,2,3],_a] (*Out:*) True MatchQ[a[a[a[a[a[a[]]]]]],_a] (*Out:*) True    \nBut the following won't:      MatchQ[a,_a] (*Out:*) False    \nAlong with a head one can also specify a test condition which will be applied to the thing that's being matched against      _a?test\/\/FullForm (*Out:*) PatternTest[Blank[a],test]    \nWhich means the following will match:      MatchQ[a[1,2,3],_a?(Length@#>1&)] (*Out:*) True    \nBut the other cases will not:      MatchQ[a[],_a?(Length@#>1&)] (*Out:*) False MatchQ[a[a[a[a[a[a[]]]]]],_a?(Length@#>1&)] (*Out:*) False    \nPatterns can also be specified as parts of an expression:      MatchQ[a[1,2,3],a[_,_,_]] (*Out:*) True    \nPatterns can also be specified as matching 1 or more elements with a double underscore:      __\/\/FullForm (*Out:*) BlankSequence[] MatchQ[a[1,2,3],a[__]] (*Out:*) True MatchQ[a[],a[__]] (*Out:*) False    \nor 0 or more elements via a triple underscore:      ___\/\/FullForm (*Out:*) BlankNullSequence[] MatchQ[a[1,2,3],a[___Integer]] (*Out:*) True MatchQ[a[],a[___]] (*Out:*) True    \nEverything that applies to single element patterns applies as well to these multi-element patterns.    Complex Patterns  \nOften it's useful to be able to match more than one type. For this, there's a built-in head Alternatives , which is represented by a vertical bar |     MatchQ[10,_Integer|_String] (*Out:*) True MatchQ[\"10\",_Integer|_String] (*Out:*) True MatchQ[π,_Integer|_String] (*Out:*) False    \nAlternatives can be used with any pattern and simplifies life tremendously in describing complicated structures concisely  \nOne issue, however, is that a set of alternatives can't be matched multiple times with the double or triple underscores. To fix this issue there is Repeated ( .. ) and RepeatedNull ( ... ) which have the same meanings as ``` and _``` respectively.  \nHere's an example of matching complex structure:      MatchQ[RandomChoice[{A,B,C}]@(Sequence@@( If[RandomInteger[]==0,ToString@#,#]&\/@RandomInteger[10,RandomInteger[10]] )), (A|B|C)[(_String|_Integer)...] ] (*Out:*) True    \nIt is impossible to know ahead of time what the head will be or how many arguments there will be or whether they'll be strings or integers, but that doesn't matter. We can still represent this pattern in under one line. Yet the pattern is robust enough that by doing something like appending in a symbol, our pattern catches that:      MatchQ[Append[RandomChoice[{A,B,C}]@(Sequence@@( If[RandomInteger[]==0,ToString@#,#]&\/@RandomInteger[10,RandomInteger[10]] )),RandomChoice[{A,B,C}]], (A|B|C)[(_String|_Integer)...] ] (*Out:*) False    \nThere is one further useful addition to this current redux on patterns. Sometime you know you'll, say, see pairs of a patterns, and so a simple .. or __ isn't precise enough. For this case there is the head PatternSequence which can capture this:      MatchQ[A@@(If[OddQ@#,ToString@#,#]&\/@Range[10]), A[PatternSequence[_String,_Integer]..] ] (*Out:*) True     Except  \nThe final piece of patterns is the head Except . It specifies that anything Except the pattern inside should match. It is a negation pattern, in essence.      MatchQ[1,Except[_String]] (*Out:*) True MatchQ[<|a->b|>,Except[_String]] (*Out:*) True MatchQ[Graphics@Disk[],Except[_String]] (*Out:*) True MatchQ[\"asdasd\",Except[_String]] (*Out:*) False",
			"tags":"patterns",
			"url":"mathematica-programming\/code-structure\/patterns.html",
			"note":""
		},
		{
			"title":"Replacement Patterns",
			"text":"‌   Replacement Patterns  \nThe fundamental usage of patterns is in replacement. This is just what it sounds like. One replaces part of an expression with something else. There’s a whole family of functions built around this concept, too, and they’re some of the oldest functions in the language. They all share one parent, though    Replace  \nReplace is possibly the most fundamental function in Mathematica. It takes an expression and if it matches a pattern, replaces it with that value. For example:      Replace[{1, 2, 3}, a : {__Integer} :> Column@a] (*Out:*)       \nIf the pattern doesn’t match, nothing happens:      Replace[{1, 2, 3}, a : {RandomInteger[1000], RandomReal[1000], RandomReal[1000]} :> \"This has a 1\/1000000000 chance of being the result\" ] (*Out:*) {1, 2, 3}    \nReplace can also try a list of replacements:      Replace[{1, 2, 3}, { {_Integer, _Integer, _String} :> \"No\", {_Integer, _Integer, _List} :> \"No\", {_Integer, _Integer, _Association} :> \"No\", {_Integer, _Integer, _Integer} :> \"Yes!\", {__Integer} :> \"Yes, but won't happen\" } ] (*Out:*) \"Yes!\"    \nYou’ll notice it only matches the first pattern that fits.  \nReplace can also work at various levels of an expression:      Replace[{1, 2, \"3\", 2, 1}, i_Integer :> (\"int \" <> ToString@i), 1] (*Out:*) {\"int 1\", \"int 2\", \"3\", \"int 2\", \"int 1\"}     ReplaceAll  \nReplaceAll is the only other member of the family I’ll mention here. It works similarly to Replace , except the replacements can happen at any level of the expression. This is dangerous, but also useful.  \nAlso useful is the fact that it has a keyboard alias: \/.  \nHere’s a fun example:      GraphicsGrid[ Table[ Table[RandomInteger[100], {j, RandomInteger[{1, 6}]}], {i, RandomInteger[{3, 5}]} ] \/. i_Integer :> Graphics[{RandomColor[], Disk[]}, ImageSize -> i], Spacings -> 0 ] (*Out:*)        Replace⋆  \nThe rest of this family share the name Replace⋆ and most of them work quite like Replace , with the notable exception of ReplacePart",
			"tags":"patterns",
			"url":"mathematica-programming\/code-structure\/replacement-patterns.html",
			"note":""
		},
		{
			"title":"Functions",
			"text":"‌   Functions   Functions as Patterns  \nThe reason for that long discussion of patterns is the following: Mathematica functions (except pure functions) are just patterns. Consider the following:      f[x_]:=x*10    \nAll I’ve done here is tell the system that whenever it sees the pattern f[Blank[]] execute the right hand code, but with x replaced with the value of that Blank[] .  \nSeeing as that’s all we’re doing, though, we can also leverage the power of patterns to restrict our definition:      g[i_Integer]:=RandomInteger[i]; g[s_String]:=RandomChoice@Characters@s; g[{v_,___}]:=g[v];    \nNow we have a function g that can vary depending on its arguments.      g\/@{10,\"my word!\",{g,c,d}} (*Out:*) {2,\"w\",g[g]}    \nOne thing worth noting is that if a multi-element pattern is matched, the values are substituted as the arguments of the enclosing head, but if the values themselves are returned they are wrapped in Sequence for consistency. For instance:      g[s___]:={Hold[s], ListPlot[{s}]}; g[1,2,3,2,1,2,3,4] (*Out:*)          g2[s___]:=s; g2[1,2,3,2,1] (*Out:*) Sequence[1,2,3,2,1]     Named Patterns, Optional and Disappearing Arguments  \nA Pattern can be declared without any underscores by following it with a colon. This is useful in function declarations when you want to get the value of a complicated pattern element, for instance:      h[a:(_Integer|_String|π)]:=Head@a; h[_]:=2 h\/@{1,\"1\",π,h,{\"H\",\"i\",\"M\",\"o\",\"m\",\"!\"}} (*Out:*) {Integer,String,Symbol,2,2}    \nPattern has a cousin, however, called Optional who also uses a colon, but who can only be called on top of an existing Pattern :      a:_:Automatic\/\/FullForm (*Out:*) Optional[Pattern[a,Blank[]],Automatic]    \nMatchQ works with Optional by just matching the pattern beneath      MatchQ[1,a:_Integer|_String:Automatic] (*Out:*) True    \nWhat makes Optional special is its behavior in functions. It has a special simplest form which you may have seen already in a function declaration:      a_:Automatic\/\/FullForm (*Out:*) Optional[Pattern[a,Blank[]],Automatic]    \nAnd now observe what this can do for us:      optionsFunction[arg_:Automatic]:=arg; optionsFunction[1] (*Out:*) 1 optionsFunction[] (*Out:*) Automatic    \nNotice how we didn’t need to supply a value. How Optional works is that if the Pattern doesn’t match, the default value gets substituted instead. What makes this special is the following sort of thing:      opF[intArg:_Integer:1,strArg:_String:\"Hi\",listArg:_List:{1,2,3}]:=Grid@{ {\"Int\",\"Str\",\"List\"}, {intArg,strArg,listArg} }; opF[] (*Out:*)          opF[{1}] (*Out:*)          opF[\"a\",{1}] (*Out:*)          opF[10, {1}] (*Out:*)       \nNotice how we didn’t even need to specify all of our arguments to change our list argument. This is because a List wouldn’t match ``` Intege or String``` so these took on their default values, but the list argument took the value supplied.  \nThis sort of trick only works when the argument patterns are disjoint enough, but often they are. At base, it means that complicated functions can be declared more concisely. Moreover, it is a crucial thing to know when dealing with OptionsPattern   Attributes  \nI’m mentioning Attributes here only because I would be remiss not to. All Symbol s can have Attributes in Mathematica and as functions are Symbol s, they can too. There is a list of permitted Attributes and trying to set an undefined attribute will cause an error to be raised:      SetAttributes[a,hat]; Attributes@a    \nThe point of Attributes is generally to change the evaluation behavior of a symbol. The most useful Attributes in my mind are HoldFirst , HoldAll , and Listable all of which change how a definitions on a Symbol are applied.  \nHoldFirst and HoldAll designate that some portion of their arguments (either the first or all of them) should not be evaluated before being substituted into the code of their function definition. For example:      atF~SetAttributes~HoldFirst; atF[arg_]:=Hold[arg]; atF[N[π]] (*Out:*) Hold[N[π]]    \nIf atF did not have this, N[π] would have evaluated first:      ClearAttributes[atF,HoldFirst]; atF[N[π]] (*Out:*) Hold[3.141592653589793`]    \nHoldAll has the same behavior, just every argument is held. (There is also a HoldRest attribute which should be self explanatory). There is however also an attribute HoldAllComplete which behaves like HoldAll except even UpValues are not applied (this is probably a meaningless statement, but there is a section dealing with UpValues soon)  \nListable changes evaluation behavior by specifying that the function should be applied to the elements of any List in its arguments. This is made clear better by the documentation, but there is a useful case to know about, where this behavior is important.  \nStringJoin joins strings, obviously, but it also has the attribute Listable which means that rather that requiring      StringJoin[\"a\",\"b\",\"c\",\"d\"] (*Out:*) \"abcd\"    \nIt can take:      StringJoin@{\"a\",\"b\",\"c\",\"d\"} (*Out:*) \"abcd\"    \nBut where this is really useful is in the alias form of StringJoin ( <> ). If it did not have Listable we’d have to do the following:      \"a\"<>\"b\"<>\"c\"<>\"d\" (*Out:*) \"abcd\"    \nBut since it does we can drop some of those <> for a list:      \"\"<>{\"a\",\"b\",\"c\",\"d\"} (*Out:*) \"abcd\"    \nThis behavior may seem unimportant now, but it can be incredibly useful when in the midst of a large project and needing to try out different things. Converting your entire list to <> joined pairs can be annoying, or maybe you already had some joins in there. In any case, it can save time and brain power which could be better used on actual programming.    Options, OptionsPattern, OptionValue, and FilterRules  \nMuch like Attributes a Symbol can also store Options . These are a list of Rule s with default values which are used by functions via the OptionValue interface. There’s a convenient Pattern called OptionsPattern which will match Rule and RuleDelayed sequences among other things. The Options interface is rich, so check out the documentation on it, but I’ll provide some tips, tricks, and common uses cases  \nOne thing to keep in mind is that since OptionsPattern matches a block of Rule and RuleDelayed , it can be useful to declare that all of the arguments before this block (or after it) are not Rule or RuleDelayed     Options[opEx]={\"X\"->0,Y->0,1->5,{1,2,3}->3}; opEx[notRuleArgs:Except[_Rule]...,ops:OptionsPattern[]]:={ {notRuleArgs}, {ops} }; opEx[1,2,3] { {1,2,3},{}} opEx[1, 2, \"X\"1000] { {1,2},{\"X\"1000}} opEx[1, 2, \"X\"1000,A20] { {1,2},{\"X\"1000,A20}}    \nWhen using Options in a function one uses OptionValue to get the value, which will first check to see it’s been overridden in an argument and if not go to the default value:      opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]]:=OptionValue@\"X\"; opEx[1,2,3] (*Out:*) 0 opEx[1, 2, \"X\"1000] (*Out:*) 1000    \nIf you call an OptionValue for which there is no default, you’ll get an error:      opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]]:=OptionValue@Z; opEx[1,2,3]    \nEven if you provide an explicit override value, it will still grouse at you:      opEx[1,2,\"Z\"500]    \n  OptionValue::nodef:   Unknown option \"Z\" for opEx.       (*Out:*) 500    \nOptions are generally used to provide more flexibility and control than can easily be done via an argument list. Options can also be used as a function to see all of the default options for a symbol and for many of the built-in symbols you can see how many there are, so that users can tweak lots of things. For example, Plot has a whole host of options:      Options@Plot (*Out:*) {AlignmentPointCenter,AspectRatio,AxesTrue,AxesLabelNone,AxesOriginAutomatic,AxesStyle{},BackgroundNone,BaselinePositionAutomatic,BaseStyle{},ClippingStyleNone,ColorFunctionAutomatic,ColorFunctionScalingTrue,ColorOutputAutomatic,ContentSelectableAutomatic,CoordinatesToolOptionsAutomatic,DisplayFunction$DisplayFunction,Epilog{},EvaluatedAutomatic,EvaluationMonitorNone,ExclusionsAutomatic,ExclusionsStyleNone,FillingNone,FillingStyleAutomatic,FormatTypeTraditionalForm,FrameFalse,FrameLabelNone,FrameStyle{},FrameTicksAutomatic,FrameTicksStyle{},GridLinesNone,GridLinesStyle{},ImageMargins0.`,ImagePaddingAll,ImageSizeAutomatic,ImageSizeRawAutomatic,LabelStyle{},MaxRecursionAutomatic,MeshNone,MeshFunctions{#1&},MeshShadingNone,MeshStyleAutomatic,MethodAutomatic,PerformanceGoal$PerformanceGoal,PlotLabelNone,PlotLabelsNone,PlotLegendsNone,PlotPointsAutomatic,PlotRange{Full,Automatic},PlotRangeClippingTrue,PlotRangePaddingAutomatic,PlotRegionAutomatic,PlotStyleAutomatic,PlotTheme$PlotTheme,PreserveImageOptionsAutomatic,Prolog{},RegionFunction(True&),RotateLabelTrue,ScalingFunctionsNone,TargetUnitsAutomatic,TicksAutomatic,TicksStyle{},WorkingPrecisionMachinePrecision}    \nThis is also useful for chaining functions together and passing their options to each other. Before an example of that, it’s worth talking about FilterRules . All it does is take a list of rules and either an explicit list of rules or rule names or a pattern to match and selects those rules whose left-hand side matches. For example:      FilterRules[Options@Plot,PlotStyle|EvaluationMonitor] (*Out:*) {EvaluationMonitorNone,PlotStyleAutomatic}    \nThis can be used to make sure rules conform to the options of a given function:      FilterRules[{\"Z\"->10,\"X\"->100},Options@opEx] (*Out:*) {\"X\"100}    \nFinally as OptionValue matches the last pattern it sees, one can pass all the defaults for a symbol plus some updates by putting your new rules first in a FilterRules :      ClearAll@opEx Options[opEx] = {\"X\" -> 0, Y -> 0}; opEx[notRuleArgs : Except[_Rule] ..., ops : OptionsPattern[]] := OptionValue@\"X\"; FilterRules[Join[{\"Z\"->10,\"X\"->100},Options@opEx],Options@opEx] (*Out:*) {\"X\"100,\"X\"0,Y0} opEx@@FilterRules[Join[{\"Z\"10,\"X\"100},Options@opEx],Options@opEx] (*Out:*) 100    \nThis trick is necessary when overriding options on an old function:      Options[newGraphics3D]=Join[{ Lighting->\"Neutral\", Boxed->False, ImageSize->Small }, FilterRules[Options@Graphics3D,Except[Boxed|Lighting|ImageSize]] ]; newGraphics3D[graphicsStuff:Except[_Rule]...,ops:OptionsPattern[]]:=Graphics3D[{graphicsStuff}, FilterRules[Join[{ops},Options@newGraphics3D], Options@Graphics3D] ] newGraphics3D@Sphere[] (*Out:*)",
			"tags":"functions patterns",
			"url":"mathematica-programming\/code-structure\/functions.html",
			"note":""
		},
		{
			"title":"Contexts",
			"text":"‌   Contexts  \nContexts are a relatively simple concept but have major effects. Their basic use is to tag symbols with extra information. Usually we are in the global context:      $Context (*Out:*) \"Global`\"    \nAlthough many of the functions we use are not:      Context@Plot (*Out:*) \"System`\"    \nA context is a series of symbol names followed by \"`\"  \nContexts we can use without fully qualifying the name are those on $ContextPath     $ContextPath (*Out:*) {\"CloudObjectLoader`\",\"StreamingLoader`\",\"SymbolicMachineLearningLoader`\",\"IconizeLoader`\",\"HTTPHandlingLoader`\",\"PacletManager`\",\"System`\",\"Global`\"}    \nWe can define our own contexts via Begin and BeginPackage and the context is exited via End and EndPackage respectively. The only difference between these is that BeginPackage restricts the value of $ContextPath while Begin does not:      BeginPackage[\"NameTools`\"]; thisIsTheLocalContextPath=$ContextPath; EndPackage[] thisIsTheLocalContextPath\/\/Context (*Out:*) \"NameTools`\" thisIsTheLocalContextPath (*Out:*) {\"NameTools`\",\"System`\"}    \nThis protects symbols from being affected by things in the Global` context or any other context. Begin does not do this:      Begin[\"NameTools`\"]; thisIsTheLocalContextPath=$ContextPath; End[]; thisIsTheLocalContextPath (*Out:*) {\"NameTools`\",\"CloudObjectLoader`\",\"StreamingLoader`\",\"SymbolicMachineLearningLoader`\",\"IconizeLoader`\",\"HTTPHandlingLoader`\",\"PacletManager`\",\"System`\",\"Global`\"}    \nNote that BeginPackage also prepended the context defined to the $ContextPath .  \nAnything not in NameTools` exactly won’t be found, however:      NameTools`hidden`a=100 (*Out:*) 100 a (*Out:*) a a\/\/Context (*Out:*) \"Global`\"    \nThis is how Mathematica defines so many functions without us having to worry about using the wrong symbols. Just consider all of the symbols we can find in System`Private` :      Pane[Column@Names@\"System`Private`*\", {Automatic,100},Scrollbars{False,True}, AppearanceElementsNone] (*Out:*)       \nOne final useful thing to know is that the current context can be implied when defining a symbol, such as done in the following example:      `Private`b=100 (*Out:*) 100    \nThis just had the current context put in front of the first `      Global`Private`b (*Out:*) 100",
			"tags":"contexts",
			"url":"mathematica-programming\/code-structure\/contexts.html",
			"note":""
		},
		{
			"title":"OwnValues, Set, and SetDelayed",
			"text":"‌   OwnValues, Set, and SetDelayed   Set and SetDelayed  \nBoth Set and SetDelayed work by setting definitions on a symbol. What this means in practice is that Set and SetDelayed add replacement patterns to one of the ⋆Values lists of the symbol. The lists can be OwnValues , DownValues , UpValues or SubValues . There are also NValues and FormatValues , but these are assigned via alternate interfaces and do not have much effect on real programming.    OwnValues  \nOwnValues are the most fundamental type of ⋆Values . These represent things like the following:      a = 10; a := 20;    \nWe can then query the OwnValues     OwnValues@a (*Out:*) {HoldPattern[a] :> 20}    \nWe can even edit the OwnValues manually if we know what we’re doing:      OwnValues[a] = Prepend[OwnValues[a], HoldPattern[a] :> 50] (*Out:*) {HoldPattern[a] :> 50, HoldPattern[a] :> 20} a (*Out:*) 50    \nSomething interesting happens, though, if you set more values on a via SetDelayed :      a := 100 OwnValues@a (*Out:*) {HoldPattern[a] :> 100, HoldPattern[a] :> 20} a := 32 OwnValues@a (*Out:*) {HoldPattern[a] :> 32, HoldPattern[a] :> 20}    \nOnly the first entry is changed. This behavior could be used with something like the following to cache symbol values:      setValue[s_Symbol, v_] := (OwnValues[s] = Prepend[OwnValues[s], HoldPattern[s] :> v]); resetValue[s_Symbol] := (OwnValues[s] = Rest@OwnValues[s]); SetAttributes[setValue, HoldFirst]; SetAttributes[resetValue, HoldFirst] setValue[a, 10]; a (*Out:*) 10 setValue[a, 20]; a (*Out:*) 20 resetValue[a]; a (*Out:*) 10    \nNotice that using a plain Set erases these changes:      a = 10 (*Out:*) 10 OwnValues@a (*Out:*) {HoldPattern[a] :> 10}    \nEven if now we add more values Set will erase them all:      OwnValues[a] = Join[ConstantArray[HoldPattern[a] :> 25, 10], OwnValues@a] (*Out:*) {HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 25, HoldPattern[a] :> 10} a = 10 (*Out:*) 10 OwnValues@a (*Out:*) {HoldPattern[a] :> 10}",
			"tags":"values assignment",
			"url":"mathematica-programming\/code-structure\/ownvalues-set-and-setdelayed.html",
			"note":""
		},
		{
			"title":"Function Values and Definition Clearing",
			"text":"‌   Function ⋆Values and Definition Clearing   DownValues  \nIf OwnValues are standard value bindings, DownValues are your basic function bindings:      f[x_] := x DownValues@f (*Out:*) {HoldPattern[f[x_]] :> x}    \nThis is also why we can define functions as patterns. All that happens is a series of replacement rules are tried, based on the DownValues of the expression. Really, one can imagine that all Mathematica does to execute an expression is apply ReplaceRepeated on the ⋆Values .  \nObviously the system is more complex, because of Attributes and the coming discussion of evaluation order and things, and also more optimized, but it’s a good concept to keep in mind.  \nJust like with OwnValues we can manipulate the DownValues via  \nOne final thing. On the name DownValues : one can imagine that the system is looking “down-stream” in the expression to see if the arguments match the defined replacement pattern.    UpValues  \nUpValues are a highly useful, if not necessarily intuitive feature of the expression structure. While DownValues look “down-stream”, UpValues look “up-stream”. What this means in practice is they are patterns applied on an expression by the arguments of the expression which are, in a way, looking “up-stream”. This is probably clearest via example, but first we need to know how UpValues are set.  \nFirst off, there is a function UpSet ( ^= ) and it’s partner UpSetDelayed ( ^:= ) which will do this      h[b[c___]] ^:= b[h, c]    \nThis has set UpValues on b :      UpValues@b (*Out:*) {HoldPattern[h[b[c___]]] :> b[h, c]}    \nThen let’s test this:      h[b[1, 3, 4, 2, 1]] (*Out:*) b[h, 1, 3, 4, 2, 1]    \nThe most useful aspect of this behavior is that it requires only that we give definitions to the down-stream symbol, not the head, so we can use this to “overload” the basic functionality of a built-in function, which is more efficient and also cleaner and safer.  \nMoreover, this means we can apply definitions to functions which we otherwise couldn’t. We’ll demonstrate this with the MessageName function. Aliased with ::  \nI’ll also demonstrate the better way to set these definitions, using TagSet ( \/: )      AssociationInterface \/: HoldPattern[ MessageName[AssociationInterface[a_Association], key_] ] := a[key];    \nTagSet only sets the definition on the symbol to the left, unlike UpSet which sets the definition on every argument.  \nThe HoldPattern is necessary to make sure the expression doesn’t evaluate while we set the UpValue , which will make more sense when we get to discussions of evaluation order.  \nNow we can see how our definition works:      AssociationInterface[<| \"a\" -> b, \"b\" -> d, \"e\" -> f |>]::a (*Out:*) b    \nMessageName automatically converts its second argument to a String , so the keys of our Association need to be strings, but we can see the definition works.  \nOne thing that should be mentioned before moving on is that the UpValues of the arguments of a symbol are applied before the DownValues of the enclosing head, although the DownValues of the argument itself are applied before its UpValues   SubValues  \nSubValues are the final type of values we need to deal with here. They provide an extension of DownValues to multiple sets of arguments as follows:      s[arg_][arg2_] := arg + arg2; SubValues@s (*Out:*) {HoldPattern[s[arg_][arg2_]] :> arg + arg2}     Clear and ClearAll  \nWith ⋆Values discussed it’s possible to understand the operations of of the functions Clear and ClearAll . Consider some symbol we’ve set a lot of definitions on:      m[1] = 1; m[2] = 10; m[5] = 100; HoldPattern[m[1][3]] = 20; m[s_String] := \"soup\"; HoldPattern[Print[m[x_]]] ^:= x + \"Print\"; m := 35 OwnValues@m (*Out:*) {HoldPattern[m] :> 35} DownValues@m (*Out:*) {HoldPattern[m[1]] :> 1, HoldPattern[m[2]] :> 10, HoldPattern[m[5]] :> 100, HoldPattern[m[s_String]] :> \"soup\"} UpValues@m (*Out:*) {HoldPattern[HoldPattern[Print[m[x_]]]] :> x + \"Print\"} SubValues@m (*Out:*) {HoldPattern[HoldPattern[m[1][3]]] :> 20}    \nAll Clear does is remove the ⋆Values :      Clear@m OwnValues@m (*Out:*) {} DownValues@m (*Out:*) {} UpValues@m (*Out:*) {} SubValues@m (*Out:*) {}    \nClearAll on the other hand can also remove Options and Attributes     SetAttributes[m, Listable]; Options[m] = {\"why\" -> \"me?\"}; Clear@m Options@m Attributes@m (*Out:*) {\"why\" -> \"me?\"} (*Out:*) {Listable} ClearAll@m Options@m Attributes@m (*Out:*) {} (*Out:*) {}",
			"tags":"values clear",
			"url":"mathematica-programming\/code-structure\/function-values-and-definition-clearing-.html",
			"note":""
		},
		{
			"title":"Hold and Evaluation Order",
			"text":"‌   Hold⋆ and Evaluation Order  \nWe’ve touched on evaluation order briefly when we introduced UpValues but there are a series of other things to consider. For example say you want to define a function that makes a string of print commands to display. Naively we might try the following:      Column@(ToString \/@ {Print[1], Print[2], Print[3]})    \n 1   \n 2   \n 3      (*Out:*)       \nBut Print evaluates before ToString so we’ll need to format a different way. We can try it with Hold     Column@(ToString \/@ Hold[Print[1], Print[2], Print[3]]) (*Out:*) Column[Hold[ToString[Print[1]], ToString[Print[2]], ToString[Print[3]]]]    \nHold prevents the evaluation of the command it’s wrapped around. Unfortunately that applies to ToString too.  \nOur solution is instead to use Unevaluated     Column@(ToString \/@ {Unevaluated@Print[1], Unevaluated@Print[2], Unevaluated@Print[3]}) (*Out:*)       \nUnevaluated has no meaning on it’s own, but when wrapped around an expression essentially says to use that expression it is Unevaluated form.  \nIts counterpart is Evaluate , which forces the evaluation of a held expression:      Hold[Evaluate@∫ 0 π Sin[θ]θ]        (*Out:*) Hold[2]    \nNote that Evaluate only works when on the first level of the expression though:      Hold[1 + Evaluate@∫ 0 π Sin[θ]θ]         Hold[1 + Evaluate[∫ 0 π Sin[θ]θ]]     \nHold is often used with Thread to create lists of held expressions:      Column@Thread@Hold[{ ∫ 2 π Sin[θ]θ, ∫ 1 π Sin[θ]θ, ∫ 0 π Sin[θ]θ}]        (*Out:*)       \nIt’s also used with the Replace function family to manipulate expressions without evaluation:      Hold[a[1], b[], c[1]] \/. { a -> Print, _b :> ∫ 2 π Sin[θ]θ, c -> CreateDocument}         Hold[Print[1], ∫ 2 π Sin[θ]θ, CreateDocument[1]]     \nNote that Print[2] is inserted into the Hold without evaluation.  \nThere’s a trick to getting it do evaluate:      Hold[a[1], b[], c[1]] \/. { a -> Print, _b :> With[{r = ∫ 2 π Sin[θ]θ}, r \/; True], c -> CreateDocument}        (*Out:*) Hold[Print[1], 1 + Cos[2], CreateDocument[1]]    \nWhy this works will be explained later, for now just keep in mind as a useful trick",
			"tags":"hold evaluation-order",
			"url":"mathematica-programming\/code-structure\/hold-and-evaluation-order.html",
			"note":""
		},
		{
			"title":"Procedural Programming",
			"text":"‌   Procedural Programming  \nIn most programming languages (C++, Java, python) we generally use what is called “procedural programming” where we work in a very step-wise fashion. Perhaps the archetype of this is the “for-loop”, the work-horse of standard programming. Mathematica, too, has a For loop. In fact we can use all the standard constructs of procedural programming:      radii={}; For[ i =1, i<10, i++, radii=radii~Append~RandomReal[] ]; radii (*Out:*) {0.914128302537593`,0.3769315906863173`,0.6234932943918361`,0.1322100006893343`,0.1577628966678457`,0.016730303000478397`,0.17548676789547235`,0.8109969085084299`,0.20378370831071368`}    \nWe have a very simple set of steps, here, make a list, radii , initialize a loop variable i , then perform a task (appending a Real to radii ) and incrementing our loop variable i while some test holds ( i < 10 ). Everything is laid out very explicitly and easily to understand. Unfortunately, when writing a large program, having to go through so many steps is a hassle and impedes the development process.  \nFunctional programming, which is almost always defined in contrast to procedural programming, deals with using functions like our usual primitives and passing them through other function accordingly. There are many facets to functional programming, of course, but its most common use is the application of functions to lists.  \nWe can do the above process in a single line using a functional construct:      Table[RandomReal[],10] (*Out:*) {0.4137847297182886`,0.9732982192569992`,0.3548496693281973`,0.8582126960787808`,0.15420928011477764`,0.6816139288605962`,0.8404716895591711`,0.9679926345109562`,0.7314841013853948`,0.7997407311341189`}    \nThere are many useful functional constructs we can use that will solve large classes of programming issues for us.",
			"tags":"functional-programming procedural-programming",
			"url":"mathematica-programming\/functional-programming\/procedural-programming.html",
			"note":""
		},
		{
			"title":"Table \/ Do",
			"text":"‌   Table \/ Do  \nBoth Table and Do are only barely functional programming, still generally used procedurally, but they are simple, much more efficient alternatives to For and While loops. All they do is loop over a list or range, with optional localized loop variables:  \nCompare:      For[ i = 1, i< 10^6, i++, PrimeQ@i]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.830501`    \nand      Do[ PrimeQ@i,{i,10^6}]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.31723`    \nIt’s over 2x faster to use Do here and the result is exactly the same. Moreover, as shown before, Table will automatically accumulate the results of each step, with huge efficiency gains over the equivalent procedural construct:      results={}; For[ i = 1, i< 2.5*10^4, i++,AppendTo[results, PrimeQ@i]]\/\/ AbsoluteTiming\/\/First (*Out:*) 3.008666` Table[PrimeQ@i,{i,2.5*10^4}]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.008375`",
			"tags":"functional-programming table do",
			"url":"mathematica-programming\/functional-programming\/table--do.html",
			"note":""
		},
		{
			"title":"Map \/ Scan",
			"text":"‌   Map \/ Scan  \nNote that often we can even one-up Table and Do in terms of simplicity, while losing no performance. Map and Scan pass an argument from a list to a function, much as Table and Do iterate over a range or list:      Table[PrimeQ@i,{i,10^6}]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.369371`    \ncompared to      Map[PrimeQ,Range[10^6]]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.3625`    \nEven better, though, Map has a more compact in-line syntax:      PrimeQ\/@Range[10^6]\/\/ AbsoluteTiming\/\/First (*Out:*) 0.374421`    \nOver time you will start thinking in this new syntax. Rather than “map prime-q over range of 10^6” you will start to think “prime-q slash at range of 10^6”.  \nNote that both Map and Table generate output, while their equivalents Scan and Do don’t. Even though Scan does not have in-line syntax it is worth getting to know, as it can sometimes be more efficient than Do and is, of course, vastly more efficient than For",
			"tags":"functional-programming map scan",
			"url":"mathematica-programming\/functional-programming\/map--scan.html",
			"note":""
		},
		{
			"title":"Nest \/ NestList",
			"text":"‌   Nest \/ NestList   Nest  \nOften instead of mapping a function over a list we want to map a function in a nested fashion, taking the previous result as the argument of our next call. For this, there is Nest . We could, for instance, implement a random-walk function using this.  \nFirst the random vector:      randomVector= Compile[{ {mag,_Real} }, mag*Normalize@RandomReal[{-1,1},3] ];    \nThen the random walk starting from a point:      randomWalk[start_,n_,stepSize_]:=Nest[randomVector[stepSize]+#&,start,n]; randomWalk[{0,0,0},100,.1] (*Out:*) {-0.6701260860918063`,0.14108631400644098`,-0.18613771198513052`}    \nDo to this procedurally we would have had to have scoped it then looped:      randomWalkP[start_,n_,stepSize_]:= Module[{current=start,i}, For[i = 1, i<= n , i++,current+= randomVector[stepSize]]; current ]; randomWalkP[{0,0,0},100,.1] (*Out:*) {-0.014976940150273566`,0.9945437636484472`,-0.08019586484541548`}    \nAnd then we can see the efficiency gains of the former:      randomWalkP[{0,0,0},10^6,.1]\/\/ AbsoluteTiming\/\/First (*Out:*) 2.599178` randomWalk[{0,0,0},10^6,.1]\/\/ AbsoluteTiming\/\/First (*Out:*) 1.824635`    \nSmall (most of the cost comes from the normalization in randomVector , hence the Compile call) but non-negligible.    NestList  \nThe gains are drastic if we want all of our walk positions. For this we use the corresponding NestList function:      randomWalk2[start_,n_,stepSize_]:= NestList[randomVector[stepSize]+#&,start,n]; randomWalk2[{0,0,0},10^6,.1]\/\/AbsoluteTiming\/\/First (*Out:*) 1.892415` randomWalkP2[start_,n_,stepSize_]:= Module[{path={start},i}, For[i = 1, i<= n , i++,AppendTo[path, randomVector[stepSize]+Last@path]]; path ]; randomWalkP2[{0,0,0},10^5,.1]\/\/ AbsoluteTiming\/\/First (*Out:*) 27.372997`    \nNote that, not only does it take almost 15x as long, we accumulated an order of magnitude fewer points.  \nLet’s put this to good use, now, seeing where our random walks end up:      randomWalkP2[{0,0,0},2.5*10^4,.1]\/\/Mean\/\/AbsoluteTiming (*Out:*) {1.821336`,{7.575784741863281`,-5.394047567758916`,2.3229639385579515`}} randomWalk2[{0,0,0},25*10^3,.1]\/\/Mean\/\/AbsoluteTiming (*Out:*) {0.043608`,{-6.015475841270593`,-0.6336148160099607`,-3.303309091893062`}}    \nBoth have traveled a considerable distance and using the vast efficiency gains from the NestList we can actually see if this holds in general or if it’s just a spurious effect:      Table[randomWalk2[{0,0,0},25*10^3,.1]\/\/Mean\/\/Norm,100]\/\/Mean\/\/AbsoluteTiming (*Out:*) {4.537624`,8.4477492155034`}    \nSo it does in fact seem that, on average, a random walk will leave its origin. Note that doing that checking the same thing procedurally would have take a number of minutes. We can do it in under five seconds.",
			"tags":"functional-programming nest nestlist",
			"url":"mathematica-programming\/functional-programming\/nest--nestlist.html",
			"note":""
		},
		{
			"title":"Fold \/ FoldList",
			"text":"‌   Fold \/ FoldList  \nWhere Nest applies a function in to the result of the previous function call in a nested fashion, Fold and its related functions apply a function to the previous function call and simultaneously map over a list.  \nAs a very simple example we can turn an expression like this:      c[a1,a2,a3,...,an]    \ninto one like      c[a1][a2][a3][...][an]    \nin one line of code. This process is closely related to the concept “currying” in standard functional programming so we can call this pseudocurrying (in fact this example comes directly from a question I asked on the Mathematica stack exchange):      curry= Function[expr, Replace[expr,h_[a__]:>Fold[#1[#2]&,{h,a}]], HoldFirst];    \nwhere we take advantage of Mathematica’s ability to set attributes on pure functions. We can use this to, for example, drill into nested associations, where we will also build our association using Fold :      data=Association@Fold[#2Replace[#,_Rule->Association@#]&,Range[1,10]] (*Out:*) 10987654321 curry@data[10,9,8] (*Out:*) 7654321    \nNote that Mathematica already implements this type currying for associations:      data[10,9,8] (*Out:*) 7654321    \nBut for other user-defined types this can be incredibly useful",
			"tags":"functional-programming fold foldlist",
			"url":"mathematica-programming\/functional-programming\/fold--foldlist.html",
			"note":""
		},
		{
			"title":"FixedPoint and Gradients",
			"text":"‌   FixedPoint and Gradients   Why is this here  \nWhile not tightly intertwined with all aspects of functional programming, this does provide an example of the simplicity with which we can do interesting tasks using functional programming.  \nUsing a more procedural paradigm each portion of this code (outside of the basic gradient definitions) would be more involved, more error prone, and also less efficient.    FixedPoint and Gradients  \nJust as a side note there is a function called FixedPoint that is essentially Nest until the result doesn’t change. This is great for following gradients to minima. We can use its corresponding FixedPointList to trace an arbitrary gradient. For now we’ll use a gradient with a predictable result:      gradient= Compile[{ {pos,_Real,1}}, { Piecewise[{ {Sqrt@-(#+2),#<-3}, {(-(#+2)^3),-3<#<0}, {-((#-2)^3),0≤#<3}, {-Sqrt@(#-2),3<=#} },#]&@pos[[1]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[2]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[3]] } ]; Plot[First@gradient@{x,x,x},{x,-5,5}] (*Out:*)          Plot[Last@gradient@{x,x,x},{x,-5,5}] (*Out:*)       \nEssentially our system should be pushed to either {2,0,0} or {-2,0,0}  \nThen we’ll calculate the path a point travels along (we’ll apply a much rougher sameness test that FixedPoint usually takes):      (path= FixedPointList[ gradient@#+#&, {5,2,2}, SameTest(Norm@Abs[#-#2]<.0001&)])\/\/AbsoluteTiming\/\/First (*Out:*) 0.001503`    \nAnd we can plot this:      Graphics3D[Arrow@Tube[path],AxesTrue,ImageSizeSmall] (*Out:*)       \nThen we can do this for many paths. First we’ll calculate a grid across the cube { {-5,-5,-5},{5,5,5}} with 20 divisions on per direction:      gridPoints= Tuples[Subdivide[-5,5,20],3];    \nThen we’ll compute the paths traveled (note how quickly this can be computed using FixedPoint ):      (paths= Table[ FixedPointList[ gradient@#+#&, p, SameTest(Norm@Abs[#-#2]<.1&) ][[2;;]], {p,gridPoints} ])\/\/AbsoluteTiming\/\/First (*Out:*) 0.213083`    \nWe’ll plot the paths followed:      Graphics3D[Line\/@paths,AxesTrue,ImageSizeSmall] (*Out:*)       \nNote the central gap where the gradient sampled out the points immediately. We can visualize this by simply showing the first step for a central cube:      Arrow@{#,#+gradient@#}&\/@Tuples[Subdivide[-1,1,3],3]\/\/Graphics3D[#, ImageSizeSmall, PlotRange{Automatic,{-2,2},{-2,2}}, AxesTrue, AxesOrigin{0,0,0}]& (*Out:*)       \nThen we’ll create a density map for these points based on the norm of the gradient at a each point along the paths:      pds=Append[#,Norm@*gradient@#]&\/@DeleteDuplicates@Flatten[paths,1]; densityData= With[{r=Last\/@pds\/\/MinMax}, ReplacePart[#,4->Rescale[Last@#,r]]&\/@pds ];    \nthen use the magical ListDensityPlot3D to get a density plot of this:      ListDensityPlot3D[densityData, OpacityFunction(If[#<.25,1-#,0]&), ImageSizeSmall] (*Out:*)       \nNote that we don’t see two wells because Mathematica interpolates between the two well pieces. We can change this by simply adding our grid points back in:      pdsNew=Join[pds,Append[#,Norm@gradient@#]&\/@gridPoints,1]; densityDataNew= With[{r=Last\/@pdsNew\/\/MinMax}, ReplacePart[#,4->Rescale[Last@#,r]]&\/@pdsNew ]; ListDensityPlot3D[densityDataNew, OpacityFunction(If[#<.2,1-#,0]&) ] (*Out:*)       \nNote the application of OpacityFunction to drop those bits of data with norms above the 20% mark. The rings are, of course, just coming from our grid points.  \nAnd of course we can functionalize this:      Options[gradientDensityPlot]=Options@ListDensityPlot3D; gradientDensityPlot[grad_, startPoints:{ {_?NumericQ,_?NumericQ,_?NumericQ},__List}, cutoff:_?NumericQ:.2, ops:OptionsPattern[] ]:= With[{ pathData= With[{o= Sequence@@ FilterRules[ {ops, SameTest->(Norm@Abs[#1-#2]<.1&) }, Options@FixedPointList]}, Join@@Map[ FixedPointList[grad@#+#&,#,o]&, startPoints] ] }, With[{ gradData= Append[#,Norm@grad@#]&\/@DeleteDuplicates@Join[pathData,startPoints] }, ListDensityPlot3D[ With[{r=MinMax@gradData}, ReplacePart[#, -1->Rescale[Last@#,r]]&\/@gradData ], FilterRules[ {ops, OpacityFunction->(If[#<cutoff,1-#,0]&) }, Options@ListDensityPlot3D] ] ] ];    \nBy judicious use of RegionFunction and a density cutoff we can focus in on the places we are interested in:      gradientDensityPlot[gradient,gridPoints, .05, SameTest->(Norm@Abs[#1 - #2 ]<.01 &) ] (*Out:*)       \nNow let’s try it on another gradient!  \nWe’ll just use a linear gradient, pushing everything into zero:      gradientDensityPlot[-#\/2&,N@gridPoints] (*Out:*)",
			"tags":"functional-programming fixedpoint",
			"url":"mathematica-programming\/functional-programming\/fixedpoint-and-gradients.html",
			"note":""
		},
		{
			"title":"Packages",
			"text":"‌   Packages  \nPackages are a convenient way to partition code into chunks that don’t interact with each other needlessly, allowing for simpler programming. Mathematica even has a special package file type, the .m file, which is closer to plain-text than a .nb file.  \nA package is really just a collection of symbols in a given context, defined so as to interact with only the System context and whichever contexts the user loads, which protects from name overlaps and things.    Definition  \nA package may be defined anywhere, using BeginPackage and EndPackage . Usually one inserts a Private context into the package, however, to make definitions cleaner, and only exposes a certain subset of functions, which are given usage messages. For example let’s define a simple package:      BeginPackage[\"BabysFirstPackage`\"]; function1::usage = \"an exposed function\"; function2::usage = \"another one!\" $constant::usage = \"a package constant\"; Begin[\"`Private`\"]; function1[x_] := function2[1, x]; function2[x_, y_] := ($constant = RandomReal[]*x*y); End[]; EndPackage[];    \nNote that the symbols must be used before they are given private definitions or else the definitions will be on private symbols.    Get and Needs  \nOnce the package is defined, it’s later imported using Get or Needs , the difference between which can be found in the documentation (there are no subtleties to be warned about, here).  \nNote that both Get and Needs only work on these very plain .m and .wl files. One cannot run Get on a notebook file and evaluate the expressions contained within so simply.    AutoGeneratedPackage and InitializationGroups  \nHappily there is a way to define packages within notebooks, using the AutoGeneratePackage option for the notebook. When this is set to Automatic , every time the notebook is saved it saves all of the initialization cells within to a package file with the same file name.  \nIf this were all, that wouldn’t be too useful, as having to specify all of the initialization cells is a pain. Happily we evade that problem by using an InitializationGroup , which is simply a cell group where all of the evaluatable cells are automatically initialization cells.  \nThe way I often go about using this is creating two cell groups:  \nI put all of my package code here.  \nAnd run all of my tests here.  \nThen I make the Package cell an InitializationGroup . This way I can simply add and subtract from the package at will, but still get all the benefits of a notebook for testing and formatting.  \nPackages are also a great way to store useful tricks and things you develop for doing problem sets or similar projects. Just toss all of your tricks in one package and you can get them all at once.",
			"tags":"packages",
			"url":"mathematica-programming\/higher-level-functionality\/packages.html",
			"note":""
		},
		{
			"title":"Dynamic",
			"text":"‌   Dynamic  \nEverything done up to here has involved static content. Often, though, dynamic content is what you need. I don’t have the time to explain all of Dynamic here, given how many things one can do with Dynamic , but it’s worth going over a few critical things.    Dynamic as formatting head  \nDynamic only ever updates while it’s on screen. This is one of it’s key features, as otherwise things could get out of hand. How this works is that Dynamic is just something that the Mathematica front end sees and creates listeners to update.  \nThis means, though, that if your content will never display it won’t update. If you need an invisible updater, use DynamicWrapper .    Dynamic’s second argument  \nDynamic takes a function as a second argument that it calls whenever it tries to update, passing the update value as the first argument. We can use this to do fancy things like the following:      Slider@Dynamic[x, (x = RandomReal[]) &] (*Out:*)       \nThe variable takes a random value every time we try to update it.  \nThis could also be used to record responses:      $responseCache = {}; Grid[ { { SetterBar[ Dynamic[Last@Replace[$responseCache, {} :> {None}], AppendTo[$responseCache, #] & ], Range[10] ], Dynamic@Column@$responseCache } }, Alignment -> Top ] (*Out:*)       \nEach click adds to the response cache.    TrackedSymbols  \nDynamic usually decides in a semi-opaque manner which symbols to track changes in, but we can force it to follow symbol updates. Let’s make a Dynamic thing that passes colors back and forth. We’ll write it using Mouseover so the passing only occurs when we’re hovering      c1 = Gray; c2 = Green; counter = 1; Mouseover[ Row@{Dynamic@Graphics[{c1, Disk[]}], Dynamic@Graphics[{c2, Disk[]}]}, Row@{ Dynamic[Graphics[{ c1 = If[counter < 5, counter++; Pause[.1]; c1, counter = 1; c2], Disk[]}], TrackedSymbols :> {c1, c2, counter}], Dynamic[Graphics[{ c2 = If[c1 === c2, RandomColor[], c2], Disk[]}], TrackedSymbols :> {c1, c2, counter}] } ] (*Out:*)       \nYou’ll notice this works exactly as expected.  \nOften, however, one runs into issues with TrackedSymbols . This is because of an interesting implementation choice. To track a symbol, it needs to appear in the display expression and not too deep. Usually I simply put the symbol in as part of a CompoundExpression so it does nothing, but Dynamic knows to track it. The following is probably the safer way to write this, to ensure tracking:      c1 = Gray; c2 = Green; counter = 1; Mouseover[ Row@{Dynamic@Graphics[{c1, Disk[]}], Dynamic@Graphics[{c2, Disk[]}]}, Row@{ Dynamic[counter; c1; c2; Graphics[{ c1 = If[counter < 5, counter++; Pause[.1]; c1, counter = 1; c2], Disk[]}], TrackedSymbols :> {c1, c2, counter}], Dynamic[c1; c2; Graphics[{ c2 = If[c1 === c2, RandomColor[], c2], Disk[]}], TrackedSymbols :> {c1, c2, counter}] } ] (*Out:*)        UpdateInterval  \nDynamic can also be scheduled to simply update on a given time frame, which is usually a fall back for when there’s no other way to get symbol tracking to work right or there are no symbols to track. In this case it’s very important the TrackedSymbols be passed an empty list.  \nHere’s a classic stop watch example:      startTime = None; updateInterval = ∞; Panel@Grid[{ {Button[\"Start\", startTime = TimeObject[]; updateInterval = .1], Button[\"Stop\", updateInterval = ∞], Button[\"Reset\", startTime = If[updateInterval === ∞, None, TimeObject[]]] }, {Panel@Panel[ Dynamic[ updateInterval; startTime; Dynamic[ TemplateApply[\"``:``:``\", If[MatchQ[#, _Integer], StringPadLeft[ToString[#], 2, \"0\"], ToString@#] & \/@ First@TimeObject@( If[ startTime === None, {0, 0, 0}, {0, 0, Round[TimeObject[] - startTime \/\/ QuantityMagnitude, .01]}]) ], TrackedSymbols :> {}, UpdateInterval -> updateInterval], TrackedSymbols :> {updateInterval, startTime}], ImageSize -> 200, Alignment -> Center, Background -> White], SpanFromLeft} }] (*Out:*)",
			"tags":"dynamic",
			"url":"mathematica-programming\/higher-level-functionality\/dynamic.html",
			"note":""
		},
		{
			"title":"Formatting",
			"text":"‌   Formatting  \nMathematica has a number of useful formatting heads for arbitrary expressions, which fall into two main categories: spatial formatting and styling    Grid, Row, and Column  \nThese are the primary spatial formatting heads. They primarily let you arrange lists nicely:      Column@RandomInteger[20,20] (*Out:*)          Row@Riffle[RandomInteger[20,20],\", \"] (*Out:*) Row[{20, \", \", 19, \", \", 18, \", \", 7, \", \", 0, \", \", 19, \", \", 18, \", \", 19, \", \", 0, \", \", 20, \", \", 9, \", \", 3, \", \", 4, \", \", 18, \", \", 11, \", \", 18, \", \", 11, \", \", 17, \", \", 15, \", \", 18}] Grid@Array[RandomInteger[20,20]&,20] (*Out:*)       \nEach of these comes with their own options and formatting rules, but the idea is the same for all of them. I’ll just point out a few things:  \nAnything can be part of a formatted expression:      Grid@Array[Array[Graphics[{RandomColor[],Disk[]},ImageSizeRandomInteger[{5,20}]]&, 5] &, 5] (*Out:*)       \nThe internal expression is also still possible to recover using First :      First@%       \nAnd a Grid is not just a Column of Rows :      Row\/@%\/\/Column (*Out:*)       \nGrid in particular has three special elements types that change how spacing is done, SpanFromLeft , SpanFromAbove , and SpanFromBoth . It is not always clear exactly what combination of spanning elements will achieve the desired effect, but just play around with them until the output looks right and you’ll be fine.  \nBe sure to look at all of the options for Grid as there are many cool things one can do. As a quick example, one can put in dividers with arbitrary coloring:      Grid[ Array[Array[Graphics[{RandomColor[],Disk[]},ImageSizeRandomInteger[{5,20}]]&, 5] &, 5], Dividers{Array[#->RandomColor[]&,6],Array[#->RandomColor[]&,6]} ] (*Out:*)       \nSimilarly look at Item because it provides more fine-grained control over grid formatting, which can often be useful.    Style, Framed, Pane, and Panel  \nThe other class of formatting heads is the styling heads. First among them is Style which applies styling to an expression, particularly text:      Style[ HoldForm[ Row@{ ∫ 0 π Cos[θ]Sin[θ]θ, Spacer[25], Graphics[Disk[]] } ], BackgroundRandomColor[], FontSizeLarge, FontColorRandomColor[], FontFamilyRandomChoice@$FontFamilies, FontVariations{\"Underline\" -> True,\"Underlight\"Purple}, FontWeightBold, AutoStyleWords{ \"Cos\"\"Text\", \"Sin\"\"Section\" } ]        (*Out:*)       \nEssentially any styling one can apply to a Cell , one can apply to an expression using Style  \nFramed on the other hand does one thing. It puts a frame around an expression:      Framed[\"Are you enjoying the tutorial?\"] (*Out:*)       \nBut what makes it useful is the styling one can apply to the frame:      Framed[ Style[\"Are you enjoying the tutorial?\",Blue], RoundingRadius5, FrameStyleGrayLevel[.8], BackgroundLightBlue] (*Out:*)       \nIt does nothing to affect the display of the actual expression though.  \nIn contrast, that is all Pane does. Pane merely provides a way to change how an expression displays on screen. It’s chief use is for preventing large objects from taking up lots of display space:      Pane[ ExampleData[{\"Text\",\"USConstitution\"}], ImageSize{500,250} ] (*Out:*)       \nThe display size can be variable and one can also attach scroll bars and things:      Pane[ ExampleData[{\"Text\",\"USConstitution\"}], ImageSize{ {Automatic,500},250}, Scrollbars{False, Automatic} ]\/\/Framed[#,FrameMargins{ {3,0},{0,0}}]& (*Out:*)       \nPane has less customization than the rest of the styling heads, but is possibly the most useful when designing quality interfaces  \nPanel is different from the other styling heads in that it is a sort of amalgamation of all three:      Panel[\"Check this out\"] (*Out:*)       \nIt basically generates a frame and applies default text styling, but the size of the panel can also be set:      Panel[ ExampleData[{\"Text\",\"USConstitution\"}], ImageSize{500,250} ] (*Out:*)       \nUnfortunately scrolling is disabled, so often one wraps a Pane in a Panel to achieve that:      Panel[ Pane[ ExampleData[{\"Text\",\"USConstitution\"}], ImageSize{500,250}, Scrollbars{False, Automatic} ] ] (*Out:*)       \nPanel is a nice, simple, reasonably professional looking go-to for arbitrary formatting, so it should often be the one of the first things one considers when formatting and expression    Format and Interpretation  \nThe use for most of this formatting is often to hide the complexity of an expression. One leverages the power of the Format function and Interpretation functions to make an ugly expression look nice.  \nUsually one does this by defining an inert formatting head to wrap around the expression and defining the formatting for that expression:      Format[ExampleDataFormatter[data_,title_]]:= Interpretation[ Panel[Column[{ Style[title,Large,Bold], Panel@Pane[ data, ImageSize->{ {Automatic,400},150}, Scrollbars->{False, Automatic} ]}, Dividers->Center] ], ExampleDataFormatter[data,title] ]; ExampleDataFormatter[ ExampleData[{\"Text\",\"USConstitution\"}],\"The United States Constitution\"] (*Out:*)          Column@{ StringLength@First@%, Head@%, Last@% } (*Out:*)       \nThis allows the often messy internal structure of a Mathematica expression to be hidden by a nice, content-rich format.",
			"tags":"formatting",
			"url":"mathematica-programming\/higher-level-functionality\/formatting.html",
			"note":""
		},
		{
			"title":"Interfaces",
			"text":"‌   Interfaces   Button  \nButton is as simple as they come. It’s just a button. It has an expression it puts on the button and it runs a command and that’s it:      Button[ MouseAppearance[\"Click Me\", Style[\"?\",Large,Bold] ], Print[\"Ouch!\"]] (*Out:*)       \nIt’s got some nice formatting options:      Row@Table[ With[{a=a}, Button[ MouseAppearance[\"Click Me\", Style[\"?\",Large,Bold] ], Print[a], Appearancea] ], {a,{Automatic,\"Frameless\",\"Palette\",\"AbuttingRight\",\"AbuttingLeft\"}} ] (*Out:*)       \nAnd you can change its basic styling:      Button[ Mouseover[\"You deserve a break\", Style[\"Relax and click here\",\"HyperlinkActive\"] ], SystemOpen@\"https:\/\/www.youtube.com\/watch?v=cMdiYuzHVZ4\", BaseStyle\"Hyperlink\", Appearance\"Frameless\" ] (*Out:*) [\"You deserve a break\"](#\"You deserve a break\")     InputField  \nAn InputField is pretty self-explanatory:      InputField[\"Hi there\",String] (*Out:*)       \nIts usefulness comes when combined with Dynamic     inputVar=\"Change me\"; InputField[Dynamic[inputVar, Print[\"Changed!\"];inputVar=#;&],String] (*Out:*)          inputVar    \nIt of course has many useful styling and usage options but these are generally pretty well documented so there is no pressing need to discuss them here.    PopupMenu  \nA PopupMenu just selects a value from a list:      PopupMenu[\"\",Prepend[Names[\"*Data\"],\"\"Style[\"Choose a data type\",Italic,Gray]]] (*Out:*)       \nOnce again we can also set a variable this way:      Dynamic@popupVar; PopupMenu[Dynamic@popupVar,Prepend[Names[\"*Data\"],\"\"->Style[\"Choose a data type\",Italic,Gray]]] (*Out:*)          popupVar     EventHandler  \nEventHandler isn’t really an interface element so much as an extension for them. It catches front end events -- mouse clicks, keyboard input, etc. and routes them through a set of rules. It’s powerful, but can be a little tough to use.  \nMathematica, unlike a more usual front-end system like tkinter, has no rich event syntax, instead it depends on the user querying the front end about global state, such as how one catches a double click event:      youDidIt=False; nowClickPrinted=False; wellDonePrinted=False; EventHandler[ MouseAppearance[ Panel[\"Double click here\"], \"Arrow\"],{ \"MouseEntered\":> If[!(youDidIt\/\/TrueQ)&&!(nowClickPrinted\/\/TrueQ),Print[\"Now click\"]; nowClickPrinted=True], \"MouseClicked\":> If[CurrentValue@\"MouseClickCount\"==2, If[!(youDidIt\/\/TrueQ), Print[\"You did it!\"]; youDidIt=True ] ], \"MouseExited\":>If[ youDidIt&&!(wellDonePrinted\/\/TrueQ), Print[\"Well done\"]; wellDonePrinted=True] } ] (*Out:*)       \nThis is an undeniably poor way to do things with myriad pitfalls, but it is one of the restrictions of the system, unfortunately.  \nThe full list of events that EventHandler can use isn’t completely clear, but the most common use cases are on its doc page. Others can be found by `` \"googling\" ``` .  \nOne class of events to know about is the class of \"MenuCommand\" events. These look like {\"MenuCommand\", token} and of these particularly crucial are the tokens \"HandleShiftReturn\" and \"EvaluateCells\" . These prevent Shift-Return or Keypad-Enter from evaluating and creating a new cell. Here’s a way to use this:      HandlerInputField[sym:_Dynamic|None:None,handlerFunction_,ops___]:= With[{dynSym=Replace[sym, NoneWith[{u=Unique@\"handlerInputFieldValue$\"},u=Null;Dynamic@u] ]}, EventHandler[InputField[dynSym,ops],{ {\"MenuCommand\",\"HandleShiftReturn\"} Replace[ dynSym, Verbatim[Dynamic][s_,___]( handlerFunction@s; s=\"\" ) ], {\"MenuCommand\",\"EvaluateCells\"} Replace[ dynSym, Verbatim[Dynamic][s_,___]( handlerFunction@s; s=\"\" ) ], \"ReturnKeyDown\"NotebookWrite[EvaluationNotebook[],\"\\n\"] } ] ]    \nThis creates and input field wrapped in an event handler. Now we’ll make an interface that can log the most common words we type. Type normally and return with Shift-Return.      wordLog={}; Column[{ HandlerInputField[ (wordLog=Join[wordLog, ToLowerCase\/@StringSplit@StringReplace[#,Except[WordCharacter|\"'\"]->\" \"] ])&, String ], Dynamic[ With[{a=Counts@wordLog}, BarChart[Values@a, ChartLabels->Keys@a] ] ] }, Dividers->{ {},{2->Gray}} ]     OpenerView and Toggler  \nOpenerView is a particularly nice formatting element which let’s expressions be hidden but a title displayed:      OpenerView@{\"Updating dynamic thing\", Dynamic[ Pause[.5]; Graphics@{RandomColor[],Disk[]}, UpdateInterval1]} (*Out:*)       \nIt’s really a subclass of Toggler (well it’s parent function Opener is) but worth mentioning because of how useful it is. A nice way to add underlines is to use Column :      OpenerView@{ Column[ {\"Updating dynamic thing\"}, Dividers{ {},{2Gray}} ], Dynamic[ Pause[.5]; Graphics@{RandomColor[],Disk[]}, UpdateInterval1]} (*Out:*)       \nToggler just toggles between expressions when clicked      Toggler[1,Table[iFramed[ Style[i,FontColorIf[i<5,White,Black]], RoundingRadius5, FrameStyleNone, BackgroundGrayLevel[i\/10]],{i,10}]] (*Out:*)       \nAnd Toggler can similarly be used as a variable setter:      togglerVar=1; Toggler[Dynamic@togglerVar,Table[i->Framed[ Style[i,FontColor->If[i<5,White,Black]], RoundingRadius->5, FrameStyle->None, Background->GrayLevel[i\/10]],{i,10}]] (*Out:*)          togglerVar",
			"tags":"interfaces",
			"url":"mathematica-programming\/higher-level-functionality\/interfaces.html",
			"note":""
		},
		{
			"title":"The Front End",
			"text":"‌   The Front End  \nThe front end is what most people think of when they think of Mathematica. It's the collection of cells and notebooks and palettes and windows that you use to program, do your homework, write your resume, etc.  \nThis is separate from the back end, also known as the kernel. That is where all your definitions and variables live. That's where the your code actually runs.  \nThe two communicate, but it's important to understand that they are separate entities altogether    The Front End  \nThe front end can be accessed via the symbol $FrontEnd . This is the most global way to set options, change formatting, etc. For example, we can get the current default window size:      WindowSize\/.Options[$FrontEnd,WindowSize] (*Out:*) {808,755}    \nWe can also change this, but often the better thing to do is just to change the value on the symbol $FrontEndSession which only applies the changes for the current session. $FrontEnd keeps track of any changes applied and caches them permanently.      SetOptions[$FrontEndSession,WindowSize->{100,100}]    \nThis will change how big any windows we make appear, although it will not change the size of windows made with File ▸ New or  ```+ N . We can test this out using CreateDocument``` though:      CreateDocument[]    \nWe can also remove this:      SetOptions[$FrontEndSession,WindowSize->Inherited]    \nSince $FrontEndSession inherits from $FrontEnd this reverts the change    Notebooks  \nA notebook is any window Mathematica creates. We can find all of the notebooks:      Notebooks[]    \nOr notebooks matching a name:      Notebooks[\"Mathematica For Chemists\"]    \nA notebook is represented by a NotebookObject . A NotebookObject only exists for a given front end session. We can see why if we look at its InputForm :      CreateDocument[]\/\/InputForm    \nThis is a symbolic form that represents an object communicating with the front end specified by the FrontEndObject ( LinkObject refers to a link to a kernel process—something beyond the scope of what we're working with here). Its ID is the last argument. Every time we create a new notebook the ID increments, so that within a given front end session no two notebooks will ever have the same ID.  \nMathematica has a special notebook that always exists:      First@Notebooks@\"Messages\"    \nMathematica will dump all messages generated without a notebook to this notebook. Generally this means dynamically generated messages—that is, messages generated by Dynamic or other front-end events.  \nIn a given evaluation, Mathematica keeps track of the notebook that started it. This can be obtained as follows:      EvaluationNotebook[]    \nNote that this applies even in the case of Dynamic evaluations:      Dynamic@EvaluationNotebook[]\/\/ CreateDocument[#, WindowSize->Small, WindowTitle->\"Different notebook\"]&; Dynamic@EvaluationNotebook[]    \nIn most cases this is the most useful notebook to have, but there are a number of others that may be of interest.  \nThis will give the notebook that currently has keyboard focus. This is very useful when making palettes.      InputNotebook[]    \nIf the current evaluation was started by a button, this gives the notebook that button was in. Again, useful for palettes and similar functionality.      ButtonNotebook[]    \nWe can get and set options on notebooks just like the front end:      SetOptions[ CreateDocument[], Background->RandomColor[] ]    \nWe can also write data to a notebook:      nb=CreateDocument[]; NotebookWrite[nb,\"some_string\"]    \nWe'll go more into detail of what exactly can be written and where when discussing Cells and Boxes .  \nOne final thing: although a displayed notebook is referenced by a NotebookObject , it is stored as an expression with the head Notebook and for a given NotebookObject there is a way to get this expression:      NotebookGet@EvaluationNotebook[]    \nThis pulls the entire Notebook expression for the current notebook.    Cells  \nAs we just saw, at the symbolic level, a notebook is a list of Cell or CellGroupData expressions plus some options. In practice, though, this turns into a column of cells. We can get this list of cells by doing the following:      Cells@EvaluationNotebook[]    \nIn the case of this notebook, this is a very large list of cells. Let's just look at the form of the first of these:      First@Cells@EvaluationNotebook[]\/\/InputForm (*Out:*) CellObject[131425]    \nYou'll notice it's just an ID, because the CellObject doesn't need to track a LinkObject the way a NotebookObject does. But otherwise it can largely be treated like a NotebookObject in terms of setting and getting options.  \nThere are a number of ways to get a CellObject :      EvaluationCell[] NextCell[] PreviousCell[] (*Out:*)          (*Out:*)          (*Out:*)       \nAs with a NotebookObject there is a stored symbolic form for a CellObject :      First@Cells@EvaluationNotebook[]\/\/NotebookRead    \nAnd when we use NotebookWrite we often use it on these sorts of Cell expressions:      NotebookWrite[EvaluationNotebook[], Cell[\"A newly written cell\",\"Output\",CellDingbat->Cell[\"NEW!!\",Background->None] ] ]    \nNotebookWrite can also be used to overwrite cells:      bg=Darker@Red; fg=Orange; CellPrint@Cell[ \"The phoenix burns to ashes...\", \"Output\", FontColor->fg, Background->bg ]; Do[ NotebookWrite[ NextCell[], Cell[ \"The phoenix burns to ashes...\", \"Output\", FontColor->Blend[{fg,Darker[bg,i\/10]},i\/10], Background->Darker[bg,i\/10] ] ], {i,10} ]; Pause[.25]; Do[ NotebookWrite[NextCell[], Cell[\"And is reborn there from\", \"Output\", FontColor->Blend[{Darker[bg,1-i\/10],fg},i\/10], Background->Darker[bg,1-i\/10] ] ], {i,10} ]    \nA general Cell expression has a deterministic form:      Cell[data_,style_,options__]    \ndata will generally either be a String , BoxData expression, or TextData expression. The differences between these forms will become clearer in the section on Boxes  \nWhen working with a cell, it's possible to view and edit this symbolic representation using Cell ▸ Show Expression or +E   Boxes  \nIf notebooks are windows and cells are elements of a notebook, then Boxes describe front-end content. Every piece of content except for primitives such as strings and numbers has a box form for display. Boxes allow for the interesting formatting that Mathematica permits, by giving a low-level spec for various styling options. We can view the boxes in an expression using ToBoxes :      Framed[Style[ \"Something super cool\", FontColor->CurrentValue[{StyleDefinitions,\"Section\",FontColor}] ], RoundingRadius->5, FrameStyle->CurrentValue[{StyleDefinitions,\"Section\",FontColor}], Background->CurrentValue[{StyleDefinitions,\"Section\",Background}] ] (*Out:*) \"Something super cool\" ToBoxes@ Framed[Style[ \"Something super cool\", FontColor->CurrentValue[{StyleDefinitions,\"Section\",FontColor}] ], RoundingRadius->5, FrameStyle->CurrentValue[{StyleDefinitions,\"Section\",FontColor}], Background->CurrentValue[{StyleDefinitions,\"Section\",Background}] ] (*Out:*)       \nTo make content like Dynamic work these boxes can't be static objects, though. Much like CellObject and NotebookObject there is a BoxObject which we can access, although with more difficulty. Easiest, though, is just to use EvaluationBox :      Dynamic[EvaluationBox[]]    \nNote that this really does have to be wrapped in Dynamic . Before it is displayed, this box doesn't exist. But we can do something fun with this now:      Dynamic[box=EvaluationBox[]] NotebookWrite[box, ToBoxes@ Framed[Style[ \"And the box disappears...\", ShowStringCharacters->False, FontColor->CurrentValue[{StyleDefinitions,\"Section\",FontColor}] ], RoundingRadius->5, FrameStyle->CurrentValue[{StyleDefinitions,\"Section\",FontColor}], Background->CurrentValue[{StyleDefinitions,\"Section\",Background}] ]]    \nThis gives us a way to use NotebookWrite to overwrite data without overwriting a cell itself.    Stylesheets  \nStylesheets give us the power to leverage the multitudinous styling options available to cells to make cascading stylesheets for giving custom styles to notebooks. On the whole this process is straightforward once you know how to get started.  \nFor a given notebook, you can access its stylesheet by going to Format ▸ Edit Stylesheet . There you can edit the default cell styles or define your own.  \nWhat the front end pays attention to are cells formatted like this:      Cell[StyleData[style_],options___]    \nThis will set options on all cells with style style by default. To inherit definitions from a different cell style use:      Cell[StyleData[style_,StyleDefinitions->StyleData[parent_]],options___]    \nThat's pretty much it. Past that it's simply a matter of figuring out what styles work best and knowing which options do what you want done.",
			"tags":"front-end",
			"url":"mathematica-programming\/higher-level-functionality\/the-front-end.html",
			"note":""
		},
		{
			"title":"Remote Kernels",
			"text":"‌   Remote Kernels  \nAs mentioned in the previous section, in addition to the front-end there is the kernel. One very useful feature of Mathematica, though, is that it allows for multiple kernels to be running.  \nRemember that the kernel is where your code runs, so if you have a particularly time-intensive calculation running in one kernel it can be convenient to have a secondary kernel running.    Add kernels  \nWe start another kernel via the front end. Go to Evaluation ▸ Kernel Configuration Options... and then click Add... and give a name to your new kernel.  \nThen in a new notebook go to Evaluation ▸ Notebook's Kernel and choose this new kernel you created.    Add kernels via FrontEndTokens  \nWe'll discuss FrontEndTokens more later, but for now just consider them a mechanism to use all front end functionality from the kernel.  \nFor our cases here, we can make our lives a little bit easier by using a special FrontEndToken     FrontEndExecute@FrontEndToken[\"ModifyEvaluatorNames\"]    \nor more simply:      FrontEndTokenExecute[\"ModifyEvaluatorNames\"]    \nThis gives us the add dialog. Unfortunately FrontEndTokens are not particularly well documented and so the command for setting a notebook's kernel remains opaque.    Remote kernels  \nOne useful feature of kernels is that they can be run anywhere—not just on your local computer. If, then, Mathematica exists on a remote server, call it \"server.place.dom\" , say, a kernel can be initiated there and connected to your local front end, by passing X-Windows or a similar remote GUI system.  \nWe can access this by going back to Evaluation ▸ Kernel Configuration Options... or doing the same via the following:      FrontEndTokenExecute[\"ModifyEvaluatorNames\"]    \nThen in Add... under Basic Options select Remote Machine and input your info. If the server is \"server.place.dom\" , put that as the Remote host and give your info as the Remote user .  \nThen whenever you give that kernel as a notebook name and try to evaluate anything or start the kernel, Mathematica will pop up a dialog asking for your password.  \nIf you have RSA authentication enabled, this password step becomes unnecessary.",
			"tags":"kernels",
			"url":"mathematica-programming\/higher-level-functionality\/remote-kernels.html",
			"note":""
		},
		{
			"title":"Compile",
			"text":"Mathematica is what is often called a high-level programming language, because when you are writing programs, you don't need to worry about how the computer is doing its job. This provides notable gains in simplicity and scalability of large programs, but it comes at the cost of the speed and efficiency of low-level computations.   ‌   Basics of Compilation  \nTo get around this Mathematica provides the function Compile which will generate a low-level function that we can then apply with fantastic results. For example, in the section on Nest I provided a random vector generator:  \nThis creates a compiled function that will perform the task at hand, in this case taking a vector of Real numbers and returning a vector. Just so we can see the difference let's create the same function, uncompiled and compare the two:      randomVector= Compile[{{mag,_Real}}, mag*(#\/Norm[#])&@RandomReal[{-1,1},3] ] (*Out:*)          randomVectorU= Function[mag, mag*Normalize@RandomReal[{-1,1},3] ];    \nThen we'll compare them using a little timing function:      compareTiming[f1_,f2_,its_:1]:= With[{ tf1=First@AbsoluteTiming[Do[f1,its]],tf2=First@AbsoluteTiming[Do[f2,its]]}, (tf2-tf1)\/Max@{tf1,tf2} ]; compareTiming~SetAttributes~HoldAll; compareTiming[ randomVector[1], randomVectorU[1], 10^6 ] (*Out:*) 0.5244177474084153`    \nSo we get a 52% speed boost from essentially just changing Function to Compile on the simplest function imaginable. If we had a more involved function the speed boost would likely be even larger. But since it's so simple we can easily dissect what is giving the speed boost:    Analyzing Compile  \nWe'll build from the bottom up:      randomReal3=Compile[{},RandomReal[{-1,1},3]]; randomReal3U=Function[RandomReal[{-1,1},3]]; compareTiming[randomReal3[], randomReal3U[],10^6] (*Out:*) 0.4059389866935647`    \nThis alone is 40% faster! Of course when we know how many vectors we'll need ahead of time the fastest thing is to use the syntax RandomReal[range,{count,3}] which can, for example, generate 10 8 random vectors in a fraction of a second, which is much, much faster than our compiled form:      compareTiming[Do[randomReal3[], 10^7], RandomReal[{-1, 1}, {3, 10^7}]] (*Out:*) -0.9477078222470973`    \nIgnoring the correct way to do this, though, and considering out surprising result, this is likely an artifact of type-checking in the compiled function that has to be performed at each call in the uncompiled one.  \nWhen we add our normalization now:      randomVectorNoMag= Compile[{}, (#\/Norm[#]&)@RandomReal[{-1,1},3] ]; randomVectorNoMagU= Function[ Normalize@RandomReal[{-1,1},3] ]; compareTiming[randomVectorNoMag[], randomVectorNoMagU[], 10^6] (*Out:*) 0.4923576135986387`    \nNow we're a full 50% faster than we were (that this is greater than our original 40 is likely just a lack of consistency between runs).  \nNote that I'm in the CompiledFunction I'm not using Normalize . This is because Normalize cannot be directly compiled.  \nWe can see this by looking at the intermediate representation generated when we use it:      <<CompiledFunctionTools` CompilePrint@ Compile[{}, Normalize@RandomReal[{-1,1}, 3] ]\/\/Snippet[#, -5]&       -----------Out----------- 1 R0 = I1 2 R1 = I2 3 T(R1)1 = RandomReals[ R0, R1, T(I1)0]] 4 T(R1)2 = MainEvaluate[ Hold[Normalize][ T(R1)1]] 5 Return    \nThe call to \"MainEvaluate\" means that the compiled function couldn't handle this and thus it returns the value to the main evaluator to process.    Drastic Examples  \nThe previous case was simple so that it could easily be analyzed, but for more complicated cases we can much bigger gains. Consider the primary gradient function we used in the section on FixedPoint :      gradient= Compile[{{pos,_Real,1}}, { Piecewise[{ {Sqrt@-(#+2),#<-3}, {(-(#+2)^3),-3<#<0}, {-((#-2)^3),0<=#<3}, {-Sqrt@(#-2),3<=#} },#]&@pos[[1]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[2]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[3]] } ];    \nAnd then consider its uncompiled cousin:      gradientU= Function[pos, { Piecewise[{ {Sqrt@-(#+2),#<-3}, {(-(#+2)^3),-3<#<0}, {-((#-2)^3),0<=#<3}, {-Sqrt@(#-2),3<=#} },#]&@pos[[1]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[2]], Piecewise[{ {Sqrt@-(#),#<-1}, {(-(#)^3),-1<=#<=1}, {-Sqrt@(#),1<=#} },#]&@pos[[3]] } ]; With[{grid=RandomReal[{-5,5},{10^5,3}]}, compareTiming[ gradient@g, gradientU@g, {g,grid}] ] (*Out:*) 0.8961919038258733`    \nSo the simple application of Compile provides a 90% speed boost.  \nAs another example, one can implement numerical integration of a volume over a surface via:      compDotCross= Compile[{{coords, _Real, 2}, {abc,_Integer,1}}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]] ]; vol[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, (MeshCells[s, 2]\/.Polygon[g_List] :> compDotCross[coords, g]) \/\/Total ]\/6    \nthen get an interesting surface:      surf= RegionUnion@@ With[ { graphics= FirstCase[ ChemicalData[\"Caffeine\", \"SpaceFillingMoleculePlot\"], _GraphicsComplex, None, ∞ ] }, Cases[ graphics[[2]], Sphere[s_, r_]:>Ball[graphics[[1, s]], r] ] ]\/\/BoundaryDiscretizeRegion[#, MaxCellMeasure->{1->20}]& (*Out:*)       \nAnd compute its volume:      vol@surf\/\/RepeatedTiming (*Out:*) {0.0989207000000000003`2.,1.6728430521905467`*^8} Volume@surf\/\/RepeatedTiming (*Out:*) {0.0010948070175438598`2.,1.6728430521905503`*^8}    \nOur little compiled implementation is much slower than the built-in implementation, of course, but it's still incredibly fast for the level of mesh refinement.  \nPersonally, I this it for computing atomic orbital volumes derived from orbital contour plots.  \nLets then to a version without the compiled dot-cross:      uncompDotCross= Function[{coords, abc}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]] ]; volU[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, (MeshCells[s, 2]\/.Polygon[g_List] :> uncompDotCross[coords, g]) \/\/Total ]\/6 compareTiming[vol@surf, volU@surf] (*Out:*) 0.9539375762845481`    \nOurs is a whopping 95% faster. As the surface refinement increases this can be the difference between a function being nearly instantaneous versus a major speed bump in the research process.  \nWe can also compare the version where we compile to C (i.e. we use CompilationTarget->\"C\"     compDotCross= Compile[{{coords, _Real, 2}, {abc,_Integer,1}}, coords[[ abc[[1]] ]]. Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]], CompilationTarget->\"C\" ]; volC[s_?RegionQ]:= With[ {coords = MeshCoordinates[s]}, With[{compiledDotCross=compDotCross}, (MeshCells[s, 2]\/.Polygon[g_List] :> compiledDotCross[coords, g]) \/\/Total ]\/6 ] compareTiming[volC@surf, vol@surf] (*Out:*) 0.13463908089141324`    \nAnd simply compiling to C made the function 13% faster. More performance can be eked but by using the difference RuntimeOptions and things.    Using Compile  \nIt's often unclear whether a given function can be compiled or not, but happily Mathematica provides all of the possible compilable functions in Compile`CompilerFunctions . We can use this to make a compileableQ type function:      compilableQ[f_]:= MemberQ[Compile`CompilerFunctions[], f]    \nFor example, we can see that, say, RandomVariate is compilable:      compilableQ@RandomVariate (*Out:*) True    \nAlternatively we can figure out which Random⋆ functions are compilable:      compilableSelect[p_]:= Select[Compile`CompilerFunctions[], StringMatchQ[ToString@#,p]&] compilableSelect@\"Random*\" (*Out:*) {RandomChoice,RandomSample,RandomInteger,RandomVariate,RandomComplex,RandomReal,Random}    \nOnce we have that, Compile has a very simple call structure that is similar to Module :      Compile[ { {var1,type1,arraySize1}, {var2,type2,arraySize2}, ... }, expression, ops ]    \nThis will generate a CompiledFunction which is just a function in either Mathematica byte code or C byte code, as specified by the CompilationTarget option. In most cases Mathematica byte code is more than fast enough, but there are cases where the C code is a significantly better choice.",
			"tags":"compile",
			"url":"mathematica-programming\/performance-tuning\/compile.html",
			"note":""
		},
		{
			"title":"Special Array Types",
			"text":"‌   Packed Arrays  \nMathematica has a wide variety of low-level optimizations that we never run into in our high-level usage. One of the most useful of these is the concept of the PackedArray .  \nThese are efficiently stored arrays of a single type of object that perform much faster on many simple numerical manipulations than their \"unpacked\" companions.  \nMost internal functions that return arrays will return them in packed form. We can check that an array is packed with Developer`PackedArrayQ :      reals = RandomReal[{-1, 1}, {1000, 1000}]; Developer`PackedArrayQ@reals (*Out:*) True    \nThe memory footprint of these is much lower than standard arrays:      ByteCount@reals (*Out:*) 8000152 ureals=Developer`FromPackedArray@reals; Developer`PackedArrayQ@ureals ByteCount@ureals (*Out:*) False (*Out:*) 24208200    \nAnd operations that can return a packed array are faster than their unpacked variants:      1+reals\/\/RepeatedTiming\/\/First (*Out:*) 0.0024315980392156863`2. 1+ureals\/\/RepeatedTiming\/\/First (*Out:*) 0.0096411960784313737`2.     Unpacking  \nThe biggest thing to worry about with packed arrays is the time\/memory footprint that occurs when a packed array must be unpacked to be processed by a function that can't handle it in packed form.  \nFor instance the function Chop necessarily unpacks as it replaces the Real number 0. with the Integer number 0 . This means Chop will actually be slower on a packed array:      Chop@reals\/\/RepeatedTiming\/\/First (*Out:*) 0.1129493750000000046`2. Chop@ureals\/\/RepeatedTiming\/\/First (*Out:*) 0.052316666666666671`2.    \nBut if we use a function that can leverage the packing of the array it will be faster. For instance, let's look at the Real variant of Chop , a function called Threshold :      Threshold@reals\/\/RepeatedTiming\/\/First (*Out:*) 0.0030930624999999999`2. Threshold@ureals\/\/RepeatedTiming\/\/First (*Out:*) 0.0107768695652173899`2.    \nThe packed version is much faster now.   ‌   RawArray  \nThe RawArray is a relatively new addition to the language. It works rather like PackedArray in its requirement ot use a single type of object in it, but is a fundamentally different object.  \nIt's main benefit is how little memory it consumes:      reals\/\/ByteCount (*Out:*) 8000152    \nIf we use a 64-bit real we get similar memory consumption to the packed array:      raw64=RawArray[\"Real64\", reals]; raw64\/\/ByteCount (*Out:*) 8000096    \nBut we can specify that it out to use half as many bytes, as the memory usage will drop correspondingly:      raw32=RawArray[\"Real32\", reals]; raw32\/\/ByteCount (*Out:*) 4000096    \nThese can also be used more effectively via Library Link but we won't get into that now. For many data-intensive custom Import formats RawArray can help cut down on the memory consumption, particularly where some large portions of the data may not be immediately useful.   ‌   SparseArray  \nWe won't discuss SparseArray much, as the sparse array is a well-known concept especially in numerical linear algebra.  \nIt is worth keeping in mind, though, for places where one has highly sparse data. One classic place this can show up is in quantum mechanical calculations in a direct-product basis constructed from orthonormal bases. Here often one will obtain expressions that looks like      H[n, m, i, j] = H1*δ[i, j] + H2*δ[n, m]    \nAssuming N1 elements in the first basis and N2 in the second, this can be more efficiently represented as:      H = KroneckerProduct[H1, IdentityMatrix[N2]] + KroneckerProduct[IdentityMatrix[N1], H2]    \nAnd now if we visualize this with H1 and H2 being odd-looking matrices which arise in this context:      H1=Table[(-1)^(i-j)\/2 If[i==j, π^2\/3, 2\/(i-j)^2], {i, 50}, {j, 50}]; H2=Table[(-1)^(i-j)\/(2*(.05)^2) If[i==j, π^2\/3, 2\/(i-j)^2], {i, 75}, {j, 75}]; H1\/\/MatrixPlot (*Out:*)       \nWe can directly construct H in a the standard fashion:      H = KroneckerProduct[H1, IdentityMatrix[Length@H2]] + KroneckerProduct[IdentityMatrix[Length@H1], H2];\/\/AbsoluteTiming\/\/First (*Out:*) 4.523075`    \nIt takes a while and we see it has a large memory footprint:      H \/\/ ByteCount (*Out:*) 340260728    \nBut if we visualize it we see it's most zeros:      H \/\/ MatrixPlot (*Out:*)       \nIf we build it instead use SparseArray nothing will be done with that vast field of zeros, so it'll be faster and less memory intensive:      HS = KroneckerProduct[H1, IdentityMatrix[Length@H2, SparseArray]] + KroneckerProduct[IdentityMatrix[Length@H1, SparseArray], H2];\/\/AbsoluteTiming\/\/First (*Out:*) 0.118826` HS\/\/ByteCount (*Out:*) 11191512    \nAnd even better, when we ask for its smallest 5 Eigenvalues these will be computed faster, and increasingly so with matrix size:      Eigenvalues[H, -5]\/\/AbsoluteTiming (*Out:*) {4.943048`,{0.3917953580905429`,0.3745580141408224`,0.3611510903074643`,0.35157483336542145`,0.34582905618130677`}} Eigenvalues[HS, -5]\/\/AbsoluteTiming (*Out:*) {3.733548`,{0.39179535809072363`,0.37455801414116613`,0.3611510903079675`,0.35157483336567635`,0.34582905618161475`}}",
			"tags":"packed array",
			"url":"mathematica-programming\/performance-tuning\/special-array-types.html",
			"note":""
		},
		{
			"title":"Packages in Mathematica",
			"text":"‌   Packages  \nWe talked briefly before about packages in the context of programming, but we haven't talked about packages as an organizational structure in Mathematica.  \nAs with most languages, packages provide a way to bundle together different code files and resources. By creating a package a developer allows disparate functionality to act as a single unit. There are packages in C, Java, Python, etc. and while they all have subtle differences in setup and exact usage, they all serve the same purpose. In this regard, Mathematica is no different.  \nWe'll go more into how to set up one's own packages in a later post, but first we'll deal with some terminology.    Package File  \nMathematica packages come in two variants. The first is simply bundling a number of functions into a single file with the extension \".m\" or \".wl\"  \nWe talked about this earlier so in order to minimize repeating myself I won't go into this here.  \nThe main case where this type of package is useful is when the size of the code is not particularly large, there aren't any external resources that should be distributed with the package, versioning and updating is not a concern, and no metadata needs to be stored.  \nSurprisingly this covers the major use case most casual coders will handle.  \nA package file can simply be installed via Get , so often one need not install a package file explicitly to make use of it.    Paclet  \nSince the term \"package\" was already used, what most programming languages call a package Mathematica calls a \"paclet\".  \nA paclet is simply a .zip archive by another name that bundles code, resources, and metadata in a way that Mathematica's native package manager (the PacletManager system) can deal with. Paclets provide an easy way to install code, resources, stylesheets, palettes, and documentation via the PacletInstall function.  \nWhen we discuss packages for the rest of this section we will generally be talking about paclets, not package files themselves.",
			"tags":"packages paclets",
			"url":"package-usage-and-development\/basics\/packages-in-mathematica.html",
			"note":""
		},
		{
			"title":"Paclets",
			"text":"‌   Paclets  \nAs we discussed previously, paclets provide a way to distribute code, resources, and other things in Mathematica. They are the native format for this type of distribution and are tightly bound into the system.  \nPaclets can provide any or all of the following:  \nCode Resources Style Sheets Palettes Documentation  \nIn general the most common thing we'll want to provide is code, but the others are common things to distribute as well.    Paclet Structure  \nA paclet provides any of the aforementioned components and then also provides a file PacletInfo.m that supplies metadata. At its absolute simplest this might look like:      + PacletInfo.m Kernel + init.m MyPaclet.m     \nThis will then get distributed as a ZIP file with the extension .paclet and name MyPaclet-version.paclet where version is formatted for semantic versioning.  \nWe can distribute paclets in a more sophisticated manner via a server, but we'll talk about that and paclet construction after we go over some more basic usage.",
			"tags":"packages paclets",
			"url":"package-usage-and-development\/basics\/paclets.html",
			"note":""
		},
		{
			"title":"Multipackage Paclets",
			"text":"Paclets in the simplest case provide a single main package with the all of the functions implemented by the paclet. On the other hand, for any sufficiently complex package multiple packages will be needed. However, with the context mechanism Mathematica supplies it is not always clear what the best way to divide code over multiple packages is, so we'll provide a few different approaches   ‌   Predeclared Symbols \/ Shared Context  \nIn the simplest case, every piece of the package will have the same context and simply directly share symbols. To make this work right, all of the package-level symbols need to be declared before any of the implementation files are loaded. One way this could work is having a directory structure like      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m ... + MyPaclet.m     \nAnd then have MyPaclet.m look like:      BeginPackage[\"MyPaclet`\"] MyPacletSym1::usage=\"...\"; MyPacletSym2::usage=\"...\"; ... Begin[\"`Private`\"]; Get\/@ Select[ FileNames[\"*.m\", FileNameJoin@{DirectoryName[$InputFileName], \"Kernel\"}], FileNameTake[#]!=\"init.m\"& ]; End[]; EndPackage[];    \nAnd then each Component*.m file will simply provide definitions for the functions provided.   ‌   Folder-Based Contexts  \nA step up from this allows for different contexts to be supplied, taken from the folder the file is found in. This adds a layer of complexity, as we'll need a more complicated structure when declaring our symbols, but given the following directory layout:      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m Subcontext + Component1.m + Component2.m ... + MyPaclet.m     \nWe could use the following loader:      BeginPackage[\"MyPaclet`\"] MyPacletSym1::usage=\"...\"; MyPacletSym2::usage=\"...\"; ... BeginPackage[\"`Subcontext`\"] MySubcontextSym1::usage=\"...\"; MySubcontextSym2::usage=\"...\"; EndPackage[]; With[{`Private`dirPath=FileNameJoin@{DirectoryName[$InputFileName], \"Kernel\"}}, Map[ Function[ Begin[ StringRiffle[ Join[ Most@ FileNameSplit[ FileNameDrop[ DirectoryName[#], FileNameDepth[`Private`dirPath]] ], { \"Private\", \"\" } ], \"`\" ] ]; Get@#; End[] ], Select[ FileNames[\"*.m\", `Private`dirPath, Infinity], FileNameTake[#]!=\"init.m\"& ] ] ]; EndPackage[];     ‌   Packages with Autoloading  \nDepending on the size of the code, rather than simply load the entire package in when Get is called it can be efficient to introduce autoloading.  \nWhat this mean is that we determine which symbols are declared in which packages by inspecting the package header, but instead of loading the package we set the OwnValues to be a function that loads the package and then returns the symbol. By doing things this way we drastically cut down the load time for each function and keep parts of our package more appropriately contained.  \nThe code for this can be a little bit long, so we won't get into it here, but more info on this can be found here .   ‌   Other Approaches  \nA list of other approaches with detailed pros-and-cons may be found here .",
			"tags":"packages paclets development",
			"url":"package-usage-and-development\/higher-level-features\/multipackage-paclets.html",
			"note":""
		},
		{
			"title":"PacletInfo and Paclet Structure",
			"text":"‌   Paclet Structure  \nWe briefly mentioned what a paclet looks like previously, but we didn't discuss what the different types of paclets will look like and how this will be reflected in the PacletInfo.m file.  \nFirst we'll handle some PacletInfo.m basics then get into more details on how paclet structure is reflected here.    PacletInfo.m  \nThe PacletInfo.m file supplies a Paclet expression that encodes metadata in rules. The absolute simplest example might be:      Paclet[ Name->\"MyPaclet\", Version->\"1.0.0\" ]    \nThis simply tells the system there is a paclet named \"MyPaclet\" that has version \"1.0.0\" . There are many different parameters we can supply though:  \nWolframVersion — specifies the minimum version of Mathematica necessary to get the paclet to function properly  \nThis should be a string that looks like \"11.0.1+\" or \"10+\" or similar  \nSystemID — specifies the operating system or systems on which the paclet may be expected to work.  \nThe valid IDs are the valid IDs for $SystemID .  \nLoading — specifies the loading mode for the paclet  \nThe valid loading modes are Manual (default), Automatic , and \"StartUp\" . With the \"StartUp\" mode, the paclet is loaded right after the PacletManager . The Automatic mode will configure autoloading for any symbols that are provided as part of the \"Kernel\" extension (we'll get into this later).  \nThere are also a number of useful bits of descriptive metadata that are used by the Installed Add-Ons Guide and other third-party interfaces:  \nDescription — provides a brief description for the paclet Creator — specifies the creator of the paclet  \nThis should generally be a name and an email as one string, e.g. \"b3m2a1 <b3m2a1@gmail.com>\"  \nPublisher — specifies the organization publishing the paclet, if relevant Thumbnail — relative path to an icon for the paclet  \nOther bits of standard data are:  \nLicense — the license for the paclet Copyright — the copyright holder of the paclet Support — contact info for support   Extensions  \nThe Paclet expression can also supply an \"Extensions\" parameter that tells the manager what kinds of things may be done with it. A paclet with extensions will look like:      Paclet[ Name->\"MyPaclet\", Version->\"1.0.0\", Extensions-> { {\"Extension1\", \"Prop1\"->val1, ...}, {\"Extension2\", \"Prop1\"->val1, ...}, ... } ]    \nThe different extensions are what allow different types of resources to be served by the PacletManager . We'll break these down in turn.    Kernel  \nThe first and probably most common extension we'll want is the \"Kernel\" extension. If a paclet supplies code, it will want a \"Kernel\" extension.  \nIt has three main parameters it can take:  \n\"Root\" — this is the root off of which the \"Kernel\" folder should be located. Defaults to \".\" . \"Context\" — this supplies the contexts the paclet can load \"Symbols\" — this supplies a set of symbols that the paclet provides. If the Loading is set to Automatic , autoloading will be set up for everyone of these symbols.  \nFor a paclet structure that looks like  \n```  \nMyPaclet + PacletInfo.m Kernel + init.m MyPaclet.m SubContext.m ```  \nWe'd write the extension to look like:  \n```{ \"Kernel\", \"Root\"->\".\", \"Context\"->{\"MyPacle \", \"MyPaclet SubContex \", ...} }  ``    FrontEnd  \nThe \"FrontEnd\" extension tells the PacletManager to make the supplied front-end resources available system-wide. It has a few parameters:  \nRoot — the path to the front-end root directory. Defaults to \"FrontEnd\" . Prepend — if True the resources are prepended to the lookup path for the FE  \nWe can supply four different types of FE resources, each within a sub-folder of the \"FrontEnd\" folder:  \n\"StyleSheets\" — the folder containing stylesheet notebooks  \nThese notebook will appear in the main menu under Format » Stylesheet . If placed within a sub-folder, they'll be place in the group with that name in the menu. If nested twice they won't appear in the menu at all.  \n\"Palettes\" — the folder containing palette notebooks  \nThese operate fundamentally the same as the stylesheets with respect to the sub-folders and appearing in the menu.  \n\"TextResources\" — the folder containing .tr files that serve resources for FrontEndResource  \nMore info on these text resources can be found here or elsewhere on the Mathematica StackExchange.  \n\"SystemResources\" — the folder containing various system resources that may be used by the front-end. There are two subfolders:\n\"Bitmaps\" — the sub-folder containing various bitmaps and icons to be served \"AutocompletionData\" — the sub-folder containing pieces of autocompletion data to be served, especially the specialArgFunctions.tr file or .trie files  \nAnytime we want front-end resources we provide to be used we should add the extension:      { \"FrontEnd\", Prepend->True }     Documentation  \nAllows documentation files to be found and searched automatically. It has the following parameters:  \n\"Language\" — the target language for the docs (defaults to All ) \"Root\" — the root path for the docs (defaults to \"Documentation\" ) \"LinkBase\" — the path root (e.g. \"PacletManager\" in \"PacletManager\/ref\/PacletInstall\" ) \"MainPage\" — the default landing page for the paclet  \nIf we want to add English-language documentation to our paclet we'd set up the paclet like:      MyPaclet + PacletInfo.m Documentation English ReferencePages Symbols + MySymbol1.nb + MySymbol2.nb ... Guides + MyPaclet.nb + OtherGuide.nb ... Tutorials + Feature1.nb + Feature2.nb ...    \nThen our extension would look like:      { \"Documentation\", \"Language\"->\"English\", \"LinkBase\"->\"MyPaclet\", \"MainPage\"->\"Guides\/MyPaclet\" }     Resource  \nThe \"Resource\" extension may be used multiple times and supplies different resources that can be accessed via PacletResource .  \nEach resource takes a set of parameters  \n\"Root\" — the root from which lookups are done \"Resources\" — a set of relative paths to the resources \"SystemID\" — a specific system ID for the resource (defaults to All )  \nEach elements in the \"Resources\" should either be the relative path or a list {name, path} where name is a nickname for the resource.  \nAs an example, if we wanted to supply a set of resources we could have our paclet setup like:      MyPaclet + PacletInfo.m Resources + MyResource1.mx SubResources + SubResource1.mx    \nAnd then the extension would look like      { \"Resource\", \"Root\"->\"Resources\", \"Resources\" -> { {\"Resource\", \"MyResource1.mx\"}, {\"SubResource\", \"SubResources\/SubResource1.mx\"} } }     JLink  \nAutomatically adds the supplied .jar files to the classpath. Has the following parameters:  \n\"Root\" — specifies the root directory (defaults to \"Java\" ) \"WolframVersion\" — the versions for which the .jar files are valid \"SystemID\" — the systems for which the .jar files are valid   LibraryLink  \nAutomatically makes the supplied library files locatable via FindLibrary . Note that FindLibrary will find the file Root\/$SystemID . Has the same kind of parameters as \"JLink\" :  \n\"Root\" — specifies the root directory (defaults to \"LibraryResources\" ) \"WolframVersion\" — the versions for which the library files are valid \"SystemID\" — the systems for which the library files are valid   AutoCompletionData  \nProvides autocompletion data for lookup. Only supplies the \"Root\" parameter.",
			"tags":"packages paclets",
			"url":"package-usage-and-development\/paclet-development\/pacletinfo-and-paclet-structure.html",
			"note":""
		},
		{
			"title":"Paclet Development",
			"text":"‌   Paclet Development  \nNow that we know how a paclet should be structured, we can get into the details of developing a paclet. We'll make a paclet that has a bit of everything in it to see how it all works.    Directory Structure  \nOur basic structure will start out looking like      MyPaclet + PacletInfo.m     \nAnd the PacletInfo.m will look like:      Paclet[ Name -> \"MyPaclet\", Version -> \"0.0.1\", Creator -> \"b3m2a1 <b3m2a1@gmail.com>\", Description -> \"A sample paclet to show the paclet developement process\" ]     Kernel and Main Package  \nThe first thing we'll need to add to the paclet is a \"Kernel\" folder and a primary implementation package. For simplicity, we'll have our paclet provide a context \"MyPaclet`\" , and so our main package will have to create this context.  \nWe'll change our structure to look like:      MyPaclet + PacletInfo.m Kernel + init.m MyPaclet.m     \nAnd the info will look like:      Paclet[ Name -> \"MyPaclet\", Version -> \"0.0.1\", Creator -> \"b3m2a1 <b3m2a1@gmail.com>\", Description -> \"A sample paclet to show the paclet developement process\", Extensions -> { {\"Kernel\", \"Root\"->\".\", \"Context\"->{\"MyPaclet`\"}} } ]    \nNow we'll need to make the init.m file load MyPaclet.m , but this is no different than the standard way we might do this, e.g. via:      <<MyPaclet`MyPaclet`    \nAny other packages we provide should then be loaded in turn via MyPaclet.m . We won't get into the details of how to write a paclet with interacting piceces here, as there are many different ways people like to do this and we're trying to take a high-level overview, but we will return to that theme later.  \nAfter we do this it's possible to load the paclet with      <<MyPaclet`     FrontEnd Resources  \nLet's say we have some front-end resources we'd like to bundle with our paclet:  \nA stylesheet called MyPacletStyles.nb An icon in MyPacletIconResource.png A helper palette in MyPacletHelper.nb  \nWe'll add the following folder to our main directory:      FrontEnd StyleSheets MyPaclet + MyPacletStyles.nb Palettes MyPaclet + MyPacletHelper.nb SystemResources Bitmaps MyPaclet + MyPacletIconResource.png     \nAnd the info will look like:      Paclet[ Name -> \"MyPaclet\", Version -> \"0.0.1\", Creator -> \"b3m2a1 <b3m2a1@gmail.com>\", Description -> \"A sample paclet to show the paclet developement process\", Extensions -> { {\"Kernel\", \"Root\"->\".\", \"Context\"->{\"MyPaclet`\"}}, {\"FrontEnd\"} } ]    \nWe can then link to this stylesheet by setting      StyleDefinitions->FrontEnd`FileName[{\"MyPaclet\"}, \"MyPacletStyles.nb\"]     \nOr if we want to use the paclet icon we can do so with the appropriate FrontEnd`FileName . This time we'll want FrontEnd`FileName[{\"MyPaclet\"}, \"MyPacletIconResource.png\"] . Here's an example of this:      RawBoxes@ DynamicBox[ FEPrivate`ImportImage@ FrontEnd`FileName[{\"MyPaclet\"}, \"MyPacletIconResource.png\"] ]      Documentation  \nIf we have some documentation pages we have either built with Workbench or any of a number of third-part interfaces ( here's mine ), we can add these to our package too. Assuming we have the following English-language documentation pages to add:  \nA symbol page, MyPacletSym.nb A guide, MyPaclet.nb A tutorial, MyPacletOverview.nb  \nWe'll add the following folder to our directory      Documentation English ReferencePages Symbols + MyPacletSym.nb Guides + MyPaclet.nb Tutorials + MyPacletOverview.nb     \nAnd we'll add the following extension to the paclet info:      { \"Documentation\", \"Language\" -> \"English\", \"MainPage\" -> \"Guides\/MyPaclet\", \"LinkBase\" -> \"MyPaclet\" }    \nAfter this is installed, when people search for MyPacletSym the page will appear.    Resources  \nFinally, let's say we want to bundle resources with our paclet, maybe we have a template notebook, MyTemplate.nb and a bunch of data stored in .mx files, MyDat1.mx , MyDat2.mx , and MyDat3.mx  \nWe can add the following folder structure:      Resources + MyTemplate.nb Data + MyDat1.mx + MyDat2.mx + MyDat3.mx     \nAnd then add the extension:      { \"Resource\", \"Resources\" -> { {\"Template\", \"MyTemplate.nb\"}, {\"Data1\", \"Data\/MyDat1.mx\"}, {\"Data2\", \"Data\/MyDat2.mx\"}, {\"Data3\", \"Data\/MyDat3.mx\"} } }    \nNow we can use      PacletResource[\"MyPaclet\", \"Template\"]     \nand we'll get the file path to the template notebook",
			"tags":"packages paclets development",
			"url":"package-usage-and-development\/paclet-development\/paclet-development.html",
			"note":""
		},
		{
			"title":"Paclet Distribution",
			"text":"‌   Paclet Distribution  \nWe can distribute paclets in either of two ways. We can distribute a packed .paclet file directly or distribute via a server.  \nWhichever route we go, though, we'll first need the .paclet file.    Creating a .paclet File  \nTo create a .paclet file we use the PackPaclet function in the \"PacletManager`\" context. We can call it one of two ways:  \nPackPaclet[dir] — creates a packed .paclet file from dir and places it in dir PackPaclet[dir, dest] — creates a packed .paclet file from dir and places it in dest  \nSay, for the sake of argument, that I am Etienne Bernard and write the Machine Learning functionality packaged into Mathematica. I can find my paclet directory like      dir = PacletFind[\"MachineLearning\"][[1]][\"Location\"] (*Out:*) \"\/Applications\/Mathematica.app\/Contents\/SystemFiles\/Components\/MachineLearning\"    \nThen this can be packed into a .paclet file like:      paclet = PackPaclet[dir, $TemporaryDirectory] (*Out:*) \"\/private\/var\/folders\/9t\/tqc70b7d61v753jkdbjkvd640000gp\/T\/MachineLearning-1.1.0.paclet\"    \nAnd now this can be distributed    Direct Distribution  \nOnce a paclet is packed it can be distributed directly as it. For instance, I can put this in on my Wolfram Cloud account:      CopyFile[ paclet, CloudObject[\"user:b3m2a1.testing\/MachineLearning.paclet\", Permissions->\"Public\"] ]\/\/Most (*Out:*) CloudObject[]    \nAnd now anyone could come along and install this with:      PacletInstall@ \"http:\/\/www.wolframcloud.com\/objects\/b3m2a1.testing\/MachineLearning.paclet\"    \nOften we want something a little more sophisticated, though.   ‌   Paclet Servers  \nPaclet servers exist to make it easy to serve many paclets from the same location. The PacletManager indexes all the paclet servers available to it and figures out where to install paclets from if simply provided with a name. Therefore it's useful for us to be able to set up our own servers.  \nTo do this we simply need to add a Paclets directory to our server and provide a compressed metadata file PacletSite.mz . Overall our server will look like:      Server PacletSite.mz Paclets Paclet1-version1.paclet Paclet1-version2.paclet Paclet2-version1.paclet ...      PacletSite.mz  \nThe paclet manager indexes the paclets on the server by looking at PacletSite.mz , which is much like a PacletInfo.m file, except instead of containing a single Paclet expression it contains a PacletSite expression that bundles up a bunch of different Paclet expressions.  \nIn all it'll look like:      PacletSite[ Paclet[ Name->\"MyPaclet1\", ... ], Paclet[ Name->\"MyPaclet2\", ... ], ... ]    \nThen this gets written to a file as an expression and ZIP compressed.  \nIn general we don't need to handle this ourselves, though, as there's a function in the PacletManager that does this. If we call PacletManager`Package`BuildPacletSiteFiles on our target directory it will do this for us.  \nFor instance, I could call:      PacletManager`Package`BuildPacletSiteFiles@ ExpandFileName@\"~\/Documents\/GitHub\/GitHubServer\"    \nAnd all of the files in the Paclets sub-folder will get indexed into a PacletSite.m and PacletSite.mz file.    Setting Up a Paclet Server  \nOnce the construction is done locally, the server should be served over HTTP if possible. Older versions of the PacletManager failed to deal appropriately with HTTPS content.  \nI tend to serve mine via the Wolfram Cloud or GitHub.  \nAn example of the former is here and the latter is here .",
			"tags":"packages paclets distribution",
			"url":"package-usage-and-development\/paclet-development\/paclet-distribution.html",
			"note":""
		},
		{
			"title":"Tips and Tricks",
			"text":"‌   Paclet Directories  \nWhen developing a paclet it can be useful to be able to test code without having to uninstall and reinstall the paclet. That's why there's a PacletDirectory* mechanism that makes this easier. We can use the function PacletDirectoryAdd to add another directory in which paclets will be looked for. When we're done with this we can use PacletDirectoryRemove to clear the directory and test what development looks like without the code being directly accessible.",
			"tags":"packages paclets development",
			"url":"package-usage-and-development\/paclet-development\/tips-and-tricks.html",
			"note":""
		},
		{
			"title":"Sample Paclet Structures",
			"text":"‌   Sample Paclets  \nIt can be unclear what type of directory\/paclet info structure we want, so we'll go over a number of the different common types.  \nKeep in mind that you can always mix-and-match with these template structures. I'm just showing how a pure, modularized paclet of each type can be constructed.    Code Paclet  \nThe most common type of paclet is one that just serves code and maybe some front-end\/system resources. To get this type of paclet up-and-running we'll take our directory structure to look something like:      MyPaclet + PacletInfo.m Kernel + init.m + Component1.m + Component2.m ... + MyPaclet.m     \nAnd the PacletInfo.m will be     Paclet[ Name -> \"MyPaclet\", Version -> \"1.0.0\", Creator -> \"me <me@me.me>\", Description -> \"A world-changing application\", Extensions ->{ {\"Kernel\", \"Root\"->\".\", \"Context\"->{\"MyPaclet`\"}} } ]     Documentation Paclet  \nSometimes we just want to distribute documentation, as it can be bulky and unwieldy. If this is the case, we'll want to use a directory structure that looks like:  \nThe most common type of paclet is one that just serves code and maybe some front-end\/system resources. To get this type of paclet up-and-running we'll take our directory structure to look something like:      Documentation_MyPaclet + PacletInfo.m Documentation English ReferencePages Symbols + SymbolPage1.nb + SymbolPage2.nb ... Guides + MyPaclet.nb + Guide1.nb ... Tutorials + Tutorial1.nb + Tutorial2.nb ...     \nAnd the PacletInfo.m will be     Paclet[ Name -> \"Documentation_MyPaclet\", Version -> \"0.0.1\", Creator -> \"me <me@me.me>\", Description -> \"Documentation for MyPaclet\", Extensions ->{ { \"Documentation\", \"Root\"->\".\", \"LinkBase\"->\"MyPaclet\", \"MainPage\"->\"Guides\/MyPaclet\" } } ]    \nWe use a small version number that won't conflict with the main MyPaclet ever    FrontEnd Paclet  \nSometimes we want to package versioned FE resources separately from a package, or simply pass around standalone palettes and stylesheets. If this is the case we want a front-end paclet, which has a directory structure like:      FrontEnd_MyPaclet + PacletInfo.m FrontEnd StyleSheets MyPaclet + StyleSheet1.nb ... Palettes MyPaclet + Palettes.nb ... SystemResources MyPaclet + SystemResource1.nb + SystemResource2.txt + SystemResource3.png ... Bitmaps MyPaclet + Bitmap1.png + Bitmap2.png ... TextResources MyPaclet + TextResource1.tr + TextResource2.tr ...     \nAnd we'd have a pretty simple PacletInfo.m     Paclet[ Name -> \"FrontEnd_MyPaclet\", Version -> \"0.0.1\", Creator -> \"me <me@me.me>\", Description -> \"FrontEnd resources for MyPaclet\", Extensions ->{ {\"FrontEnd\"} } ]     Resource Paclet  \nSometimes we want to package versioned FE resources separately from a package, or simply pass around standalone palettes and stylesheets. If this is the case we want a front-end paclet, which has a directory structure like:      Resources_MyPaclet + PacletInfo.m Resources + Resource1.mx Templates + Template1.nb + Template2.nb ... ...    \nAnd we'll have a PacletInfo.m that looks like:      Paclet[ Name -> \"Resources_MyPaclet\", Version -> \"0.0.1\", Creator -> \"me <me@me.me>\", Description -> \"Basic resources for MyPaclet\", Extensions ->{ { \"Resource\", \"Root\"->\"Resources\", \"Resources\"-> { {\"Resource1\", \"Resource1.mx\"}, {\"Template1\", \"Templates\/Template1.mx\"}, {\"Template2\", \"Templates\/Template2.mx\"} } } } ]     Data Paclet  \nBefore its curated data system got wrapped into the Entity Framework , Mathematica distributed its curated data via the DataPaclets system. These are resource paclets that simply distribute version controlled data.  \nWe can still make use of this system ourselves, though, as done here . Even if we don't want to hook into that system directly, we can make use of this kind of setup by setting up a directory like:      Data_MyPaclet + PacletInfo.m Data + MyPacletData.wdx + MyPacletHDF5Data.h5 ...     \nThen the PacletInfo.m looks almost exactly like a resource paclet      Paclet[ Name -> \"Data_MyPaclet\", Version -> \"0.0.1\", Creator -> \"me <me@me.me>\", Description -> \"Data for MyPaclet\", Extensions ->{ { \"Resource\", \"Root\"->\"Data\", \"Resources\"-> { {\"Data\", \"MyPacletData.wdx\"}, {\"HDF5Data\", \"MyPacletHDF5Data.h5\"}, ... } } } ]",
			"tags":"packages paclets development",
			"url":"package-usage-and-development\/paclet-development\/sample-paclet-structures.html",
			"note":""
		},
		{
			"title":"Installation",
			"text":"‌   Paclets  \nAs we discussed previously, paclets provide a way to distribute code, resources, and other things in Mathematica. They are the native format for this type of distribution and are tightly bound into the system.  \nPaclets can provide any or all of the following:  \nCode Resources Style Sheets Palettes Documentation  \nIn general the most common thing we'll want to provide is code, but the others are common things to distribute as well.  \nWe'll talk briefly about how to install and work with these paclets. Everything in this section requires the \"PacletManager`\" context, so, if you have to, run:      Needs[\"PacletManager`\"]      Installation  \nAs the paclet system is tightly bound into Mathematica, installation is very easy via the PacletInstall function.  \nWe can use it in a few ways:  \nPacletInstall[fileOrURL] — installs a .paclet file at the given path PacletInstall[name] — looks for and installs the paclet named name PacletInstall[{name, version}] — looks for and installs the paclet named name with version number version  \nWe can also pass a few options to PacletInstall . The main ones are:  \n\"Site\" — provides a server to look for the paclet on \"IgnoreVersion\" — installs the paclet even if a different version has already been installed  \nIf we pass a \"Site\" it should be the path to a \"paclet server\", which we'll talk about more later.  \nHere's an example of this:      PacletInstall[\"ChemTools\", \"Site\"->\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\" ] (*Out:*)       \nOnce we do this we can load the package with:      <<ChemTools`      Finding Paclets \/ Paclet Information  \nWe can use the PacletFind and PacletInformation functions to find the installed paclet and get information about a paclet. We can call PacletFind in a few ways:  \nPacletFind[name] — finds the installed paclet name PacletFind[{name, version}] — finds the installed paclet name with version number version  \nPacletFind can take a number of filters as Options :  \n\"Location\" — where to search for the paclets \"Qualifier\" — search for paclets with a given qualifier \"SystemID\" — search for paclets stated to work on a given system \"WolframVersion\" — search for paclets targeted for a given Mathematica version or verions \"Enabled\" — search for paclets that are enabled \"Loading\" — search for paclets with a given loading mode \"Creator\" — search for paclets created by a specific person\/persons \"Publisher\" — search for paclets published by a given entity \"Internal\" — search for internal paclets \"IncludeDocPaclets\" — allow paclets that only server system-level documentation to be included \"Context\" — search for paclets that serve a given context \"Extension\" — search for paclets that serve a given extension  \nHere's a way to use this. We'll make use of the fact that PacletFind will expand the \"*\" wildcard to find every paclet ending in \"Link\" which also provide the \"LibraryLink\" extension and which work in Mathematica 11.0.1 or before:      PacletFind[\"*Link\", \"Extension\"->\"LibraryLink\", \"WolframVersion\"->\"11.0.1\"] (*Out:*)       \nWe can then find information about these paclets with PacletInformation . This can be called in a few ways:  \nPacletInformation[paclet] — returns information about the Paclet expression paclet PacletInformation[name] — returns information about the first paclet found via PacletFind[name]     PacletInformation[\"DAALLink\"] (*Out:*) { \"Name\"->\"DAALLink\", \"Version\"->\"1.0\", \"BuildNumber\"->\"\", \"Qualifier\"->\"\", \"WolframVersion\"->\"11.0+\", \"SystemID\"->All, \"Description\"->\"Link to the Intel DAAL Library\", \"Category\"->\"\", \"Creator\"->\"Sebastian Bodenstein <sebastianb@wolfram.com>\", \"Publisher\"->\"\", \"Support\"->\"\", \"Internal\"->False, \"Location\"->\"\/Applications\/Mathematica.app\/Contents\/SystemFiles\/Links\/DAALLink\", \"Context\"->{\"DAALLink`\"}, \"Enabled\"->True, \"Loading\"->Automatic }     Removal  \nIf we have a paclet installed, but want to remove it, we can do so with PacletUninstall . This can be called either on a Paclet or with a name that works for PacletFind .",
			"tags":"packages paclets",
			"url":"package-usage-and-development\/paclet-usage\/installation.html",
			"note":""
		},
		{
			"title":"Paclet Servers",
			"text":"‌   Paclet Servers  \nWe talked about the basic paclet installation process before, but one place where paclets are very useful is when setup to be distributed on a server.  \nWolfram Research has a main paclet server it distributes its paclets from, but users can also create their own servers. As an example of this, some members of the Mathematica StackExchange have built a custom public paclet server that serves paclets developed by members of the community.    PacletSites  \nThe PacletManager keeps track of the active set of servers via its PacletSites system. We can see the currently configured set:      PacletSites[] (*Out:*) {PacletSite[\"http:\/\/pacletserver.wolfram.com\",\"Wolfram Research Paclet Server\",\"Local\"->False]}    \nWe can add a server via PacletSiteAdd :      PacletSiteAdd[ \"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\", \"Public paclet server\" ] (*Out:*) PacletSite[\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\",\"Public paclet server\",\"Local\"->False]    \nThis is now permanently added to the PacletSites :      PacletSites[] (*Out:*) {PacletSite[\"http:\/\/pacletserver.wolfram.com\",\"Wolfram Research Paclet Server\",\"Local\"->False],PacletSite[\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\",\"Public paclet server\",\"Local\"->False]}    \nIf we want to check for updates on our sites we can use PacletSiteUpdate to do so:      PacletSiteUpdate[\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\"] (*Out:*) PacletSite[\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\",\"Public paclet server\",\"Local\"->False]    \nFinally, if we want to remove this we can do so with PacletSiteRemove :      PacletSiteRemove[\"http:\/\/raw.githubusercontent.com\/paclets\/PacletServer\/master\"] (*Out:*) {PacletSite[\"http:\/\/pacletserver.wolfram.com\",\"Wolfram Research Paclet Server\",\"Local\"->False]}     Finding Paclets on a Server  \nWe can find paclets located on a server with PacletFindRemote . First we'll add a different paclet server:      PacletSiteAdd[\"http:\/\/www.wolframcloud.com\/objects\/b3m2a1.paclets\/PacletServer\"]; PacletSiteUpdate[\"http:\/\/www.wolframcloud.com\/objects\/b3m2a1.paclets\/PacletServer\"];     \nNow we'll look for a version of the \"BTools\" package on that server      PacletFindRemote[{\"BTools\", \"2.1.25\"}] (*Out:*)       \nNow that we're done with this we can remove it again:      PacletSiteRemove[\"http:\/\/www.wolframcloud.com\/objects\/b3m2a1.paclets\/PacletServer\"];     Installing Paclets off A Server  \nIf a paclet server has been added, it's easy to install paclets off of it, as PacletInstall will do this by default. If not, we can always pass the site in the \"Site\" option to it.",
			"tags":"packages paclets paclet servers",
			"url":"package-usage-and-development\/paclet-usage\/paclet-servers.html",
			"note":""
		},
		{
			"title":"Overview",
			"text":"‌   Undocumented Functions  \nMathematica is a sprawling system and WRI loves to brag about the number of functions in it. Unfortunately it also often under-performs due to this sprawl. Targeted, highly-specialized functions get buried deep in the system, while the most general form of the function exists at the \"System`\" level.  \nTherefore, a lot of using Mathematica well comes from taking advantage of the nominally undocumented, unsupported parts of the system.  \nTo make this easier, I've attempted to compile lists of useful undocumented functionality, separated by context.",
			"tags":"undocumented",
			"url":"reference-guides\/undocumented-contexts\/overview.html",
			"note":""
		},
		{
			"title":"Internal",
			"text":"‌   Internal  \nThe \"Internal`\" context is one of the core contexts that Mathematica uses. It's got no targeted focus, but rather appears to be a place where developers dump the cruft they don't know what to do with.    Bag  \nProvides a general purpose container that has efficient push and pop behavior. Especially useful in Compile .  \nSee here   StuffBag  \nUsed with Internal`Bag  \nSee here   BagPart  \nUsed with Internal`Bag  \nSee here   WithLocalSettings  \nAllows for a setup block that will be evaluated before a code block and a tear-down block that will evaluate no matter what errors are raised in the code block . This is highly-useful for error handling.  \nThe function GeneralUtilities`SetupTeardown provides a mild generalization on this.  \nSee here or here   InheritedBlock  \nAllows for definitions to be preserved, but otherwise uses Block semantics. Very useful for metaprogramming and overloading.  \nSee here   WithTimestampsPreserved  \nThis is a tricky function that tells the kernel to preserve some amount of old-state for efficiency\/control reasons.  \nSee here   LoadingPanel  \nThis just makes a nicely formatted panel with a 9-patch Appearance argument:      Internal`LoadingPanel@\"Hello World\" (*Out:*)        Handlers  \nA system of internal handlers for various events that occur. Generally best used with Internal`HandlerBlock .  \nSee here   HandlerBlock  \nThis acts in much the same way to the handlers, but can treat them in a Block -like fashion.    LocalizedBlock  \nLike Block but can localize some non- Symbol arguments.",
			"tags":"undocumented",
			"url":"reference-guides\/undocumented-contexts\/internal.html",
			"note":""
		},
		{
			"title":"Types",
			"text":"‌   Types  \nMathematica has 2 basic types of things in it:  \nNumbers Words  \nIt also has 2 basic ways to have multiple values together  \nLists Key-Value Sets   Numbers  \nA number is simply any number you'd like, for example:      1 (*Out:*) 1    \nIt can be real:      2.1232 (*Out:*) 2.1232`       -1.33 (*Out:*) -1.33`    \nIrrational (You can access special characters by pressing  typing a shortcut and pressing  again)      π E I (*Out:*) π (*Out:*) E (*Out:*) I    \nJust as mathematicians distinguish between integers, real numbers, and complex numbers, so does Mathematica.  \nIn general it is good practice to assume that if you can find a mathematical term on Wikipedia, you can find it on Mathematica, although its name may be a bit tough to discover.    Words  \nA word is a string of letters or other characters enclosed in double quotes. Because it's a string of characters this type is called String .  \nFor instance, we can have a single character:      \"a\" (*Out:*) \"a\"    \nOr a sequence of them:      \"abcdefg\" (*Out:*) \"abcdefg\"    \nWe can include punctuation:      \"Hi Mom!\" (*Out:*) \"Hi Mom!\"    \nAnd non-standard characters:      \"τ is my favorite irrational number\" (*Out:*) \"τ is my favorite irrational number\"    \nMathematica has a built-in set of characters:      \"\" (*Out:*) \"\"    \nFinally, a String can be of any length:      \"When in the Course of human events, it becomes necessary for one people to dissolve the political bands which have connected them with another, and to assume, among the Powers of the earth, the separate and equal station to which the Laws of Nature and of Nature's God entitle them, a decent respect to the opinions of mankind requires that they should declare the causes which impel them to the separation. - Winston Churchill (1984)\" (*Out:*) \"When in the Course of human events, it becomes necessary for one people to dissolve the political bands which have connected them with another, and to assume, among the Powers of the earth, the separate and equal station to which the Laws of Nature and of Nature's God entitle them, a decent respect to the opinions of mankind requires that they should declare the causes which impel them to the separation.\\n\\n - Winston Churchill (1984)\"     Lists  \nA List is an ordered collection of any type of thing enclosed in curly brackets, for example:      {1,2,3} (*Out:*) {1,2,3}    \nA List of String :      {\"a\",\"b\",\"c\"} (*Out:*) {\"a\",\"b\",\"c\"}    \nA mixed-type list:      {1,2,{1,2,3},{\"a\",\"b\",\"c\"},10,11,12} (*Out:*) {1,2,{1,2,3},{\"a\",\"b\",\"c\"},10,11,12}    \nWe get values from lists using the Part function, which can be typed as [[ ]] , for example:      {\"a\",\"b\",\"c\"}[[1]] (*Out:*) \"a\"    \nWe can also count from the end using negative indices      {\"a\",\"b\",\"c\"}[[-1]] (*Out:*) \"c\"     Key-Value Sets  \nA key value set is a collection of key->value pairs enclosed in <| |>  \nThese are useful for associating things by key rather than having to find them by positions, because it's associating keys and values this type is called Association , for example      <|1->\"a\",2->\"b\",3->\"c\"|> (*Out:*) <|1->\"a\",2->\"b\",3->\"c\"|>    \nWe get values using the Lookup function, which can be typed using [ ] , for example      <|1->\"a\",2->\"b\",3->\"c\"|>[1] (*Out:*) \"a\"",
			"tags":"types",
			"url":"using-mathematica\/basics\/types.html",
			"note":""
		},
		{
			"title":"Variables",
			"text":"‌   Variables   Set  \nVariables in Mathematica are simple. Just type a name and give it a value with the equals sign ( = ).  \nHere we'll set the variable thisIsAVariable     thisIsAVariable=10 (*Out:*) 10    \nWe can suppress the output by ending the line with a semicolon     thisIsAVariable=10;    \n(for those interested, the semi colon denotes that this is a CompoundExpression where the return value is Null )    SetDelayed  \nA variable can also have a \"delayed\" value. That is, its value is calculated when requested. Here we'll set the variable randomValuedVariable .  \nUse colon-equals ( := ) to do this.      randomValuedVariable:=RandomReal[];    \nWhen we ask for its value, the return value will change every time.      randomValuedVariable (*Out:*) 0.12257688426972924` randomValuedVariable (*Out:*) 0.13807713447085046`     Clear  \nThe value of a variable can be removed via Clear     Clear[randomValuedVariable]    \nThe variable now has no value      randomValuedVariable (*Out:*) randomValuedVariable     Simple expressions  \nWe can use variables in expressions to store values for us.  \nFor example, let's do a simple ideal gas law computation for the volume occupied by 2 mols of ideal gas at one atmosphere of pressure and 273 K.  \nWe'll use Mathematica's built in constant data to get the value R in L atm \/ mol K.      R$gasConstant= QuantityMagnitude[ UnitConvert[Quantity[\"MolarGasConstant\"], \"Liters\"*\"Atmospheres\"\/(\"Moles\"*\"Kelvins\")] ] (*Out:*) 0.0820573382679496654`5.937562804821409    \nThen we can set up our constants:      n$quantityOfGas=2 (*mols*); P$externalPressure=1(*atm*); T$temperatureOfGas=273 (*K*);    \nAnd finally calculate our volume:      V$volumeOccupied=n$quantityOfGas*R$gasConstant*T$temperatureOfGas\/P$externalPressure (*Out:*) 44.8033066943005173068`5.937562804821409",
			"tags":"variables",
			"url":"using-mathematica\/basics\/variables.html",
			"note":""
		},
		{
			"title":"Functions",
			"text":"‌   Functions  \nFunctions are common to all programming languages. They work exactly like the name suggests. A single input or set of inputs is mapped to a single output.  \nIn Mathematica, functions are defined using variables followed by an underscore square brackets and can be defined with either = or := , which has the same meaning as with variables.  \n= uses the immediate values of the right hand side while := recalculates these when called for.  \nThe := definition works most similarly to standard programming languages and is the definition I would suggest using by default  \nHere we'll define a simple function to add two primes using :=     primeSum[n1_, n2_] := Prime[n1] + Prime[n2] primeSum[1, 10] (*Out:*) 31    \nThe same works with plain =     primeSum[n1_, n2_] = Prime[n1] + Prime[n2] (*Out:*) Prime[n1] + Prime[n2] primeSum[1, 10] (*Out:*) 31     Differences between = and :=  \nLet’s write a more complex function that moves a position around randomly. This position could be the position of an atom, say as hydrogen. Let’s start it out at the origin.      hydrogenPosition = {0, 0, 0};    \nNow we’ll define a function to move our hydrogen around randomly and return where it is now.      moveOurH[] := Row@{ \"H is at:\", hydrogenPosition += { RandomReal[{-1, 1}], RandomReal[{-1, 1}], RandomReal[{-1, 1}] } } moveOurH[] (*Out:*) Row[{\"H is at:\", {0.524521, 0.626446, -0.705801}}] moveOurH[] (*Out:*) Row[{\"H is at:\", {0.239477, 0.598285, -1.29094}}] moveOurH[] (*Out:*) Row[{\"H is at:\", {-0.632497, 0.50078, -0.826784}}]    \nNow let’s try to do the same, but using =     hydrogenPosition = {0, 0, 0}; moveOurH[] = Row@{ \"H is at:\", hydrogenPosition += { RandomReal[{-1, 1}], RandomReal[{-1, 1}], RandomReal[{-1, 1}] } }; moveOurH[] (*Out:*) Row[{\"H is at:\", {-0.279658, -0.455241, -0.0753173}}] moveOurH[] (*Out:*) Row[{\"H is at:\", {-0.279658, -0.455241, -0.0753173}}] moveOurH[] (*Out:*) Row[{\"H is at:\", {-0.279658, -0.455241, -0.0753173}}]    \nYou’ll notice our position doesn’t change. That’s because the right hand side was evaluated as the function was defined.  \nNote that this is not always a bug. Sometimes this can be a feature as there are instances where having most values set is useful.    Function  \nThere is also a special type called Function which is defined as follows:      Function[{var1, var2, var3, ..., varn}, code]    \nThis is useful primarily in complicated code when a simple function needs to be used just once or twice and it is not worth defining a full function to do this.  \nThis form of function can also be defined as follows:      (code &)    \nwhere var1,var2,var3,...,varn are replaced by #1,#2,...,#n in the code. For example:      Function[ {a, b, c}, Grid@{ {\"a is:\", a}, {\"b is:\", b}, {\"c is:\", c} } ]    \ncould be written as:      (Grid@{ {\"a is:\", #1}, {\"b is:\", #2}, {\"c is:\", #3} } &)    \nAnd to see that they are in fact the same function:      Function[ {a, b, c}, Grid@{ {\"a is:\", a}, {\"b is:\", b}, {\"c is:\", c} } ][1, 2, 3] (*Out:*)    \n \n\"a is:\"    \n1  \n \n\"b is:\"    \n2  \n \n\"c is:\"    \n3       (Grid@{ {\"a is:\", #1}, {\"b is:\", #2}, {\"c is:\", #3} } &)[1, 2, 3] (*Out:*)    \n \n\"a is:\"    \n1  \n \n\"b is:\"    \n2  \n \n\"c is:\"    \n3    \nIn Mathematica these are known as pure functions, to distinguish them from functions defined the way we’ve done before.",
			"tags":"functions",
			"url":"using-mathematica\/basics\/functions.html",
			"note":""
		},
		{
			"title":"Loops and Scoping",
			"text":"‌   Loops and Scoping  \nFor most simple tasks (i.e. most computations a chemist has to perform), making a notebook with a bunch of input and output cells is sufficient and possibly even best.  \nHowever, sometimes the task at hand is not so simple and so we'll need to progress to more complex structures.    Table and Do  \nBoth Table and Do list over a range or a set of inputs and apply a function, example:      Table[i*i, {i, 10}] (*Out:*) {1, 4, 9, 16, 25, 36, 49, 64, 81, 100} Table[i*i, {i, {a, b, c, d, e}}] (*Out:*) {a^2, b^2, c^2, d^2, e^2}    \nThe difference is that Table returns a List while Do returns either Null or anything returned from Return  \nUsually this means one wants to use Table , however this behavior gives Do two distinct advantages. The first is that Table must return something at every step, while Do used in conjunction with Reap and Sow need not. For example let's get the prime numbers between 1 and 1000:      Reap[ Do[If[PrimeQ[i], Sow[i]], {i, 1000}] ][[2, 1]] (*Out:*) {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}    \nTable would return Null every time there wasn’t a prime meaning we’d have vastly too many outputs.  \nSecondly and most critically, Do can go over an infinite range, when used with Break or Return which acts like a While[True, body] loop, but cleaner. In general, Do can be used in this way whenever While would have been used. For example:      Do[If[RandomReal[] < .00001, Return[i]], {i, ∞}] (*Out:*) 210319    \nThis simulates the following loop:      i = 1; While[RandomReal[] > .00001, i += 1 ]; i (*Out:*) 184158    \nBut Do is a cleaner construct, owing to its automatic scoping of the i and implicit incrementor    Module, With, and Block  \nModule , With , and Block are called scoping constructs. That is, they let you use a variable or multiple variables without having to change or set them globally, or. This is easiest to show in an example:  \nConsider the following chunk of code:      a = 2; squareA[] := (a = a*a); {squareA[], squareA[], squareA[]} (*Out:*) {4, 16, 256}    \nThen check the current value of a     a (*Out:*) 256    \nNow try checking a in a Module where the variable a has been scoped      Module[{a}, a ] (*Out:*) a$736    \nNotice that the value of a is not its global value. This is because Module creates its own scope to execute the code in.  \nThis is the basic use of a scoping construct, protecting code from being influenced by the global state.  \nEach construct has its own peculiarities, but these will be discussed more later. For now, we’ll only discuss Module as its usage is the clearest.    Module  \nModule has the following form:      Module[{var1, var2, ..., varn}, codeBlock ]    \nwhere var1, var2, ..., varn are either simple variable names or variable names with initial values.  \nPast that, one can write code with Module just as one would normally.  \nConsider the following:      Module[{v1, v2 = 10, v3 = 50, v4}, v3 = 10; v4 = v3*v2; {v1, v2, v3, v4} ] (*Out:*) {v1$739, 10, 10, 100}    \nThe code executes just as one would expect, the only difference being that v1 has been renamed. If one runs the following it becomes clear how Module works:      Module[ {v1, v2 = 10, v3 = 50, v4}, v3 = 10; Clear@v4; {v1, v2, v3, v4} ] (*Out:*) {v1$740, 10, 10, v4$740}    \nAll module does is replace each variable in the first argument with the variable name followed by $i where i is an integer (given by the value of the global variable $ModuleNumber when the Module is executed).",
			"tags":"loops scoping",
			"url":"using-mathematica\/basics\/loops-and-scoping.html",
			"note":""
		},
		{
			"title":"Errors",
			"text":"‌   Errors  \nObviously code doesn’t always do what one expects it to. Often this is because the programmer or user is trying to do something wrong.  \nIn many programming languages, the code will stop evaluating and the language will return an error. In Mathematica however, one of two things will happen:    Errors as Messages  \nParticularly with built-in functions, when an error is encountered Mathematica will print an error message. For example, try evaluating the following      Plot[Sin]    \nYou’ll notice that Mathematica prints a small message telling us that Plot requires two arguments. Note however that what is returned is exactly what was input. This is because when Mathematica doesn’t now how to evaluate a function, it simply returns the function and its arguments as is.    Silent Errors  \nThis behavior, returning expressions it can’t evaluate, is critical to Mathematica programming, but can lead to some nasty bugs.  \nConsider the following:      F[a_] := \"~~Wow~~~\"    \nNow say we want to format a big grid, but replace a random element with our the result of our function:      thisCallsHereIsAFunction[b_] := Grid@ReplacePart[ Partition[Range[200], 10], {RandomInteger[20], RandomInteger[10]} -> f[b]] thisCallsHereIsAFunction[x] (*Out:*)       \nOur grid isn’t what we wanted it to be because we typed f instead of F and Mathematica saw no issue with our mistake. This is why it’s critical to check your code to make sure you typed everything correctly--Mathematica won’t do that for you.",
			"tags":"errors",
			"url":"using-mathematica\/basics\/errors.html",
			"note":""
		},
		{
			"title":"Clear",
			"text":"‌   Clear  \nBefore we can really begin working with Mathematica we also need to discuss the function Clear , which can be a life-saver.  \nIt just removes any definitions we’ve given to a symbol, which can be a bigger deal than one might think. Consider the following case:     aVariableIUsedBefore=1000; aVariableIUsedBefore[x_]:=x*10;    \n  SetDelayed::write:   Tag Integer in 1000[x_] is Protected.    \nNotice we get an error because the way Mathematica reads this, we’re trying to assign a function to the number 1000.  \nHere, though, all we need to do is use Clear and we’re good to go.      Clear[aVariableIUsedBefore]    \nSometimes we’ve made a lot of definitions and we want to Clear them all, just to prevent hard to find errors from cropping up. In this case we can do the following:      Clear[\"Global`*\"]    \nWhat this does is removes all the definitions for any symbol that looks like Global`symbolName which is usually every symbol we’ve defined.  \nSometimes we want to protect some symbols, like fundamental constants, from being erased. In this case we just need to make a symbol that doesn’t look like Global`symbolName . A useful way to do this is to put the type of thing it is before it:      Constant`PlanckConstant = 6.626*10 -34 (*J×s*);     \nThis sort of thing is discussed more at length in the Contexts section, but first let’s just see that this does what we want it to. First let’s define a bunch of things:      a = 100; b = 2.50; c[x_] = RandomReal[]*x; x[x_] := x[x]; a b c[10] x[10] (*Out:*) 100 (*Out:*) 2.5` (*Out:*) 9.548010769916973` (*Out:*) 10[10]    \nAnd now we’ll clear them:      Clear[\"Global`*\"] a b c[10] x[10] (*Out:*) a (*Out:*) b (*Out:*) c[10] (*Out:*) x[10]    \nBut our constant is fine:      Constant`PlanckConstant (*Out:*) 6.6260000000000015`*^-34    \nAnd for those who don’t want to type out a long name every time they use this constant in a problem, here’s a trick: use some variable just for the problem to which you assign the value of the constant. e.g:      Constant`SpeedOfLight=3*10 8 (*m\/s*);        h = Constant`PlanckConstant; c = Constant`SpeedOfLight; λ = 1*10^-3 (*m*); h*c\/λ (*J*) (*Out:*) 1.9878000000000004`*^-22    \nThen just clear all of this before starting the next problem:      Clear[\"Global`*\"]    \nAnd now none of that can leak into the next problem:      h c λ (*Out:*) h (*Out:*) c (*Out:*) λ",
			"tags":"clear",
			"url":"using-mathematica\/basics\/clear.html",
			"note":""
		},
		{
			"title":"Function Aliases",
			"text":"‌   Function Aliases  \nMathematica has a series of useful function aliases that make coding more concise and readable.  \nTechnically, these are called infix operators , a term that also encapsulates + , - , and * , but that’s unimportant for their usage here.    @ (Prefix)  \nThe @ alias is like a pair of square brackets. The following illustrates its usage:      N@π (*Out:*) 3.141592653589793`    \nIt only applies to a single argument however. For example, Mathematica will not evaluate the following command      N@π,12     \/@ (Map)  \n\/@ takes a function and applies to every element in a list, returning the list of results. Example:      Sin\/@(π*{0,1\/4,1\/2,3\/4,1,1+1\/4,1+1\/2,1+3\/4,2}) (*Out:*) {0,,1,,0,-,-1,-,0}    \nWhen using this alias care should be taken that the right-hand side is wrapped in parentheses, as was done above, if it’s more than just a simple list.    @@ (Apply)  \n@@ applies a function to all the arguments in a list. That is, the elements of the list become the arguments to the function. Example:      N@@{π,12} (*Out:*) 3.14159265358979323846264338327950419984`12.     \/\/ (Postfix)  \n\/\/ is more or less a reversed form of @ . Example:      π\/\/N (*Out:*) 3.141592653589793`    \nBut there is a small difference in terms of how the two work with other operators.  \nConsider you’re trying to apply the function f to the list of results generated by using g\/@{1,2,3,4} One might first try the following:      f@g\/@{1,2,3,4} (*Out:*) {f[g][1],f[g][2],f[g][3],f[g][4]}    \nThis clearly doesn’t work. f is applied to g before being mapped across {1,2,3,4} .  \nIn this case there are two options:      f@(g\/@{1,2,3,4}) (*Out:*) f[{g[1],g[2],g[3],g[4]}]    \nor      g\/@{1,2,3,4}\/\/f (*Out:*) f[{g[1],g[2],g[3],g[4]}]    \nbecause \/@ evaluates before \/\/ , this works. What is said is that \/\/ has a low precedence .  \nPrecedences for any operator can be checked using the function Precedence , if the function name is known. Function names for a given operator can be found by selecting the operator and using ––F on Mac or F1 on Windows.  \nFor example, knowing that \/\/ is an alias for the function Postfix     Precedence@Postfix (*Out:*) 70.`    \nAnd we’ll compare that to the function Prefix for which @ is an alias      Prefix\/\/Precedence (*Out:*) 640.`     ~ (Infix)  \n~ takes a function and applies it to the preceding and following arguments as follows:      π~N~12 (*Out:*) 3.14159265358979323846264338327950419984`12.    \nThis is useful and worth knowing, but it can often be cleaner simply to use @@ , potentially in combination with \/\/   @* (Composition)  \n@* takes a two functions and composes them. For example:      (f@*g)[1] (*Out:*) f[g[1]]    \nThis is particularly useful when negating a function, that is, applying the Not function to it. We can make a simple NotTrueQ function by doing this:      NotTrueQ = (Not@*TrueQ); NotTrueQ@1 NotTrueQ@False NotTrueQ@True (*Out:*) True (*Out:*) True (*Out:*) False",
			"tags":"functions aliases",
			"url":"using-mathematica\/interface\/function-aliases.html",
			"note":""
		},
		{
			"title":"Documentation",
			"text":"‌   Documentation   Getting Documentation  \nMathematica has a rich, if somewhat overly complex documentation system. To learn about a given symbol there are a few things you can do. Probably the quickest is to use the built in function Definition which prints out the description all the definitions on a symbol. You can do this by putting ? before a symbol      ?Print    \n Print[ expr ] prints expr as output.     ?Plot    \n Plot[ f ,{ x , x min , x max }] generates a plot of f as a function of x from x min to x max . Plot[{ f 1 , f 2 ,…},{ x , x min , x max }] plots several functions f i . Plot[{…, w [ f i ],…},…] plots f i with features defined by the symbolic wrapper w . Plot[…,{ x }&Element; reg ] takes the variable x to be in the geometric region reg .      ?Quantity    \n Quantity[ magnitude , unit ] represents a quantity with size magnitude and unit specified by unit . Quantity[ unit ] assumes the magnitude of the specified unit to be 1.      ?GeneralUtilities`PrintDefinitions    \n PrintDefinitions[ symbol ] creates a window containing a browseable hyperlinked listing of definitions associated with symbol .   \nTo find out the most about a symbol it’s best to use the built in documentation notebooks however. Just type a symbol name and click the  icon in the little menu that appears. This will open the Documentation Center where you can look around, find links to other functions and symbols, explanations, and most crucially examples.  \nThis menu can also be gotten by placing the cursor immediately following a symbol name or piece of one and pressing +K  \nAnother way to open the documentation center is to highlight a piece of text and press ++F. This is often more useful, as getting the icon to appear can be annoying and this also works in any environment.    Documentation Issues  \nMathematica has no automatic documentation procedure. It’s all done manually. This allows for commonly used function to be incredibly well documented, but also means that less used functions get somewhat short shrift and many aren’t documented at all (although this is often intentional, as a feature isn’t ready for prime-time)  \nAnother common problem is that Mathematica’s built in autocomplete features only match from the beginning of the word you’re typing. Say you know there should be a function that converts a number into a string, so you start typing something like NumberToString , but as you’re typing you notice Mathematica will give you NumberString , but when you check its documentation page its not what you wanted at all. For that, I provide the following helpful function using the built in function Names :      FindMySymbol[piecesOfAName__String]:= Riffle[ ConstantArray[ Alternatives[piecesOfAName], Length@{piecesOfAName} ], ___ ]\/\/ Append[#,___]&\/\/ Prepend[#,___]&\/\/ StringExpression@@#&\/\/ Names    \nAnd we’ll see that this works:      FindMySymbol[\"String\",\"To\"] (*Out:*) {\"ByteArrayToString\",\"StringToByteArray\",\"StringToStream\",\"ToString\"}    \nNotice it won’t find anything if we use all parts of our name:      FindMySymbol[\"String\",\"To\",\"Number\"] (*Out:*) {}    \nBut that’s okay. Just add or drop pieces as necessary. Or use the following and just provide a guess of your name:      GuessedSymbols[nameGuess_String, matchComponents_:2]:= With[{nameSegments= SequenceCases[ StringSplit[nameGuess, l_?UpperCaseQ:>l], s:{_?UpperCaseQ,_?(LowerCaseQ@StringTake[#,1]&)}:>StringJoin@s ]}, FindMySymbol[Sequence@@#,False]&\/@ Subsets[nameSegments,{matchComponents}]\/\/ Join@@#&\/\/DeleteDuplicates ]; GuessedSymbols[name_Symbol,matchComponents_:2]:= GuessedSymbols[ToString@name,matchComponents]    \nTo verify it works:      GuessedSymbols@\"StringToNumber\" (*Out:*) {\"ByteArrayToString\",\"StringToByteArray\",\"StringToStream\",\"ToString\",\"NumberFieldClassNumber\",\"NumberString\",\"ToNumberField\"}",
			"tags":"documentation",
			"url":"using-mathematica\/interface\/documentation.html",
			"note":""
		},
		{
			"title":"Keyboard Aliases and Special Characters",
			"text":"‌   Keyboard Aliases and Special Characters  \nAs mentioned before, there are many useful keyboard aliases. Remember that you get one by pressing  typing an alias and pressing  again.  \nHere's a partial list of them:      Pane[Column[DeleteCases[ Table[Switch[First@i, \"ia\",None, _,First@iDisplayForm@Last@i ],{i,InputAliases\/.Options[EvaluationNotebook[],InputAliases]}], None], ItemSize{1000,Automatic}, DividersCenter ], {250,250}, Scrollbars{False, True} ]    \nIt’s worth playing around with lots of different combinations through. For instance, here’s the alias for each keyboard character      Thread[Join[Alphabet[], Capitalize\/@Alphabet[]]->{ \"α\",\"β\",\"χ\",\"δ\",\"ϵ\",\"ϕ\",\"γ\",\"η\",\"ι\",\"φ\",\"κ\",\"λ\",\"μ\",\"ν\",\"ω\",\"π\",\"θ\",\"ρ\",\"σ\",\"τ\",\"υ\", \"⋁\",\"ω\",\"ξ\",\"ψ\",\"ζ\",\"Α\",\"Β\",\"Χ\",\"Δ\",\"Ε\",\"Φ\",\"Γ\",\"Η\",\"Ι\",\"J\",\"Κ\",\"Λ\",\"Μ\",\"Ν\",\"Ω\",\"Π\",\"Θ\", \"Ρ\",\"Σ\",\"Τ\",\"Υ\",\"V\",\"Ω\",\"Ξ\",\"Ψ\",\"Ζ\" }]\/\/Pane[Column[DeleteCases[ Table[Switch[First@i, \"ia\",None, _,First@iDisplayForm@Last@i ],{i,#}], None], ItemSize{1000,Automatic}, DividersCenter ], {250,250}, Scrollbars{False, True} ]&    \nOn top of these alias symbols there’s another group of symbols that can be gotten via \\[<name>]  \nFor example, by doing this with the name EscapeKey one gets the following: . There are also fun things like  \nHeartSuit: ♡ SmallCircle: ∘ CheckedBox: ☒  \nPlus a host of others. In general, any cell that will autocomplete symbol name will also autocomplete these names.  \nFinally, I’ve made a little cell that will start looking for names the moment you type the first character of the name. You can generate it with the following code. If you then press backspace while the cell is empty it will automatically print \\[ for you. Hopefully this will make searching for special characters somewhat easier.      Cell[ BoxData[\"\"], \"Code\", CellDingbat->TextData[{\"Search\", \" \", \"Cell\", \" \", \"\"}], CellEventActions->{ \"KeyDown\" :> If[ MatchQ[ And[CurrentValue[\"EventKey\"] === \" \", First[ NotebookRead[ EvaluationCell[] ] ] ], BoxData[\"\"] ], NotebookWrite[ EvaluationNotebook[], \"\\\\[ \" ] ], PassEventsDown -> True}, CodeAssistOptions->{ \"AutoPopupDelay\"->0., \"MinimalSize\"->1, \"StringCompleteEnable\"->True }, Evaluatable -> False ]\/\/CellPrint",
			"tags":"keyboard aliases special characters",
			"url":"using-mathematica\/interface\/keyboard-aliases-and-special-characters.html",
			"note":""
		},
		{
			"title":"Palettes and Toolbars",
			"text":"‌   Palettes and Toolbars  \nMathematica provides a series of toolbars and palettes.  \nToolbars are found under Window ▸ Toolbar  \nPalettes are found under the Palettes menu  \nMost useful of the toolbars for every day use is the Formatting toolbar.  \nAll of the palettes are useful, but perhaps the Writing Assistant more so than the others.",
			"tags":"palettes toolbars",
			"url":"using-mathematica\/interface\/palettes-and-toolbars.html",
			"note":""
		},
		{
			"title":"Styles",
			"text":"‌   Styles  \nDifferent cells have different styles, which you can access via the style menu ( Format \\[RightPointer] Style ) or keyboard shortcuts. Here are a few of them:  \nThere are many other styles of cells and there is even a way to change the styling of cells (as I have done to make this document appear the way it does), but for most projects and purposes, such as homework assignments, these styles suffice.",
			"tags":"styles",
			"url":"using-mathematica\/interface\/styles.html",
			"note":""
		},
		{
			"title":"Plotting",
			"text":"‌   Plotting  \nMathematica has a host of different plot functions, but usually one only needs three of them:    Plot  \nPlot takes a function as its first argument and a variable and range as its second one. Example:      Plot[Sin[x], {x, -π, π}, ImageSize -> Small] (*Out:*)       \nThe function can also be defined outside of the Plot function itself:      sinx = Sin[x]; Plot[sinx, {x, -π, π}, ImageSize -> Small] (*Out:*)       \nUser defined functions are also valid, but they must first be called on the variable one wants to use.  \nThat’s why the following fails:      mySin[x_] := Sin[x]; Plot[mySin, {x, -π, π}, ImageSize -> Small] (*Out:*)       \nBut the following will work:      mySin[x_] := Sin[x]; Plot[mySin[x], {x, -π, π}, ImageSize -> Small] (*Out:*)       \nPlot can also plot many functions simultaneously, if the first argument is a list of appropriate functions:      Plot[{Sin[x], Cos[x], Tan[x]}, {x, -π, π}, ImageSize -> Small] (*Out:*)       \nThese functions can be distinguished from each other via legends and styling. For example:      Plot[{Sin[x], Cos[x], Tan[x]}, {x, -π, π}, PlotLegends -> \"Expressions\", PlotStyle -> { Directive[Dashed, Gray], Directive[Thick, Purple], Directive[Thin, Red] }, ImageSize -> Small ] (*Out:*)        ListPlot  \nListPlot is a variant of Plot that just takes a list of values and plots them. For example, let’s plot the first 1000 primes. The function we’re using here, Table , is explained more in the next section.      ListPlot[Table[Prime[n], {n, 1000}], ImageSize -> Small] (*Out:*)       \nSimilarly to Plot , we can plot multiple data sets:      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, ImageSize -> Small] (*Out:*)       \nAnd again we can apply styling rules:      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, PlotLegends -> {\"prime n for \\ n=2,4,6,...,1000\", \"-prime n for n=1,3,5,...,999\"}, PlotStyle -> {Directive[AbsolutePointSize[5], Red], Directive[AbsolutePointSize[.1], Purple]}, ImageSize -> Small ]        (*Out:*)       \nWe can also join the points to plot out a line      ListPlot[{ Table[Prime[n], {n, Range[2, 1000, 2]}], Table[-Prime[n], {n, Range[1, 999, 2]}]}, PlotLegends -> {\"prime n for \\ n=2,4,6,...,1000\", \"-prime n for n=1,3,5,...,999\"}, PlotStyle -> {Directive[Dashed, Red], Directive[Thick, Purple]}, Joined -> True, ImageSize -> Small ]        (*Out:*)        Plot3D  \nPlot3D works just like Plot , but takes two ranges      Plot3D[Sin[x + y], {x, -π, π}, {y, 0, 2 π}, ImageSize -> Small] (*Out:*)       \nMultiple functions:      Plot3D[{Sin[x], Cos[y]}, {x, -π, π}, {y, 0, 2 π}, ImageSize -> Small] (*Out:*)       \nStyling:      Plot3D[{Sin[x], Cos[y]}, {x, -π, π}, {y, 0, 2 π}, PlotLegends -> \"Expressions\", MeshStyle -> None, PlotStyle -> { Directive[Specularity[Gray, 10], White], Directive[Purple, Specularity[Gray, 100], Opacity[.3]]}, Lighting -> \"Neutral\", ImageSize -> Small] (*Out:*)        Special Plots  \nMathematica, being the massive system it is, has more-or-less every plot type one could desire built in. Most of these will not be generally useful, but it is worth keeping in mind that any plot type one could want, like, say, a 3D point-wise density-estimating plot, Mathematica has it. See: ListDensityPlot3D .  \nThat specific plot will be useful later in finding local sinks from gradient functions and is not the kind of run-of-the-mill plot one sees everywhere.",
			"tags":"plotting",
			"url":"using-mathematica\/useful-features\/plotting.html",
			"note":""
		},
		{
			"title":"Symbolic Algebra",
			"text":"‌   Symbolic Algebra  \nAs is explained more fully in the Mathematica Programming section, the language Mathematica is built around is almost 100% symbolic, which makes it perfect for algebraic manipulations.  \nOne of the simplest examples of things one can do in Mathematica is generate and combine polynomials:      simplePolynomial[var_,order_]:= Total@Table[RandomInteger[10]*Power[var,n],{n,order}]; pX1=simplePolynomial[x,2]        4 x+6 x 2         pX2=simplePolynomial[x,2]        10 x+10 x 2         pX1+pX2        14 x+16 x 2      \nThis works just as well at any polynomial order. Here we'll add five randomly generated polynomials of order less than or equal to 15 .      Array[(simplePolynomial[x,RandomInteger[15]])&,5]\/\/Total        22 x+26 x 2 +15 x 3 +28 x 4 +10 x 5 +9 x 6 +12 x 7 +13 x 8 +19 x 9 +11 x 10 +9 x 11 +13 x 12 +6 x 13 +4 x 14      \nFor those interested, the & specifies that what comes before should be treated as a function, but absent any variables we simply get our expression as a result.    Simplify  \nFor more complex things we'll need to explicitly simplify them:      sphericalHarmonicSum=Total@Array[ SphericalHarmonicY[RandomInteger[5],RandomInteger[5],θ,ϕ]&, 5]        - E I ϕ Sin[θ]+ E 2 I ϕ Cos[θ] Sin[θ] 2 + E 2 I ϕ Cos[θ] (-1+3 Cos[θ] 2 ) Sin[θ] 2      \nWe can then have Mathematica simplify this expression for us more:      Simplify[sphericalHarmonicSum]        E I ϕ Sin[θ] (-32+2 (4+) E I ϕ Sin[2 θ]+3 E I ϕ Sin[4 θ])     \nSometimes we also need to use the function FullSimplify to get everything simplified:      FullSimplify[sphericalHarmonicSum]        E I ϕ Sin[θ] (-16+ E I ϕ (4++3 Cos[2 θ]) Sin[2 θ])     \nIt often makes sense to go for Simplify over FullSimplify , despite the fact that we can get more simplification out of FullSimplify , because sometimes the Simplify is all we need to see a pattern ourselves, while FullSimplify can over-simplify and obliterate that pattern.  \nIt's good to keep in mind that while Mathematica may know more than we do, we're still smarter than it is.    Solve  \nMathematica can also solve equations for us. We'll try this on a nice quartic polynomial:      polynomialInX=simplePolynomial[x, 4]        6 x+5 x 2 +3 x 3 +6 x 4      \nNote that there's no nice way to find the roots of this polynomial by hand. But Mathematica doesn't mind:      Solve[polynomialInX==0,x]        { {x->0},{x-> (-1-+(-94+) 1\/3 )},{x->-+- (1-I ) (-94+) 1\/3 },{x->-+- (1+I ) (-94+) 1\/3 } }     \nAs mentioned before, Mathematica knows more math than any of us. It sees a quartic polynomial and knows that by the fundamental theorem of algebra there are four solutions to this equation, we just might need to find complex solutions.  \nUsually this isn't what we want, unfortunately. Happily Mathematica can dumb itself down for us.      Solve[polynomialInX==0,x,Reals]        { {x->0},{x->Root[6+5 #1+3 #1 2 +6 #1 3 &,1]} }     \nNotice that we get this odd Root expression. That's the way Mathematica represents a perfectly exact root. We can get its numerical one of two ways. Either we make the equation inexact:      Solve[polynomialInX==0., x, Reals] { {x->-0.867733324263096`},{x->0} }    \nOr we numericize after the fact:      N[Solve[polynomialInX==0,x,Reals],6] { {x->0},{x->-0.8677333242630958819`6.} }    \nOne useful thing to know with Solve is why the results are returned so oddly. Each list is a different solution, which is more important with multivariate equations, which we'll get to, but first let's see a nice way to get out our solutions in a simple list:      x\/.N[Solve[polynomialInX==0,x,Reals],6] (*Out:*) {0,-0.8677333242630958819`6.}    \nThe \/. is an alias for ReplaceAll , which is described in more detail later in the Replacement Patterns section. For now let's just note that any time it sees var on the left hand side it looks for var->val on the right hand side and replaces var with that.  \nNow let's also see how we can plot these solutions:      Show[ Plot[polynomialInX,{x,-2,2}], ListPlot[Table[{x,0}, {x,x\/.Solve[polynomialInX==0.,x,Reals]}]] ] (*Out:*)       \nWe have to use ListPlot to plot our discrete solutions, but we can see we get the result we expect.  \nWe could even write a function that will solve the equation for an arbitrary value and plot the result:      solveAndPlot[eqInX_,val_]:= Show[ Plot[eqInX,{x,-2,2}], ListPlot[Table[{x,val}, {x,x\/.Solve[eqInX==(1.val),x,Reals]}]], PlotLabel->Row@{HoldForm[eqInX==val],\" @ \",Row@Riffle[(x\/.Solve[eqInX==(1.val),x,Reals]),\", \"]} ]; solveAndPlot[polynomialInX,50] (*Out:*)       \nBut that's getting distracted, I suppose.    Multivariate Solve  \nLet's move to multivariate equations now:      polynomialInXandY=simplePolynomial[x,3]+simplePolynomial[y,3]        8 x+2 x 2 +2 y+10 y 2 +8 y 3      \nIt can still solve this equation, although as it will admit, it may miss some solutions.      Solve[polynomialInXandY == 0,{x,y}, Reals]    \n  Solve::svars:   \"Equations may not give solutions for all \\\"solve\\\" variables.\"        { {x->ConditionalExpression[-2-,y<(-5+(829-6 ) 1\/3 +(829+6 ) 1\/3 )]},{x->ConditionalExpression[-2+,y<(-5+(829-6 ) 1\/3 +(829+6 ) 1\/3 )]},{x->-2-√(4+ (5-(829-6 ) 1\/3 -(829+6 ) 1\/3 )- (-5+(829-6 ) 1\/3 +(829+6 ) 1\/3 ) 2 - (-5+(829-6 ) 1\/3 +(829+6 ) 1\/3 ) 3 ),y-> (-5+(829-6 ) 1\/3 +(829+6 ) 1\/3 )} }     \nNote that it also gives us these odd ConditionalExpression statements. This is because the solution could branch depending on how x and y interplay. Let's just get take one of these solutions and plot it:     conditionalSoln=First[x\/.Solve[polynomialInXandY == 0.,{x,y}, Reals]]; N[conditionalSoln]    \n  Solve::svars:   \"Equations may not give solutions for all \\\"solve\\\" variables.\"       (*Out:*) ConditionalExpression[-2.`-1.` ,y<0.6609358769285026`] Plot[conditionalSoln,{y,-1,1},PlotLabel->\"Value of X for given Y\"] (*Out:*)       \nWe can force a given branch of this conditional expression, however, by telling Mathematica what it can assume.    Assumptions  \nWhen Mathematica simplifies an expression it checks what we've told it to about the expression. It does that by looking at the value of the variable $Assumptions     $Assumptions (*Out:*) True    \nThis is the default value. But we can make it assume things for us. Let's assume that y satifies our ConditionalExpression     $Assumptions=y<.5 (*Out:*) y<0.5` xAndyRoots={x,y}\/.Solve[polynomialInXandY == 0,{x,y}, Reals]\/\/First\/\/Simplify    \n  Solve::svars:   \"Equations may not give solutions for all \\\"solve\\\" variables.\"       (*Out:*) {-2-,y}    \nAnd when we're done we simply reset the $Assumptions variable. We can also apply $Assumptions to a single Simplify expression or similar, but I will leave that to you to look up on.",
			"tags":"symbolic algebra",
			"url":"using-mathematica\/useful-features\/symbolic-algebra.html",
			"note":""
		},
		{
			"title":"Calculus",
			"text":"‌   Calculus  \nMathematica is useful for many types of mathematical operations, but of particular use are derivatives and integrals.    Derivatives  \nDerivatives can be taken using either the function D or the alias pd.  \nFor example, to take the first derivative of x 2 one can use either of the following:      D[x^2,x] (*Out:*) 2 x    \nor      ∂ x x^2        (*Out:*) 2 x    \nA derivative can be taken of a derivative:      ∂ x ∂ x x^2        (*Out:*) 2    \nBut this is equivalent to a simple second derivative which Mathematica can also do:      D[x^2,{x,2}] (*Out:*) 2    \nor      ∂ x,x x^2        (*Out:*) 2    \nWe can also take derivatives in multiple variables:      ∂ x,y      \n(3 x y)\/(x^2+y^2)^(5\/2)  \nAnd then for fun let's plot this:      dxy=∂ x,y ; Plot3D[dxy,{x,-5,5},{y,-5,5}]        (*Out:*)        Integration  \nMathematica also knows how to do more integrals than any chemist is likely to need. The function for integration is Integrate although like with derivatives there is an alias via intt for indefinite integrals and dintt for definite integrals  \nExamples:      Integrate[2,x] (*Out:*) 2 x ∫2x (*Out:*) 2 x    \nAnd just to show that Mathematica observes the fundamental theorem of calculus like the rest of us:      ∫∫dxyxy    \n1\/Sqrt[x^2+y^2]  \nAnd we'll plot this guy too:      reversedxy=∫∫dxy xy; Plot3D[reversedxy,{x,-5,5},{y,-5,5}] (*Out:*)        Fun examples:  \nMathematica is a great calculus tool and it knows many types of interesting functions so we'll have it integrate the following very nasty function for us:      P 3 (cos(θ))cot(θ)P 4 (cos(θ))     \nwhere <pre >     P i (cos(θ))   \n <\/pre> is the ith Legendre polynomial in cos(θ), which is to say, a nasty polynomial with a lot of trigonometric functions which is very difficult to integrate.      Integrate[LegendreP[3,Cos[θ]]Cot[θ]D[LegendreP[4,Cos[θ]],θ],{θ,0,π}] (*Out:*) 0    \nbut Mathematica has absolutely no problem evaluating this integral. It can even tell you that switching the derivative and cot terms makes the integral impossible to evaluate.      Integrate[LegendreP[3,Cos[θ]]D[Cot[θ]LegendreP[4,Cos[θ]],θ],{θ,0,π}]        ∫ 0 π (-3 Cos[θ]+5 Cos[θ] 3 ) (- (3-30 Cos[θ] 2 +35 Cos[θ] 4 ) Csc[θ] 2 + Cot[θ] (60 Cos[θ] Sin[θ]-140 Cos[θ] 3 Sin[θ]))θ     \nAnd when it sees that it simply returns the integration expression.",
			"tags":"calculus",
			"url":"using-mathematica\/useful-features\/calculus.html",
			"note":""
		},
		{
			"title":"Built-in Data and Units",
			"text":"‌   Built-in Data and Units  \nMathematica provides access to a lot of data, most useful for chemistry is the built-in chemical, element, and isotope data and the physical constants it knows about    ElementData  \nElementData is a function that gets data on an element from Mathematica’s built in servers. For example:      (*Out:*) Quantity[1.00794, \"AtomicMassUnit\"] (*Out:*) 74    \nHere is the full list of properties to query for each element:      (*Out:*)       \nAnd here is a function to apply that to a given element      (*Out:*)       \nA list of all the elements can be generated via ElementData[] and I used that to generate a template for a periodic table. So finally here is a function that uses this template and the previously defined function to get all the possible information from ElementData.  \nSince this function calls elementProperties be sure to evaluate the definition for elementProperties before evaluating the following.      (*Out:*) periodicTable[]     IsotopeData  \nIsotopeData is similar to ElementData except one supplies an isotope instead. Known isotopes for a given element can be gotten via the following function      (*Out:*) {\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"H7\"}    \nWe can similarly get all the properties for an isotope in the same way as for an element:      (*Out:*)        ChemicalData  \nThe final useful data set is the built in ChemicalData which can return properties of chemicals generally. At this point it should be clear how it works, but it’s worth pointing out that the list of all the known chemicals can take a long time to load so only call ChemicalData without any arguments if you’re sure your internet connection is good and your computer can handle the load.    Quantity  \nThe interface to the units Mathematica knows about is called Quantity  \nThis was used previously to get the value of the molar gas constant, but there is a host of useful units built in. For example let’s convert between a wavelength and a frequency for electromagnetic radiation:  \nLet’s start out with green light. Let’s find a frequency that works using Mathematica’s built-in ColorData , which knows the frequencies of the visible spectrum.  \nUnfortunately this can only convert from a wavelength to a color, but we can write a function to get close to the appropriate wavelength, knowing that in Mathematica a color is just RGBColor[redPercentage,greenPercentage,bluePercentage] .  \nFirst we write a distance function:  \nThen we get the minimum distance to our given color of all the wavelengths in the visible spectrum: (for convenience I use a more complicated function declaration syntax, which is explained later)      (*Out:*) Quantity[541, \"Nanometers\"]    \nWe can check that this is in fact a wavelength that corresponds to green light:      (*Out:*)       \nThen we’ll convert this to a frequency by recalling c=λν      (*Out:*) Quantity[5.54145*10^14, \"Hertz\"]    \nAnother place this is incredibly useful is for simple unit conversion problems, such as a classic PV=nRT application. Here’s a sample problem I found online:  \nDetermine the volume of occupied by 2.34 grams of carbon dioxide gas at STP.  \nWe can solve this trivially using this built-in data:      (*Out:*) Quantity[1.1911, \"Liters\"]    \nIt performs all the tedious conversions and has all the data. All we need to do is supply the formula.",
			"tags":"curated data units",
			"url":"using-mathematica\/useful-features\/builtin-data-and-units.html",
			"note":""
		}
	]
}